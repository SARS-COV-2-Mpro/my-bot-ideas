 name: Send Trade Ideas (10/10 Auto-RRR, 3h Cooldown)

on:
  schedule:
    - cron: "*/10 * * * *"
  workflow_dispatch: {}

jobs:
  push-ideas:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - run: npm i node-fetch@3
      - name: Push Ideas
        env:
          WORKER_PUSH_URL: ${{ secrets.WORKER_PUSH_URL }}
          PUSH_TOKEN: ${{ secrets.PUSH_TOKEN }}
          FEES_BPS: ${{ vars.FEES_BPS }}          # e.g., 6–8 futures taker, 20–30 spot
          NOTIONAL_USD: ${{ vars.NOTIONAL_USD }}  # e.g., 3000–10000
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}   # optional (recommended) for state/learning
          GIST_ID: ${{ secrets.GIST_ID }}
        run: |
          node - <<'NODE'
          import("node-fetch").then(async ({default: fetch})=>{
            const BASE="https://api.binance.com";

            // ---------- Config ----------
            const MIN_QV = 25_000_000;         // min 24h quote volume (USDT)
            const UNIVERSE = 50;               // top-N by liquidity to scan
            const MAX_SPREAD = 0.002;          // 20 bps spread cap
            const BASE_MAX_IDEAS = 10;         // max ideas per run (pre-throttle)
            const CORR_WIN = 36;               // 36 x 5m = 3h correlation window
            const CORR_MAX = 0.85;             // de-dup threshold
            const CLUSTER_THRESH = 0.80;       // corr clustering threshold
            const CLUSTER_MAX_PICKS = 3;       // per cluster cap
            const SECTOR_MAX_PICKS = 3;        // per sector cap
            const BETA_CAP_BASE = 1.8, BETA_CAP_SLOPE = 0.35; // BTC beta budget
            const COST_BPS = Number(process.env.FEES_BPS||"6");   // round-trip bps
            const NOTIONAL = Number(process.env.NOTIONAL_USD||"5000"); // USD notional for slippage
            const TARGET_PORT_RISK_BPS = 50;   // risk budget (bps) per batch

            // Indicators / data windows
            const EMA_FAST = 21, EMA_SLOW = 50;
            const ADX_P = 14, ATR_P = 14;
            const K5M = 120, K15M = 96, K1M = 200;
            const VWAP_5M_WIN = 36;

            // Controls / safety
            const PENDING_EVAL_LIMIT = 32;
            const COOLDOWN_MS = 3 * 60 * 60 * 1000;   // 3 hours cooldown per symbol
            const DD_24H_LIMIT_BPS = -150;     // throttle if 24h PnL below this
            const DD_PEAK_LIMIT_BPS = -300;    // harder throttle if peak DD below this
            const WILSON_Z = 1.28;             // ~80% lower confidence bound
            const MIN_EXP_LCB_BPS = 1;         // require positive conservative edge

            // Auto-RRR bounds/bases (ATR multiples; finalized per-trade in bps)
            const TP_ATR_MIN = 0.40, TP_ATR_MAX = 2.00;
            const SL_ATR_MIN = 0.30, SL_ATR_MAX = 1.50;
            const TP_TREND_BASE = 1.00, SL_TREND_BASE = 0.575;
            const TP_MR_BASE    = 0.60, SL_MR_BASE    = 0.55;

            const STABLES = new Set(["USDT","BUSD","USDC","TUSD","FDUSD","DAI","USDP","PAX","USTC"]);
            const isLev = (base)=> /(UP|DOWN|BULL|BEAR)$/.test(base) || /([235]L|[235]S)$/.test(base);

            // Sector tags (extend as needed)
            const SECTOR_TAGS = {
              BTC:"L1", ETH:"L1", BNB:"Exchange", XRP:"Payments", ADA:"L1", SOL:"L1", DOT:"L1", AVAX:"L1",
              MATIC:"L2", OP:"L2", ARB:"L2", TON:"L1", NEAR:"L1", ATOM:"L1", APT:"L1", SUI:"L1", SEI:"L1", TIA:"L1",
              LTC:"Payments", BCH:"Payments", XLM:"Payments", TRX:"L1", XMR:"Privacy", ZEC:"Privacy",
              DOGE:"Meme", SHIB:"Meme", PEPE:"Meme", FLOKI:"Meme",
              UNI:"DeFi", AAVE:"DeFi", MKR:"DeFi", COMP:"DeFi", CRV:"DeFi", SUSHI:"DeFi", CAKE:"DeFi", RUNE:"DeFi", SNX:"Derivatives",
              DYDX:"Derivatives", GMX:"Derivatives", INJ:"Infra", LINK:"Oracle", PYTH:"Oracle",
              LDO:"LiquidStaking", RPL:"LiquidStaking",
              IMX:"Gaming", AXS:"Gaming", SAND:"Metaverse", MANA:"Metaverse",
              FIL:"Storage", AR:"Storage", ICP:"L1", EGLD:"L1", HBAR:"L1", ROSE:"L1", MINA:"L1", KAVA:"L1",
              GRT:"AI", FET:"AI", RNDR:"AI", AKT:"Infra", ENS:"Infra", WOO:"CeFi", OKB:"Exchange", BSV:"Payments", KAS:"PoW"
            };
            const sectorOf = (base)=> SECTOR_TAGS[base] || "Other";

            // ---------- Helpers ----------
            const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
            const tanh=(x)=>Math.tanh(x);
            const sigmoid=(z)=>1/(1+Math.exp(-z));
            const ema=(arr,p)=>{ if(arr.length<p) return null; const k=2/(p+1); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; for(let i=p;i<arr.length;i++) e=arr[i]*k+e*(1-k); return e; };
            const rsi=(cl,p=14)=>{ if(cl.length<=p) return null; let g=0,l=0; for(let i=1;i<=p;i++){ const d=cl[i]-cl[i-1]; g+=d>0?d:0; l+=d<0?-d:0; } let ag=g/p, al=l/p; for(let i=p+1;i<cl.length;i++){ const d=cl[i]-cl[i-1]; ag=(ag*(p-1)+(d>0?d:0))/p; al=(al*(p-1)+(d<0?-d:0))/p; } const rs=al===0?100:ag/al; return 100-100/(1+rs); };
            const computeADX_ATR=(h,l,c,p=14)=>{ const n=c.length; if(n<p+2) return null; const TR=[],plusDM=[],minusDM=[]; for(let i=1;i<n;i++){ const up=h[i]-h[i-1], down=l[i-1]-l[i]; plusDM.push((up>down&&up>0)?up:0); minusDM.push((down>up&&down>0)?down:0); TR.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1]))); }
              let trN=0,pdmN=0,ndmN=0; for(let i=0;i<p;i++){ trN+=TR[i]; pdmN+=plusDM[i]; ndmN+=minusDM[i]; }
              let pDI=100*(pdmN/(trN||1)), nDI=100*(ndmN/(trN||1)); let dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1), adx=dx;
              for(let i=p;i<TR.length;i++){ trN=trN-(trN/p)+TR[i]; pdmN=pdmN-(pdmN/p)+plusDM[i]; ndmN=ndmN-(ndmN/p)+minusDM[i];
                pDI=100*(pdmN/(trN||1)); nDI=100*(ndmN/(trN||1)); dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1); adx=((adx*(p-1))+dx)/p; }
              const atr=trN/p; return { adx, atr };
            };
            const vwapAnchored5m=(h,l,c,v,win=VWAP_5M_WIN)=>{ const n=c.length,s=Math.max(0,n-win); let pv=0,vv=0; for(let i=s;i<n;i++){ const tp=(h[i]+l[i]+c[i])/3; const vol=+v[i]||0; pv+=tp*vol; vv+=vol; } return vv>0?pv/vv:c.at(-1); };
            const corr=(a,b)=>{ const n=Math.min(a.length,b.length); if(n<3) return 0; const as=a.slice(-n), bs=b.slice(-n); const ma=as.reduce((x,y)=>x+y,0)/n, mb=bs.reduce((x,y)=>x+y,0)/n; let num=0,da=0,db=0; for(let i=0;i<n;i++){ const xa=as[i]-ma, xb=bs[i]-mb; num+=xa*xb; da+=xa*xa; db+=xb*xb; } const den=Math.sqrt(da*db); return den===0?0:num/den; };
            const betaTo=(a,b)=>{ const n=Math.min(a.length,b.length); if(n<3) return 0; const as=a.slice(-n), bs=b.slice(-n); const ma=as.reduce((x,y)=>x+y,0)/n, mb=bs.reduce((x,y)=>x+y,0)/n; let cov=0,varb=0; for(let i=0;i<n;i++){ const xa=as[i]-ma, xb=bs[i]-mb; cov+=xa*xb; varb+=xb*xb; } return varb===0?0:(cov/varb); };
            const processInBatches=async(items,batch,fn)=>{ const out=[]; for(let i=0;i<items.length;i+=batch){ const res=await Promise.all(items.slice(i,i+batch).map(fn)); out.push(...res); } return out; };
            const fetchK=async(sym,interval,limit,start,end)=>{ const u=new URL(`${BASE}/api/v3/klines`); u.searchParams.set("symbol",sym); u.searchParams.set("interval",interval); if(limit) u.searchParams.set("limit",String(limit)); if(start) u.searchParams.set("startTime",String(start)); if(end) u.searchParams.set("endTime",String(end)); const r=await fetch(u.toString()); if(!r.ok) return null; const k=await r.json(); return Array.isArray(k)?k:null; };
            const wilsonLCB=(p,n,z=1.28)=>{ if(n<=0) return p; const z2=z*z; const a=p + z2/(2*n); const b=z*Math.sqrt((p*(1-p)+z2/(4*n))/n); const c=1+z2/n; return clamp((a-b)/c, 0, 1); };

            // Online logistic model (Adagrad-L2)
            const defaultML=()=>({ w:{}, b:0, g2:{}, gb2:1e-6, lr:0.05, l2:0.0005, n_trained:0 });
            const dot=(w,x)=>{ let s=0; for(const k in x){ const v=x[k]; if(!isFinite(v)) continue; s += (w[k]||0)*v; } return s; };
            const predictML=(ml,x)=>sigmoid(dot(ml.w,x)+ml.b);
            const updateML=(ml,x,y)=>{ const p=predictML(ml,x); const gradB=(p-y); ml.gb2+=gradB*gradB; ml.b -= (ml.lr/Math.sqrt(ml.gb2))*(gradB + ml.l2*ml.b); for(const k in x){ const g=(p-y)*x[k] + ml.l2*(ml.w[k]||0); ml.g2[k]=(ml.g2[k]||1e-6)+g*g; ml.w[k]=(ml.w[k]||0) - (ml.lr/Math.sqrt(ml.g2[k]))*g; } ml.n_trained++; };

            // Auto-RRR (decide TP/SL at entry, fixed after)
            const computeAutoRRR = ({ regime, p, adx, atr_bps, cost_bps, spread_bps, trend_align=false })=>{
              const adxF = clamp((adx - 16)/14, 0, 1); // 0 at 16 ADX, 1 at 30+
              // Preferred ratio: higher in trend/strong ADX, modest in MR
              let prefR = regime==="trend" ? (1.4 + 0.8*adxF) : (1.05 + 0.20*(1-adxF));
              prefR *= (1 + 0.4*clamp(p - 0.55, -0.2, 0.35)); // nudge by confidence
              prefR = clamp(prefR, regime==="trend" ? 1.1 : 0.9, 2.5);

              // Base SL in ATR; widen on weak trend/wide spreads; tighten on strong alignment
              let slATR = (regime==="trend" ? SL_TREND_BASE : SL_MR_BASE);
              slATR *= (1 + 0.25*(1 - adxF));
              if(spread_bps > 12) slATR *= 1.10;
              if(regime==="trend" && trend_align && adxF>0.6 && p>0.62) slATR *= 0.90;
              slATR = clamp(slATR, SL_ATR_MIN, SL_ATR_MAX);

              const tpATRmin = TP_ATR_MIN, tpATRmax = TP_ATR_MAX;
              const slMinBps = SL_ATR_MIN*atr_bps, slMaxBps = SL_ATR_MAX*atr_bps;
              const tpMaxBps = tpATRmax*atr_bps, tpMinBps = tpATRmin*atr_bps;
              let sl = clamp(Math.round(slATR*atr_bps), Math.round(slMinBps), Math.round(slMaxBps));

              const edgeTarget = 0; // set >0 if you want minimum after-cost expectancy in bps
              for(let k=0;k<4;k++){
                const rMin = ((1 - p)/p) + (cost_bps + edgeTarget)/(Math.max(1e-6, p*sl));
                let r = Math.max(prefR, rMin);
                const rMax = tpMaxBps / sl;
                if(r <= rMax){
                  let tp = Math.round(clamp(r*sl, tpMinBps, tpMaxBps));
                  if(tp < cost_bps + 2) tp = cost_bps + 2;
                  const exp = Math.round(p*tp - (1-p)*sl - cost_bps);
                  if(exp <= 0 && k<3){
                    const denom = (p*r - (1-p));
                    if(denom > 0){
                      const needSL = Math.ceil((cost_bps + edgeTarget)/denom);
                      const newSL = clamp(Math.max(sl, needSL), Math.round(slMinBps), Math.round(slMaxBps));
                      if(newSL > sl){ sl = newSL; continue; }
                    }
                  }
                  return {
                    tp_bps: tp,
                    sl_bps: sl,
                    r_used: +(tp/sl).toFixed(2),
                    tp_atr: +(tp/atr_bps).toFixed(2),
                    sl_atr: +(sl/atr_bps).toFixed(2)
                  };
                }
                const nextSL = Math.min(Math.round(sl*1.15), Math.round(slMaxBps));
                if(nextSL === sl) break; else sl = nextSL;
              }
              const tp = Math.round(tpMaxBps);
              const r = tp / sl;
              const exp = Math.round(p*tp - (1-p)*sl - cost_bps);
              if(exp <= 0) return null;
              return {
                tp_bps: tp,
                sl_bps: sl,
                r_used: +(r).toFixed(2),
                tp_atr: +(tp/atr_bps).toFixed(2),
                sl_atr: +(sl/atr_bps).toFixed(2)
              };
            };

            // ---------- State (Gist) ----------
            const loadState = async ()=>{
              const token=process.env.GIST_TOKEN, id=process.env.GIST_ID;
              const init = {
                v:"10/10-autoRRR-3h",
                buckets:{
                  trend_long:{a:50,b:50}, trend_short:{a:50,b:50},
                  meanrevert_long:{a:50,b:50}, meanrevert_short:{a:50,b:50}
                },
                experts:{ trend:{a:50,b:50}, meanrevert:{a:50,b:50}, ml:{a:50,b:50} },
                pairs:{}, pending:[], cooldown:{}, equity:[], ml: defaultML(), last_ts:null
              };
              if(!token||!id) return { state:init, persist:false };
              try{
                const r=await fetch(`https://api.github.com/gists/${id}`,{headers:{Authorization:`Bearer ${token}`,"Accept":"application/vnd.github+json"}});
                if(!r.ok) throw new Error("gist fetch "+r.status);
                const g=await r.json(); const file=g.files?.["state.json"]?.content;
                if(!file) return { state:init, persist:{id,token} };
                const state=JSON.parse(file);
                if(!state.ml) state.ml=defaultML();
                if(!state.experts) state.experts={ trend:{a:50,b:50}, meanrevert:{a:50,b:50}, ml:{a:50,b:50} };
                if(!state.equity) state.equity=[];
                if(!state.cooldown) state.cooldown={};
                return { state, persist:{id,token} };
              }catch{ return { state:init, persist:false }; }
            };
            const saveState = async (persist, state)=>{
              if(!persist) return;
              try{
                await fetch(`https://api.github.com/gists/${persist.id}`,{
                  method:"PATCH",
                  headers:{Authorization:`Bearer ${persist.token}`,"Accept":"application/vnd.github+json","Content-Type":"application/json"},
                  body: JSON.stringify({ files: { "state.json": { content: JSON.stringify(state) } } })
                });
              }catch(e){ console.warn("Failed to save gist state:", e?.message||e); }
            };

            const evalPending = async(state)=>{
              const pend = state.pending||[];
              const done=[], keep=[];
              const now=Date.now();
              for(const p of pend){
                if(done.length>=PENDING_EVAL_LIMIT){ keep.push(p); continue; }
                const deadline = p.ts_ms + p.hold_sec*1000;
                if(now < deadline + 5000){ keep.push(p); continue; }
                const start = p.ts_ms - 60*1000, end = p.ts_ms + p.hold_sec*1000 + 60*1000;
                const k = await fetchK(p.symbolFull,"1m",K1M,start,end);
                if(!k || k.length<2){ keep.push(p); continue; }
                const highs=k.map(x=>+x[2]), lows=k.map(x=>+x[3]), closes=k.map(x=>+x[4]);
                const entry = p.entry_price;
                const tp = p.tp_bps/10000, sl = p.sl_bps/10000;
                const long = p.side==="long";
                let exitPx = closes.at(-1), hit=null;
                for(let i=0;i<k.length;i++){
                  const hi=highs[i], lo=lows[i];
                  if(long){
                    if(hi >= entry*(1+tp)){ hit="TP"; exitPx = entry*(1+tp); break; }
                    if(lo <= entry*(1-sl)){ hit="SL"; exitPx = entry*(1-sl); break; }
                  }else{
                    if(lo <= entry*(1-tp)){ hit="TP"; exitPx = entry*(1-tp); break; }
                    if(hi >= entry*(1+sl)){ hit="SL"; exitPx = entry*(1+sl); break; }
                  }
                }
                const ret = long ? (exitPx/entry - 1) : (entry/exitPx - 1);
                const pnl_bps = Math.round(ret*10000) - (p.cost_bps||0);
                done.push({ ...p, hit:hit||"TIME", exit_px: exitPx, pnl_bps });
              }
              for(const d of done){
                const key = `${d.regime}_${d.side}`;
                state.buckets[key] = state.buckets[key] || {a:50,b:50};
                if(d.pnl_bps>0) state.buckets[key].a += 1; else state.buckets[key].b += 1;
                if(d.expert && state.experts[d.expert]){
                  if(d.pnl_bps>0) state.experts[d.expert].a += 1; else state.experts[d.expert].b += 1;
                }
                const ps = state.pairs[d.base] || { n:0, wins:0, pnl_sum_bps:0 };
                ps.n += 1; if(d.pnl_bps>0) ps.wins += 1; ps.pnl_sum_bps += d.pnl_bps; state.pairs[d.base] = ps;
                if(d.features && state.ml){ const y = d.pnl_bps>0 ? 1 : 0; updateML(state.ml, d.features, y); }
                state.equity.push({ ts_ms: d.ts_ms, pnl_bps: d.pnl_bps });
              }
              state.pending = keep;
              if(state.equity.length>4000) state.equity = state.equity.slice(-4000);
              return done;
            };

            const equityStats = (eq, nowMs)=>{
              const dayAgo = nowMs - 24*60*60*1000;
              let pnl24=0; for(const e of eq){ if(e.ts_ms>=dayAgo) pnl24+=e.pnl_bps; }
              let cum=0, peak=0, dd=0; for(const e of eq){ cum+=e.pnl_bps; if(cum>peak) peak=cum; dd=Math.min(dd, cum-peak); }
              return { pnl24_bps: Math.round(pnl24), peak_dd_bps: Math.round(dd) };
            };

            const estimateSlippageBps = async(symbol, notionalUSD, book, fetchDepth)=>{
              try{
                const mid=(book.bid+book.ask)/2;
                const r=await fetchDepth(symbol); if(!r||!r.bids||!r.asks) {
                  return { longBps: Math.round((book.ask-mid)/mid*10000), shortBps: Math.round((mid-book.bid)/mid*10000) };
                }
                const target = Math.max(100, notionalUSD);
                const vwapPrice = (levels, targetUSD)=>{
                  let remain = targetUSD, sumNotional=0, sumQty=0;
                  for(const [pStr,qStr] of levels){
                    const price=+pStr, qty=+qStr; if(!isFinite(price)||!isFinite(qty)||price<=0||qty<=0) continue;
                    const levelNotional = price*qty;
                    const take = Math.min(remain, levelNotional);
                    const takeQty = take / price;
                    sumNotional += take;
                    sumQty += takeQty;
                    remain -= take;
                    if(remain <= 1e-6) break;
                  }
                  return sumQty>0 ? (sumNotional/sumQty) : null;
                };
                const buyPx = vwapPrice(r.asks, target);
                const sellPx= vwapPrice(r.bids, target);
                const longBps = buyPx ? Math.max(0, Math.round((buyPx - mid)/mid*10000)) : Math.round((book.ask-mid)/mid*10000);
                const shortBps= sellPx ? Math.max(0, Math.round((mid - sellPx)/mid*10000)) : Math.round((mid-book.bid)/mid*10000);
                return { longBps, shortBps };
              }catch{ return { longBps: 10, shortBps: 10 }; }
            };

            try{
              const now = Date.now();

              // 1) Universe by liquidity
              const r24 = await fetch(`${BASE}/api/v3/ticker/24hr`); if(!r24.ok) throw new Error("24hr fetch failed "+r24.status);
              const all = await r24.json();
              const usdt = all.filter(t => (t.symbol||"").endsWith("USDT"));
              const raw = usdt.map(t=>({ symbol:t.symbol, base:t.symbol.slice(0,-4), qv:+(t.quoteVolume||0) }))
                              .filter(x => x.qv>=MIN_QV && !STABLES.has(x.base) && !isLev(x.base) && !/.*(UP|DOWN)USDT$/.test(x.symbol));
              raw.sort((a,b)=> b.qv - a.qv);
              const universe = raw.slice(0, UNIVERSE);
              if(universe.length===0) throw new Error("No candidates after filters");

              // 2) Spreads & depth
              const br = await fetch(`${BASE}/api/v3/ticker/bookTicker`); if(!br.ok) throw new Error("bookTicker fetch failed "+br.status);
              const books = await br.json();
              const bookMap = new Map(books.map(b=>[b.symbol,{ bid:+b.bidPrice, ask:+b.askPrice }]));
              const fetchDepth = async (sym)=>{ const r=await fetch(`${BASE}/api/v3/depth?symbol=${sym}&limit=10`); if(!r.ok) return null; return await r.json(); };

              // Liquidity percentile
              const liqPct = new Map();
              for(let i=0;i<universe.length;i++){
                liqPct.set(universe[i].symbol, (universe.length===1)?1:1 - i/(universe.length-1));
              }

              // 3) Market regime via BTC/ETH 15m
              const kBTC15 = await fetchK("BTCUSDT","15m",K15M);
              const kETH15 = await fetchK("ETHUSDT","15m",K15M);
              const mkRegime = ()=>{
                const build=(k)=>{ if(!k||k.length<ADX_P+5) return null; const h=k.map(x=>+x[2]), l=k.map(x=>+x[3]), c=k.map(x=>+x[4]); const cL=c.at(-1), cPrev=c.at(-5); const roc60m=(cL/cPrev)-1; const { adx }=computeADX_ATR(h,l,c,ADX_P)||{}; return { adx:adx||0, roc60m }; };
                const b=build(kBTC15), e=build(kETH15);
                const adxAvg=((b?.adx||0)+(e?.adx||0))/2;
                const dir = Math.sign((b?.roc60m||0)+(e?.roc60m||0));
                const trend = adxAvg>=22 && Math.abs((b?.roc60m||0))>0.001 && Math.abs((e?.roc60m||0))>0.001;
                const uncertain = adxAvg>=18 && adxAvg<=22;
                return { regime: trend ? "trend" : "meanrevert", adxAvg, dir, uncertain };
              };
              const market = mkRegime();

              // 4) BTC beta base
              const kBTC5 = await fetchK("BTCUSDT","5m",K5M);
              const btcCl5 = kBTC5?.map(x=>+x[4])||[];
              const btcRet5 = (btcCl5.length? btcCl5.slice(1).map((c,i)=>Math.log(c/btcCl5[i])):[]);

              // 5) Load state + evaluate pending
              const { state, persist } = await loadState();
              await evalPending(state);
              const { pnl24_bps, peak_dd_bps } = equityStats(state.equity, now);
              const throttle = (pnl24_bps<=DD_24H_LIMIT_BPS) || (peak_dd_bps<=DD_PEAK_LIMIT_BPS);
              const maxIdeas = Math.min(BASE_MAX_IDEAS, throttle ? 5 : (market.uncertain ? 6 : BASE_MAX_IDEAS));

              // Funding boundary gating
              const mins = new Date().getUTCMinutes();
              const hours = new Date().getUTCHours();
              const nearFunding = ([0,8,16].includes(hours) && (mins<=2 || mins>=58));
              const maxIdeasFinal = nearFunding ? Math.min(maxIdeas, 6) : maxIdeas;

              // 6) Analyze candidates
              const analyze = async(c)=>{
                try{
                  // 3h cooldown gate (skip symbols picked within last 3 hours)
                  const lastPickTs = state.cooldown?.[c.base];
                  if (lastPickTs && (now - lastPickTs) < COOLDOWN_MS) return null;

                  const bk=bookMap.get(c.symbol); if(!bk||!bk.bid||!bk.ask) return null;
                  const mid=(bk.bid+bk.ask)/2; if(mid<=0) return null;
                  const spread=(bk.ask - bk.bid)/mid; if(spread>MAX_SPREAD) return null;
                  const spreadBps = Math.round(spread*10000);

                  // Slippage at your notional
                  const slip = await estimateSlippageBps(c.symbol, NOTIONAL, bk, async (sym)=>fetchDepth(sym));

                  const k5=await fetchK(c.symbol,"5m",K5M); if(!k5||k5.length<Math.max(EMA_SLOW+5, ATR_P+5)) return null;
                  const o=k5.map(x=>+x[1]), h=k5.map(x=>+x[2]), l=k5.map(x=>+x[3]), cl=k5.map(x=>+x[4]), v=k5.map(x=>+x[5]);
                  const last=cl.at(-1), prev=cl.at(-2), prev3=cl.at(-4); if(!last||!prev||!prev3) return null;

                  const e21=ema(cl,EMA_FAST), e50=ema(cl,EMA_SLOW);
                  const adxo=computeADX_ATR(h,l,cl,ADX_P); if(!adxo) return null;
                  const { adx, atr } = adxo;
                  const atr_bps = (atr/last)*10000;
                  if(atr_bps<4 || atr_bps>220) return null;
                  const lastBody=Math.abs(cl.at(-1)-o.at(-1)); if((lastBody/atr)>2.2) return null;

                  const vwap=vwapAnchored5m(h,l,cl,v,VWAP_5M_WIN);
                  const rsi14=rsi(cl,14);
                  const z_vwap = (last-vwap)/(atr||1);
                  const roc5=(last/prev)-1, roc15=(last/prev3)-1;
                  const adxF = clamp((adx-16)/14,0,1);

                  // Experts
                  const momentum = 0.6*roc5 + 0.4*roc15;
                  const sideTrend = momentum>=0 ? "long" : "short";
                  const upF = last>=e21, upS = last>=e50;
                  const trendAlign = (sideTrend==="long" && upF && upS) || (sideTrend==="short" && !upF && !upS);
                  const s1=tanh(roc5/0.0030), s2=tanh(roc15/0.0065);
                  let pTrend = clamp(0.5 + 0.24*(0.6*s1+0.4*s2)*(trendAlign?1.0:0.7)*adxF, 0.32, 0.90);

                  const sideMR = z_vwap>0 ? "short" : "long";
                  const rsiEdge=(rsi14!=null)?(rsi14-50)/50:0;
                  const sMR = tanh(Math.abs(z_vwap))*Math.sign(-z_vwap);
                  let pMR = clamp(0.5 + 0.22*(0.7*sMR + 0.3*(-rsiEdge))*(1-adxF), 0.35, 0.90);

                  // Tape bias
                  const tapeAdj = (market.adxAvg>=22 ? 0.03 : 0.015);
                  const tapeBiasTrend = (market.dir>=0 ? (sideTrend==="long"?+1:-1) : (sideTrend==="short"?+1:-1));
                  const tapeBiasMR    = (market.dir>=0 ? (sideMR==="long"?+1:-1) : (sideMR==="short"?+1:-1));
                  pTrend = clamp(pTrend + tapeAdj*tapeBiasTrend, 0.30, 0.90);
                  pMR    = clamp(pMR + 0.5*tapeAdj*tapeBiasMR, 0.30, 0.90);

                  // BTC beta, liquidity
                  const ret5=[]; for(let i=1;i<cl.length;i++){ ret5.push(Math.log(cl[i]/cl[i-1])); }
                  const betaBTC = betaTo(ret5.slice(-CORR_WIN), btcRet5.slice(-CORR_WIN));
                  const liq = liqPct.get(c.symbol)||0.5;

                  // ML expert
                  const buildFeat = (side)=>{
                    const dir = side==="long" ? +1 : -1;
                    const mom5 = tanh(roc5/0.0030) * dir;
                    const mom15= tanh(roc15/0.0065) * dir;
                    const trendOk = ((side==="long" && upF && upS) || (side==="short" && !upF && !upS)) ? 1 : -1;
                    const vwapEdge = (side==="long" ? -z_vwap : z_vwap);
                    const vwapEdgeN = clamp(vwapEdge/2, -1, 1);
                    const rsiEdgeDir = (side==="long" ? -rsiEdge : rsiEdge);
                    const adxZ = adxF*2 - 1;
                    const sNorm = -clamp((spreadBps - 5)/20, 0, 1);
                    const liqZ = (liq - 0.5)*2;
                    const tape = (market.dir>=0 ? (side==="long"?+1:-1) : (side==="short"?+1:-1));
                    return {
                      mom5, mom15, trendOk, vwapEdge:vwapEdgeN, rsiEdge:rsiEdgeDir,
                      adxZ, spreadPen:sNorm, liqZ, tapeBias:tape,
                      regimeTrend: market.regime==="trend"?1:0,
                      regimeMR: market.regime==="meanrevert"?1:0
                    };
                  };
                  const featLong = buildFeat("long");
                  const featShort= buildFeat("short");
                  const ml = state.ml || defaultML();
                  const pML_long = predictML(ml, featLong);
                  const pML_short= predictML(ml, featShort);
                  const mlConf = clamp((ml.n_trained||0)/200, 0, 0.6);

                  // Mixture-of-experts weights (Bayesian means) with regime prior
                  const expW = state.experts || { trend:{a:50,b:50}, meanrevert:{a:50,b:50}, ml:{a:50,b:50} };
                  let wt = (expW.trend.a/(expW.trend.a+expW.trend.b)) * (market.regime==="trend"?1.15:0.85);
                  let wm = (expW.meanrevert.a/(expW.meanrevert.a+expW.meanrevert.b)) * (market.regime==="meanrevert"?1.15:0.85);
                  let wl = (expW.ml.a/(expW.ml.a+expW.ml.b)) * (0.7 + 0.6*mlConf);
                  if(market.uncertain){ wt *= 0.9; wm *= 0.95; wl *= 1.05; }
                  const wSum = wt+wm+wl || 1; wt/=wSum; wm/=wSum; wl/=wSum;

                  // Side-wise probabilities
                  const pTrendLong  = sideTrend==="long" ? pTrend : (1-pTrend);
                  const pTrendShort = 1 - pTrendLong;
                  const pMRLong     = sideMR==="long"    ? pMR    : (1-pMR);
                  const pMRShort    = 1 - pMRLong;

                  const pLong = clamp(wt*pTrendLong + wm*pMRLong + wl*pML_long, 0.30, 0.90);
                  const pShort= clamp(wt*pTrendShort+ wm*pMRShort+ wl*pML_short,0.30, 0.90);

                  // Side-aware costs (fees + half-spread + depth slip)
                  const costLong = COST_BPS + Math.max(Math.round(spreadBps/2), slip.longBps);
                  const costShort= COST_BPS + Math.max(Math.round(spreadBps/2), slip.shortBps);

                  // Auto-RRR for both sides; pick side by expectancy
                  const atr_bps_full = Math.round((atr/last)*10000);
                  const rrrLong = computeAutoRRR({
                    regime: market.regime, p: pLong, adx, atr_bps: atr_bps_full,
                    cost_bps: costLong, spread_bps: spreadBps, trend_align: (upF&&upS)
                  });
                  const rrrShort= computeAutoRRR({
                    regime: market.regime, p: pShort, adx, atr_bps: atr_bps_full,
                    cost_bps: costShort, spread_bps: spreadBps, trend_align: (!upF && !upS)
                  });

                  const expLong = rrrLong ? Math.round(pLong*rrrLong.tp_bps - (1-pLong)*rrrLong.sl_bps - costLong) : -1e9;
                  const expShort= rrrShort? Math.round(pShort*rrrShort.tp_bps - (1-pShort)*rrrShort.sl_bps - costShort): -1e9;

                  const side = expLong>=expShort ? "long" : "short";
                  const p_final = side==="long" ? pLong : pShort;
                  const exp_bps = side==="long" ? expLong : expShort;
                  const costSide= side==="long" ? costLong : costShort;
                  const rrr = side==="long" ? rrrLong : rrrShort;
                  if(!rrr || exp_bps <= 0) return null;

                  // Conservative LCB gating
                  const key = `${market.regime}_${side}`;
                  const bkt = state.buckets[key] || {a:50,b:50};
                  const nBucket = Math.max(0,(bkt.a-50)+(bkt.b-50));
                  const pairN = state.pairs[c.base]?.n || 0;
                  const mlN = (ml.n_trained||0);
                  const nEff = Math.min(400, Math.round(1 + nBucket/2 + pairN + mlN/20));
                  const p_lcb = wilsonLCB(p_final, nEff, WILSON_Z);
                  const exp_lcb_bps = Math.round(p_lcb*rrr.tp_bps - (1-p_lcb)*rrr.sl_bps - costSide);
                  if(exp_lcb_bps <= MIN_EXP_LCB_BPS) return null;

                  // Score and hold
                  const quality = adxF;
                  let score = 50
                    + 30*(p_final - 0.5)*2
                    + 10*quality
                    + 6*((liq-0.5)*2)
                    - Math.min(8, Math.max(0, (spreadBps-5)/2));
                  score = clamp(Math.round(score), 1, 99);

                  const hold_base = (market.regime==="trend"?720:540) + 240*(quality);
                  const hold_sec = Math.round(clamp(hold_base, 480, 1800));

                  const sector = sectorOf(c.base);
                  return {
                    symbol:c.symbol, base:c.base, qv:c.qv,
                    side,
                    p_win:+p_final.toFixed(3), p_lcb:+p_lcb.toFixed(3),
                    exp_bps, exp_lcb_bps,
                    tp_bps: rrr.tp_bps, sl_bps: rrr.sl_bps,
                    rrr: rrr.r_used, tp_atr_mult: rrr.tp_atr, sl_atr_mult: rrr.sl_atr,
                    hold_sec,
                    spread_bps: spreadBps, slip_bps: (side==="long"?slip.longBps:slip.shortBps), cost_bps: costSide,
                    adx:+adx.toFixed(1), atr_bps: Math.round((atr/last)*10000),
                    regime: market.regime,
                    score,
                    ret5: ret5.slice(-CORR_WIN),
                    beta_btc: +betaBTC.toFixed(2),
                    liq_pct:+liq.toFixed(3),
                    sector,
                    // ML/debug
                    __feat_long: featLong, __feat_short: featShort
                  };
                }catch{ return null; }
              };

              const analyzed = (await processInBatches(universe, 6, analyze)).filter(Boolean);
              if(analyzed.length===0){ console.warn("No positive-edge ideas this run"); }

              // 7) Cluster by correlation
              const clusterMap = new Map(); const leaders = [];
              for(const c of analyzed.slice().sort((a,b)=>b.qv-a.qv)){
                if(clusterMap.has(c.base)) continue;
                const id = `C${leaders.length+1}`; leaders.push({ id, ret:c.ret5 });
                clusterMap.set(c.base, id);
                for(const o of analyzed){
                  if(clusterMap.has(o.base)) continue;
                  const rho = corr(c.ret5, o.ret5);
                  if(rho >= CLUSTER_THRESH){ clusterMap.set(o.base, id); }
                }
              }
              for(const c of analyzed){ c.cluster = clusterMap.get(c.base) || "C0"; }

              // Breadth
              const breadth = (()=>{ let up=0,tot=0; for(const x of analyzed){ const r=x.ret5.at(-1)||0; if(r!==0){tot++; if(r>0) up++;} } return tot? +((up/tot).toFixed(3)) : 0.5; })();

              // 8) Selection (corr, cluster/sector caps, beta budget, throttle)
              analyzed.sort((a,b)=> b.exp_lcb_bps!==a.exp_lcb_bps ? b.exp_lcb_bps-a.exp_lcb_bps
                                    : b.exp_bps!==a.exp_bps ? b.exp_bps-a.exp_bps
                                    : b.score!==a.score ? b.score-a.score
                                    : b.qv-a.qv);

              const selected=[], usedClusters=new Map(), usedSectors=new Map(); let netBeta=0;
              for(const cand of analyzed){
                if(selected.length>=maxIdeasFinal) break;
                // corr
                let ok=true; for(const s of selected){ if(corr(cand.ret5, s.ret5) > CORR_MAX){ ok=false; break; } }
                if(!ok) continue;
                // cluster & sector caps
                const cid=cand.cluster, sec=cand.sector;
                const cCnt=usedClusters.get(cid)||0, sCnt=usedSectors.get(sec)||0;
                if(cCnt >= CLUSTER_MAX_PICKS) continue;
                if(sCnt >= SECTOR_MAX_PICKS) continue;
                // beta budget
                const betaAdj = cand.side==="long" ? cand.beta_btc : -cand.beta_btc;
                const cap = BETA_CAP_BASE + selected.length * BETA_CAP_SLOPE;
                if(Math.abs(netBeta + betaAdj) > cap && Math.abs(betaAdj) > 0.4) continue;

                selected.push(cand);
                usedClusters.set(cid, cCnt+1);
                usedSectors.set(sec, sCnt+1);
                netBeta += betaAdj;
              }

              // 9) Size hints (risk budget; fixed TP/SL after entry)
              const softmax=(arr,t=25)=>{ const ex=arr.map(x=>Math.exp(x/t)); const s=ex.reduce((a,b)=>a+b,0)||1; return ex.map(x=>x/s); };
              const exps = selected.map(x=>x.exp_lcb_bps);
              const wExp = softmax(exps, 25);
              const sizeScale = throttle ? 0.7 : 1.0;
              const picks = selected.map((x,i)=>{
                const riskShare = wExp[i] * TARGET_PORT_RISK_BPS * sizeScale;
                const sizeBps = x.sl_bps>0 ? Math.min(200, Math.round(riskShare / x.sl_bps * 100)) : 0;
                const ttl = clamp(Math.round(x.hold_sec + (i*15)), 480, 1800);
                return {
                  symbol:x.base,
                  side:x.side,
                  score:x.score,
                  rank:i+1,
                  ttl_sec: ttl,
                  p_win:x.p_win, p_lcb:x.p_lcb,
                  exp_bps:x.exp_bps, exp_lcb_bps:x.exp_lcb_bps,
                  tp_bps:x.tp_bps, sl_bps:x.sl_bps, rrr:x.rrr, tp_atr_mult:x.tp_atr_mult, sl_atr_mult:x.sl_atr_mult,
                  spread_bps:x.spread_bps, slip_bps:x.slip_bps, cost_bps:x.cost_bps,
                  adx:x.adx, atr_bps:x.atr_bps, regime:x.regime,
                  beta_btc:x.beta_btc, liq_pct:x.liq_pct, cluster:x.cluster, sector:x.sector,
                  size_bps:sizeBps
                };
              });

              // 10) Queue for self-eval/learning (fixed TP/SL; no trailing)
              const ideasTs = new Date().toISOString();
              for(const p of picks){
                const symFull = `${p.symbol}USDT`;
                const book=bookMap.get(symFull); const mid=(book.bid+book.ask)/2;
                // Attribute expert roughly by regime (optional)
                const expert = (p.regime==="trend" ? "trend" : "meanrevert");
                state.pending.push({
                  ts: ideasTs, ts_ms: now,
                  symbolFull: symFull, base: p.symbol, side: p.side,
                  entry_price: mid, hold_sec: p.ttl_sec,
                  tp_bps: p.tp_bps, sl_bps: p.sl_bps,
                  regime: p.regime, cost_bps: p.cost_bps,
                  expert,
                  features: null
                });
                // Stamp cooldown: do not re-pick this base for 3 hours
                state.cooldown[p.symbol] = now;
              }
              if(state.pending.length>300) state.pending = state.pending.slice(-300);
              state.last_ts = ideasTs;

              // Build payload
              const ideas = {
                ts: ideasTs,
                mode:"normal",
                source:"external_pusher",
                meta:{
                  origin:"gha", v:"10/10-autoRRR-3h",
                  regime: market,
                  breadth,
                  net_beta_btc: +netBeta.toFixed(2),
                  throttle: { active: throttle, pnl24_bps, peak_dd_bps },
                  filters:{
                    min_qv:MIN_QV, universe:UNIVERSE, max_spread_bps:MAX_SPREAD*10000,
                    ema_fast:EMA_FAST, ema_slow:EMA_SLOW, adx_p:ADX_P, atr_p:ATR_P,
                    vwap_5m_win:VWAP_5M_WIN, corr_win:CORR_WIN, corr_max:CORR_MAX,
                    cluster_thresh:CLUSTER_THRESH, cluster_max_picks:CLUSTER_MAX_PICKS, sector_max_picks:SECTOR_MAX_PICKS,
                    cooldown_min: COOLDOWN_MS/60000,
                    target_port_risk_bps:TARGET_PORT_RISK_BPS, cost_bps:COST_BPS, notional_usd: NOTIONAL,
                    wilson_z: WILSON_Z, min_exp_lcb_bps: MIN_EXP_LCB_BPS
                  },
                  notes:"10/10 auto-RRR with 3h cooldown: mixture-of-experts, conservative LCB gating, auto TP/SL at entry, corr/cluster/sector caps, beta balance, drawdown throttle, depth-based costs."
                },
                top_n:picks.length,
                ideas:picks
              };

              // Persist + push
              await saveState(persist, state);
              const resp = await fetch(process.env.WORKER_PUSH_URL, {
                method:"POST",
                headers:{ "Content-Type":"application/json", "Authorization": `Bearer ${process.env.PUSH_TOKEN || ""}` },
                body: JSON.stringify(ideas)
              });
              if(!resp.ok){ const txt=await resp.text(); console.error("Failed to send ideas", resp.status, txt); process.exit(1); }
              console.log(`Sent ${picks.length} ideas | Regime=${market.regime} 3hCooldown=ON funding=${nearFunding} breadth=${breadth}`);
            }catch(err){ console.error("Idea push error:", err?.message||err); process.exit(1); }
          }).catch(e=>{ console.error("Bootstrap error:", e?.message||e); process.exit(1); });
          NODE
