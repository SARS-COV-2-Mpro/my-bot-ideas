name: Ideas Pusher (MEXC 2.2 EV)

on:
  workflow_dispatch:
  schedule:
    - cron: "*/20 * * * *" # runs every 20 minutes

permissions:
  contents: read

concurrency:
  group: ideas-mexc
  cancel-in-progress: true

jobs:
  push:
    runs-on: ubuntu-latest
    timeout-minutes: 12
    env:
      # Required secrets
      WORKER_PUSH_URL: ${{ secrets.WORKER_PUSH_URL }}
      PUSH_TOKEN: ${{ secrets.PUSH_TOKEN }}

      # Optional (safe defaults inside the script)
      GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
      GIST_ID: ${{ secrets.GIST_ID }}

      # Exchange + tuning knobs (via Repo/Org Variables)
      EXCHANGE: mexc # "mexci" is normalized inside the script
      MIN_QV_USD: ${{ vars.MIN_QV_USD }}
      TOP_N: ${{ vars.TOP_N }}
      EXTRA_IDEAS_MAX: ${{ vars.EXTRA_IDEAS_MAX }}
      MAX_SPREAD_BPS: ${{ vars.MAX_SPREAD_BPS }}
      EXP_LCB_MIN_BPS: ${{ vars.EXP_LCB_MIN_BPS }}
      FEES_BPS: ${{ vars.FEES_BPS }}
      NOTIONAL_USD: ${{ vars.NOTIONAL_USD }}
      MEXC_DEPTH_LIMIT: ${{ vars.MEXC_DEPTH_LIMIT }}
      OBI_TOPN: ${{ vars.OBI_TOPN }}
      ACTIVE_UTC_START: ${{ vars.ACTIVE_UTC_START }}
      ACTIVE_UTC_END: ${{ vars.ACTIVE_UTC_END }}
      MEXC_BASE: ${{ vars.MEXC_BASE }}

      # EV controls (safe defaults inside script)
      EV_IMPACT_PCT: ${{ vars.EV_IMPACT_PCT }}
      EV_MODE: ${{ vars.EV_MODE }}              # worker | pusher | both | off
      EV_BLEND_W: ${{ vars.EV_BLEND_W }}        # 0..1 when EV_MODE=both
      EV_SLACK_MAX_BPS: ${{ vars.EV_SLACK_MAX_BPS }}
      EV_MIN_BPS: ${{ vars.EV_MIN_BPS }}
      EV_WORKER_SL_BPS: ${{ vars.EV_WORKER_SL_BPS }}
      EV_WORKER_R: ${{ vars.EV_WORKER_R }}
      EV_WORKER_FLOOR_BPS: ${{ vars.EV_WORKER_FLOOR_BPS }}
      SIGNAL_NOTIONAL_USD: ${{ vars.SIGNAL_NOTIONAL_USD }}

    steps:
      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Run pusher (always-push + clear logs)
        shell: bash
        run: |
          set -euo pipefail

          # Hard fail only on true misconfig (so setup problems aren't hidden)
          if [[ -z "${WORKER_PUSH_URL:-}" || -z "${PUSH_TOKEN:-}" ]]; then
            echo "[gha] Missing WORKER_PUSH_URL or PUSH_TOKEN"
            exit 1
          fi

          set +e
          node - <<'NODE'
          (async ()=>{
            'use strict';

            // ---------- Utils ----------
            const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
            const tanh=(x)=>Math.tanh(x);
            const ema=(arr,p)=>{ if(arr.length<p) return null; const k=2/(p+1); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; for(let i=p;i<arr.length;i++) e=arr[i]*k+e*(1-k); return e; };
            const rsi=(cl,p=14)=>{ if(cl.length<=p) return null; let g=0,l=0; for(let i=1;i<=p;i++){ const d=cl[i]-cl[i-1]; g+=d>0?d:0; l+=d<0?-d:0; } let ag=g/p, al=l/p; for(let i=p+1;i<cl.length;i++){ const d=cl[i]-cl[i-1]; ag=(ag*(p-1)+(d>0?d:0))/p; al=(al*(p-1)+(d<0?-d:0))/p; } const rs=al===0?100:ag/al; return 100-100/(1+rs); };
            const std=(x)=>{ const n=x.length; if(n<=1) return 0; const m=x.reduce((a,b)=>a+b,0)/n; let v=0; for(const xi of x) v+=(xi-m)*(xi-m); return Math.sqrt(v/(n-1)); };
            const computeADX_ATR=(h,l,c,p=14)=>{ const n=c.length; if(n<p+2) return null; const TR=[],plusDM=[],minusDM=[];
              for(let i=1;i<n;i++){ const up=h[i]-h[i-1], down=l[i-1]-l[i]; plusDM.push((up>down&&up>0)?up:0); minusDM.push((down>up&&down>0)?down:0);
                TR.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1]))); }
              let trN=0,pdmN=0,ndmN=0; for(let i=0;i<p;i++){ trN+=TR[i]; pdmN+=plusDM[i]; ndmN+=minusDM[i]; }
              let pDI=100*(pdmN/(trN||1)), nDI=100*(ndmN/(trN||1)); let dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1), adx=dx;
              for(let i=p;i<TR.length;i++){ trN=trN-(trN/p)+TR[i]; pdmN=pdmN-(pdmN/p)+plusDM[i]; ndmN=ndmN-(ndmN/p)+minusDM[i];
                pDI=100*(pdmN/(trN||1)); nDI=100*(ndmN/(trN||1)); dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1); adx=((adx*(p-1))+dx)/p; }
              const atr=trN/p; return { adx, atr, trLast: TR.at(-1) };
            };
            const vwapAnchored=(h,l,c,v,win)=>{ const n=c.length,s=Math.max(0,n-win); let pv=0,vv=0; for(let i=s;i<n;i++){ const tp=(h[i]+l[i]+c[i])/3; const vol=+v[i]||0; pv+=tp*vol; vv+=vol; } return vv>0?pv/vv:c.at(-1); };
            const corr=(a,b)=>{ const n=Math.min(a.length,b.length); if(n<5) return 0; const as=a.slice(-n), bs=b.slice(-n);
              const ma=as.reduce((x,y)=>x+y,0)/n, mb=bs.reduce((x,y)=>x+y,0)/n; let num=0,da=0,db=0;
              for(let i=0;i<n;i++){ const xa=as[i]-ma, xb=bs[i]-mb; num+=xa*xb; da+=xa*xa; db+=xb*xb; }
              const den=Math.sqrt(da*db); return den===0?0:num/den;
            };
            const wilsonLCB=(p,n,z=1.34)=>{ if(n<=0) return p; const z2=z*z; const a=p + z2/(2*n); const b=z*Math.sqrt((p*(1-p)+z2/(4*n))/n); const c=1+z2/n; return clamp((a-b)/c, 0, 1); };
            const sum=(a)=>a.reduce((x,y)=>x+y,0);
            const matMulT=(X,y)=>{ const k=X[0].length; const XtY=new Array(k).fill(0); for(let i=0;i<X.length;i++){ const row=X[i]; const yi=y[i]; for(let j=0;j<k;j++) XtY[j]+=row[j]*yi; } return XtY; };
            const matTXmat=(X)=>{ const k=X[0].length; const XtX=Array.from({length:k},()=>new Array(k).fill(0)); for(let i=0;i<X.length;i++){ const row=X[i]; for(let a=0;a<k;a++) for(let b=0;b<k;b++) XtX[a][b]+=row[a]*row[b]; } return XtX; };
            const solveRidge=(A,b,lam=1e-6)=>{ const k=A.length; const M=Array.from({length:k},(_,i)=>A[i].slice()); for(let i=0;i<k;i++) M[i][i]+=lam;
              const aug=M.map((row,i)=>row.concat([b[i]]));
              for(let i=0;i<k;i++){
                let p=i; for(let r=i+1;r<k;r++) if(Math.abs(aug[r][i])>Math.abs(aug[p][i])) p=r;
                if(Math.abs(aug[p][i])<1e-12) return null;
                if(p!==i){ const t=aug[i]; aug[i]=aug[p]; aug[p]=t; }
                const piv=aug[i][i]; for(let j=i;j<=k;j++) aug[i][j]/=piv;
                for(let r=0;r<k;r++){ if(r===i) continue; const f=aug[r][i]; for(let j=i;j<=k;j++) aug[r][j]-=f*aug[i][j]; }
              }
              return aug.map(row=>row[k]);
            };
            const olsR2=(y,factors)=>{ const n=y.length; if(n<10) return {R2:0,beta:null}; const X=[]; for(let i=0;i<n;i++){ const row=[1]; for(const f of factors) row.push(f[i]||0); X.push(row); }
              const XtX=matTXmat(X), XtY=matMulT(X,y); const beta=solveRidge(XtX,XtY,1e-6);
              if(!beta) return {R2:0,beta:null};
              let ssTot=0, ssRes=0; const ym=sum(y)/n;
              for(let i=0;i<n;i++){
                let yhat=0; for(let j=0;j<beta.length;j++) yhat+=X[i][j]*beta[j];
                ssRes+=(y[i]-yhat)**2; ssTot+=(y[i]-ym)**2;
              }
              return {R2: clamp(ssTot>0? (1-ssRes/ssTot):0,0,1), beta};
            };
            const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
            const jitter=(ms)=>ms + Math.floor(Math.random()*ms*0.25);
            const log=(...a)=>console.log("[gha]",...a);
            const softmax=(arr,t=20)=>{ const m=Math.max(...arr); const ex=arr.map(x=>Math.exp((x-m)/t)); const s=ex.reduce((a,b)=>a+b,0)||1; return ex.map(x=>x/s); };

            // ---------- Config / ENV ----------
            const UA="gh-actions-ideas-elite-mexc/2.2-ev (+https://github.com/)";
            async function fetchWithTimeout(url,opts={},ms=12000){
              const ac=new AbortController(); const t=setTimeout(()=>ac.abort(),ms);
              try{ return await fetch(url,{...opts,signal:ac.signal,headers:{"User-Agent":UA,...(opts.headers||{})}}); }
              finally{ clearTimeout(t); }
            }
            async function getJSON(url,ms=12000,tries=2){
              for(let a=0;a<tries;a++){
                try{ const r=await fetchWithTimeout(url,{},ms); if(r?.ok){ return await r.json(); } }catch{}
                await sleep(jitter(220));
              }
              return null;
            }

            const EXCHANGE=(process.env.EXCHANGE||"mexc").toLowerCase().replace("mexci","mexc");
            if(EXCHANGE!=="mexc"){ console.error("[gha] This build targets MEXC. Set EXCHANGE=mexc"); process.exit(1); }

            const MEXC_BASES=[process.env.MEXC_BASE,"https://api.mexc.com","https://www.mexc.com"].filter(Boolean);

            // Liquidity + universe targets
            const MIN_QV_ENV = Number(process.env.MIN_QV_USD||"0") || 0;
            const UNIV_TARGET_MIN = 100, UNIV_TARGET_MAX = 120;
            const DYN_QV_STEP = 5_000_000, DYN_QV_MIN = 10_000_000;

            // Spread caps
            const MAX_SPREAD_BPS = Number(process.env.MAX_SPREAD_BPS||"12"); // strict cap
            const RELAXED_SPREAD_BPS = Math.min(MAX_SPREAD_BPS+2, 14);
            const LAST_RESORT_SPREAD_BPS = Math.max(RELAXED_SPREAD_BPS, 18);

            // Core TA params
            const EMA_FAST=21, EMA_SLOW=50, ADX_P=14, ATR_P=14;
            const K1M=240, K5M=120, K15M=96, K1H=96;
            const VWAP_5M_WIN=36;

            // Costs & micro
            const FEES_BPS = Number(process.env.FEES_BPS||"10");
            const NOTIONAL = Number(process.env.NOTIONAL_USD||"300");
            const DEPTH_LIMIT = Number(process.env.MEXC_DEPTH_LIMIT||"50");
            const OBI_TOPN = Number(process.env.OBI_TOPN||"12");
            const SIGNAL_NOTIONAL = Number(process.env.SIGNAL_NOTIONAL_USD||"300");

            // EV control knobs
            const EV_IMPACT_PCT = clamp(Number(process.env.EV_IMPACT_PCT||"100"),0,100);
            const alpha = EV_IMPACT_PCT/100;
            const EV_MODE = (process.env.EV_MODE||"worker").toLowerCase();
            const EV_BLEND_W = clamp(Number(process.env.EV_BLEND_W||"0.6"),0,1);
            const EV_SLACK_MAX_BPS = Number(process.env.EV_SLACK_MAX_BPS||"6");
            const EV_MIN_BPS = Number(process.env.EV_MIN_BPS||"2");
            const EV_WORKER_SL_BPS = Number(process.env.EV_WORKER_SL_BPS||"25");
            const EV_WORKER_R = Number(process.env.EV_WORKER_R||"1.45");
            const EV_WORKER_TP_BPS = Math.round(EV_WORKER_SL_BPS*EV_WORKER_R);
            const EV_WORKER_FLOOR_BPS = Number(process.env.EV_WORKER_FLOOR_BPS||"5");

            // Risk & timing
            const TOP_N = Math.max(1, Number(process.env.TOP_N||"3"));
            const COOLDOWN_MS = 3*60*60*1000;
            const FLIP_GUARD_MS = 30*60*1000;
            const DD_24H_LIMIT_BPS=-150, DD_PEAK_LIMIT_BPS=-300;
            const WILSON_Z=1.34;
            const TARGET_PORT_RISK_BPS=52;

            // Exit shaping (ATR-based)
            const TP_ATR_MIN=0.40, TP_ATR_MAX=2.10;
            const SL_ATR_MIN=0.35, SL_ATR_MAX=1.70;
            const BASE_TP = { trend:1.12, mr:0.62, breakout:1.30 };
            const BASE_SL = { trend:0.62, mr:0.60, breakout:0.60 };

            // Fallback policy
            const MAX_STRICT_PICKS = Math.min(3, TOP_N);
            const MAX_FALLBACK_PICKS = 3;
            const FALLBACK_SIZE_FACTOR = 0.60; // -40%
            const TTL_MIN=540, TTL_MAX=1200; // 9–20 minutes

            // TOD window
            const S_H = process.env.ACTIVE_UTC_START? Number(process.env.ACTIVE_UTC_START): null;
            const E_H = process.env.ACTIVE_UTC_END?   Number(process.env.ACTIVE_UTC_END):   null;
            const nowH = new Date().getUTCHours();
            const todOK = (S_H==null || E_H==null) ? true : (S_H<=E_H ? (nowH>=S_H && nowH<=E_H) : (nowH>=S_H || nowH<=E_H));

            const STABLES=new Set(["USDT","USDC","USD","USDE","USDD","BUSD","FDUSD","TUSD","DAI","USDP","PAX","USTC"]);

            // ---------- Worker endpoints ----------
            const PUSH_URL=process.env.WORKER_PUSH_URL||"";
            const PUSH_TOKEN=process.env.PUSH_TOKEN||"";
            const HEALTH_URL=(()=>{ try{ const u=new URL(PUSH_URL); return `${u.origin}${u.pathname.replace(/\/signals\/push(\?.*)?$/,"/health")}`;}catch{return PUSH_URL.replace(/\/signals\/push(\?.*)?$/,"/health");}})();

            // Guaranteed health GET (tail visibility even if 0 ideas)
            log("health GET", HEALTH_URL);
            try{
              const r=await fetchWithTimeout(HEALTH_URL,{ headers:{ "Authorization":`Bearer ${PUSH_TOKEN}`, "User-Agent":UA }},5000);
              let t=""; try{ t=await r.text(); }catch{}
              log("health status", r?.status||"ERR", (t||"").slice(0,160));
            }catch(e){ log("health error", e?.message||e); }

            // ---------- MEXC Adapter ----------
            async function pickMexcBase(){
              for(const b of MEXC_BASES){
                try{
                  const r=await fetchWithTimeout(`${b}/api/v3/time`,{},4000);
                  if(r?.ok) return b;
                }catch{}
              }
              throw new Error("No healthy MEXC base");
            }
            const BASE = await pickMexcBase();
            const api=(path,params={})=>{ const u=new URL(path,BASE); for(const [k,v] of Object.entries(params)){ if(v!==undefined&&v!==null) u.searchParams.set(k,String(v)); } return u.toString(); };
            async function fetchK(sym,interval,limit,startTime,endTime){
              const u=api("/api/v3/klines",{symbol:sym,interval,limit,startTime,endTime});
              const r=await getJSON(u,10000,2); return Array.isArray(r)?r:null;
            }
            async function fetchDepth(symbol){ return await getJSON(api("/api/v3/depth",{symbol,limit:DEPTH_LIMIT}), 10000, 2); }

            // 24h fallback aggregator (robust universe even if all-24h fails)
            async function fetchAll24hr(){
              let all = await getJSON(api("/api/v3/ticker/24hr"), 10000, 2);
              if(Array.isArray(all) && all.length) return all;
              const exi=await getJSON(api("/api/v3/exchangeInfo"), 10000, 2);
              const syms=(exi?.symbols||[]).filter(s=>s.status==="TRADING").map(s=>s.symbol).slice(0,300);
              const out=[];
              for(let i=0;i<syms.length;i+=24){
                const chunk=syms.slice(i,i+24);
                const got=await Promise.all(chunk.map(s=>getJSON(api("/api/v3/ticker/24hr",{symbol:s}),6000,1)));
                for(const x of got) if(x) out.push(x);
                await sleep(180);
              }
              return out;
            }

            // ---------- State (Gist) ----------
            async function loadState(){
              const token=process.env.GIST_TOKEN, id=process.env.GIST_ID;
              const init={ v:"elite-ideas-mexc-2.2-ev", cooldown:{}, cooldown_side:{}, pending:[], equity:[] };
              if(!token||!id) return { state:init, persist:null };
              try{
                const r=await fetchWithTimeout(`https://api.github.com/gists/${id}`,{ headers:{Authorization:`Bearer ${token}`,"Accept":"application/vnd.github+json","User-Agent":UA}});
                if(!r.ok) return { state:init, persist:null };
                const g=await r.json(); const c=g.files?.["state.json"]?.content;
                return { state: c?JSON.parse(c):init, persist:{id,token} };
              }catch{ return { state:init, persist:null }; }
            }
            async function saveState(persist,state){
              if(!persist) return;
              try{
                await fetchWithTimeout(`https://api.github.com/gists/${persist.id}`,{
                  method:"PATCH",
                  headers:{Authorization:`Bearer ${persist.token}`,"Accept":"application/vnd.github+json","Content-Type":"application/json","User-Agent":UA},
                  body: JSON.stringify({ files:{ "state.json":{ content: JSON.stringify(state) } } })
                });
              }catch{}
            }
            async function evalPending(state){
              const now=Date.now(); const keep=[];
              for(const p of state.pending||[]){
                if(now < p.ts_ms + p.hold_sec*1000 + 5000){ keep.push(p); continue; }
                const k = await fetchK(p.symbolFull,"1m",K1M, p.ts_ms-60*1000, p.ts_ms+p.hold_sec*1000+60*1000);
                if(!k){ keep.push(p); continue; }
                const highs=k.map(x=>+x[2]), lows=k.map(x=>+x[3]), closes=k.map(x=>+x[4]);
                const entry=p.entry_price, long=p.side==="long", tp=p.tp_bps/10000, sl=p.sl_bps/10000;
                let exitPx=closes.at(-1);
                for(let i=0;i<k.length;i++){
                  const hi=highs[i], lo=lows[i];
                  if(long){ if(hi>=entry*(1+tp)){ exitPx=entry*(1+tp); break; } if(lo<=entry*(1-sl)){ exitPx=entry*(1-sl); break; } }
                  else    { if(lo<=entry*(1-tp)){ exitPx=entry*(1-tp); break; } if(hi>=entry*(1+sl)){ exitPx=entry*(1+sl); break; } }
                }
                const ret = long? (exitPx/entry - 1) : (entry/exitPx - 1);
                const pnl_bps = Math.round(ret*10000) - (p.cost_bps||0);
                state.equity.push({ ts_ms:p.ts_ms, pnl_bps });
              }
              state.pending = keep;
              if(state.equity.length>6000) state.equity = state.equity.slice(-6000);
            }
            const equityStats=(eq)=>{ const day=Date.now()-24*3600*1000; let pnl24=0,cum=0,peak=0,dd=0;
              for(const e of eq){ if(e.ts_ms>=day) pnl24+=e.pnl_bps; cum+=e.pnl_bps; if(cum>peak) peak=cum; dd=Math.min(dd,cum-peak); }
              return { pnl24_bps:Math.round(pnl24), peak_dd_bps:Math.round(dd) };
            };

            // ---------- Main (strict-first then fallback) ----------
            let reason="ok", tier="none";
            try{
              const ALL24 = await fetchAll24hr();
              const booksRaw=await getJSON(api("/api/v3/ticker/bookTicker"),10000,2) || [];
              const bookMap=new Map(booksRaw.map(b=>[b.symbol,{ bid:+b.bidPrice, ask:+b.askPrice }]));

              if(!todOK){ reason="tod_gate"; }

              // Universe with dynamic min-QV to hit 100–120
              const QUOTES=["USDT","USDC","USD"];
              const split=(sym)=>{ for(const q of QUOTES){ if(sym.endsWith(q)) return { base: sym.slice(0,-q.length), quote:q }; } return null; };
              const all=[];
              for(const t of ALL24||[]){
                const sym=t.symbol||t.s; if(!sym) continue;
                const sq=split(sym); if(!sq) continue;
                if(STABLES.has(sq.base)) continue;
                const qv=+(t.quoteVolume||t.q||0);
                if(!isFinite(qv)||qv<=0) continue;
                all.push({ symbol:sym, base:sq.base, quote:sq.quote, qv });
              }
              all.sort((a,b)=>b.qv-a.qv);

              let dynMinQV = Math.max(MIN_QV_ENV||0, DYN_QV_MIN);
              let filt = all.filter(x=>x.qv>=dynMinQV);
              while(filt.length<UNIV_TARGET_MIN && dynMinQV>DYN_QV_MIN){
                dynMinQV = Math.max(DYN_QV_MIN, dynMinQV - DYN_QV_STEP);
                filt = all.filter(x=>x.qv>=dynMinQV);
              }
              const universe = filt.slice(0,UNIV_TARGET_MAX);
              if(!universe.length){ reason = (reason!=="ok"?reason:"no_universe"); }

              // Benchmarks
              const BTC="BTCUSDT", ETH="ETHUSDT", SOL="SOLUSDT";
              const kBTC15=await fetchK(BTC,"15m",K15M);
              const kETH15=await fetchK(ETH,"15m",K15M);
              const kSOL15=await fetchK(SOL,"15m",K15M);
              const kBTC1H=await fetchK(BTC,"1h",K1H);
              const kETH1H=await fetchK(ETH,"1h",K1H);

              const regime=(()=>{
                const f=(k)=>{ if(!k||k.length<ADX_P+5) return null; const h=k.map(x=>+x[2]), l=k.map(x=>+x[3]), c=k.map(x=>+x[4]); const { adx }=computeADX_ATR(h,l,c,ADX_P)||{}; const roc=((c.at(-1)/c.at(-5)) - 1); return { adx:adx||0, roc }; };
                const b=f(kBTC15)||{adx:0,roc:0}, e=f(kETH15)||{adx:0,roc:0};
                const adxAvg=((b.adx||0)+(e.adx||0))/2, dir = Math.sign((b.roc||0)+(e.roc||0));
                const isTrend=adxAvg>=22 && Math.abs(b.roc)>0.001 && Math.abs(e.roc)>0.001;
                const uncertain=adxAvg>=18 && adxAvg<=22;
                return { regime: isTrend?"trend":"meanrevert", adxAvg, dir, uncertain };
              })();
              log("regime", regime.regime, "adxAvg", regime.adxAvg?.toFixed?.(1)||"");

              // State & DD gate
              const { state, persist } = await loadState();
              try{ await evalPending(state); }catch{}
              const { pnl24_bps, peak_dd_bps } = equityStats(state.equity);
              const throttle = (pnl24_bps<=DD_24H_LIMIT_BPS) || (peak_dd_bps<=DD_PEAK_LIMIT_BPS);

              // Liquidity pct for later scoring
              const liqPct=new Map(); for(let i=0;i<universe.length;i++){ liqPct.set(universe[i].symbol,(universe.length===1)?1:1 - i/(universe.length-1)); }

              // Microstructure helpers
              function obiWeighted(depth,topN){
                const w=(i)=>Math.exp(-i*0.18);
                let bidNot=0, askNot=0;
                for(let i=0;i<Math.min(topN, depth.bids.length); i++){ const p=+depth.bids[i][0], q=+depth.bids[i][1]; if(p>0&&q>0) bidNot += p*q*w(i); }
                for(let i=0;i<Math.min(topN, depth.asks.length); i++){ const p=+depth.asks[i][0], q=+depth.asks[i][1]; if(p>0&&q>0) askNot += p*q*w(i); }
                const obi = (bidNot+askNot>0) ? (bidNot-askNot)/(bidNot+askNot) : 0;
                return { obi };
              }
              function vwapFill(levels,targetUSD){
                let remain=targetUSD,val=0,qty=0;
                for(const [ps,qs] of levels){ const p=+ps,q=+qs; if(!(p>0&&q>0)) continue; const can=p*q, take=Math.min(remain,can), tq=take/p;
                  val+=p*tq; qty+=tq; remain-=take; if(remain<=1e-6) break; }
                return { px: qty>0? val/qty : null, filledUSD: (targetUSD-remain) };
              }

              // Prefilter (cooldown + lightweight signals) — Steps 1–3
              const picksRaw=[];
              const B=10;
              for(let i=0;i<(universe||[]).length;i+=B){
                const batch=await Promise.all(universe.slice(i,i+B).map(async c=>{
                  try{
                    const now=Date.now();
                    const lastTs=(await (async()=>state.cooldown?.[c.base]))||0;
                    if(lastTs && (now-lastTs) < COOLDOWN_MS) return null;

                    const book=bookMap.get(c.symbol); if(!book?.bid||!book?.ask) return null;
                    const mid=(book.bid+book.ask)/2; if(!(mid>0)) return null;
                    const spreadBps=Math.round(((book.ask-book.bid)/mid)*10000);
                    if(spreadBps>MAX_SPREAD_BPS) return null;

                    const k5 = await fetchK(c.symbol,"5m",K5M); if(!k5||k5.length<Math.max(EMA_SLOW+5,ATR_P+5)) return null;
                    const k15= await fetchK(c.symbol,"15m",K15M);
                    const k1h= await fetchK(c.symbol,"1h",K1H);

                    const h5=k5.map(x=>+x[2]), l5=k5.map(x=>+x[3]), c5=k5.map(x=>+x[4]), v5=k5.map(x=>+x[5]);
                    const em21=ema(c5,EMA_FAST), em50=ema(c5,EMA_SLOW);
                    const { adx:adx5, atr:atr5 } = computeADX_ATR(h5,l5,c5,ADX_P)||{};
                    if(!(adx5&&atr5)) return null;
                    const atr_bps=Math.round((atr5/c5.at(-1))*10000); if(atr_bps<4||atr_bps>260) return null;

                    const c15=k15?.map(x=>+x[4])||[], c1h=k1h?.map(x=>+x[4])||[];
                    const em15f=c15.length?ema(c15,EMA_FAST):null, em15s=c15.length?ema(c15,EMA_SLOW):null;
                    const em1hf=c1h.length?ema(c1h,EMA_FAST):null, em1hs=c1h.length?ema(c1h,EMA_SLOW):null;

                    const vwap5=vwapAnchored(h5,l5,c5,v5,VWAP_5M_WIN);
                    const last=c5.at(-1), prev=c5.at(-2), prev3=c5.at(-4);
                    const roc5=(last/prev)-1, roc15=(last/prev3)-1;

                    const upF=last>=em21, upS=last>=em50;
                    const up15=(em15f&&em15s)? (last>=em15f && last>=em15s) : true;
                    const up1h=(em1hf&&em1hs)? (last>=em1hf && last>=em1hs) : true;
                    const z_vwap=(last-vwap5)/(atr5||1);
                    const rsi14=rsi(c5,14);

                    // Donchian 15m (40), 5m (10)
                    let pHigh15=null,pLow15=null, pHigh10=null,pLow10=null;
                    if(k15 && k15.length>40){
                      const highs=k15.map(x=>+x[2]), lows=k15.map(x=>+x[3]);
                      const win=40; pHigh15=Math.max(...highs.slice(-win)); pLow15=Math.min(...lows.slice(-win));
                    }
                    if(k5 && k5.length>12){
                      const highs5=k5.map(x=>+x[2]), lows5=k5.map(x=>+x[3]);
                      const win5=10; pHigh10=Math.max(...highs5.slice(-win5)); pLow10=Math.min(...lows5.slice(-win5));
                    }
                    const boUp = pHigh15 ? (last>pHigh15) : false;
                    const boDn = pLow15  ? (last<pLow15 ) : false;

                    // Squeeze: BB width vs Keltner-ish width (ATR)
                    const winS=20; const retW=[]; for(let i=c5.length-winS;i<c5.length;i++){ retW.push((c5[i]/c5[i-1])-1); }
                    const bbWidth = std(retW)*Math.sqrt(winS);
                    const kelWidth = (atr5/last);
                    const squeezeRatio = kelWidth>0 ? (bbWidth/kelWidth) : 1;
                    const squeezeScore = clamp((1.15 - squeezeRatio)/0.45, 0, 1);

                    // Expert probabilities
                    const adxF=clamp((adx5-16)/14,0,1);
                    const s1=tanh(roc5/0.0030), s2=tanh(roc15/0.0065);

                    // Trend expert
                    const sideTrend= (0.6*roc5+0.4*roc15)>=0 ? "long":"short";
                    const trendAlign = (sideTrend==="long" && upF&&upS&&up15&&up1h) || (sideTrend==="short" && !upF&&!upS&&(!up15||!up1h));
                    let pTrend = clamp(0.5 + 0.27*(0.6*s1+0.4*s2)*(trendAlign?1.0:0.7)*adxF, 0.32, 0.93);

                    // MR expert
                    const sideMR = z_vwap>0 ? "short" : "long";
                    const rsiEdge=(rsi14!=null)?(rsi14-50)/50:0;
                    const sMR=tanh(Math.abs(z_vwap))*Math.sign(-z_vwap);
                    let pMR = clamp(0.5 + 0.23*(0.7*sMR + 0.3*(-rsiEdge))*(1-adxF), 0.35, 0.90);

                    // BO expert
                    const sideBO = boUp ? "long" : boDn ? "short" : (0.6*roc5+0.4*roc15)>=0?"long":"short";
                    let boBase = (boUp||boDn ? 1.0 : 0.35) * (0.6+0.4*adxF);
                    boBase *= (1 + 0.4*squeezeScore);
                    let pBO = clamp(0.5 + 0.29*(boBase*(sideBO==="long"?1:-1)), 0.35, 0.96);

                    // Regime weights via softmax
                    const w_trend = regime.regime==="trend" ? [1.0,0.6,0.8] : [0.6,1.0,0.8];
                    const w_sm = softmax(w_trend, 0.5); // narrow T to emphasize the largest
                    const wT=w_sm[0], wM=w_sm[1], wB=w_sm[2];

                    const pUpTrend = sideTrend==="long"? pTrend : 1-pTrend;
                    const pUpMR    = sideMR==="long"  ? pMR    : 1-pMR;
                    const pUpBO    = sideBO==="long"  ? pBO    : 1-pBO;

                    const pLong0  = clamp(wT*pUpTrend + wM*pUpMR + wB*pUpBO, 0.05, 0.95);
                    const pShort0 = clamp(wT*(1-pUpTrend) + wM*(1-pUpMR) + wB*(1-pUpBO), 0.05, 0.95);

                    return {
                      c, k5, k15, c5, adx5, atr_bps, spreadBps,
                      pLong0, pShort0, trendAlign, squeezeScore,
                      upF, upS, up15, up1h, z_vwap,
                      pHigh10, pLow10
                    };
                  }catch{ return null; }
                }));
                for(const x of batch){ if(x) picksRaw.push(x); }
              }

              // Keep top 120 by max(pLong0,pShort0)
              picksRaw.sort((a,b)=> Math.max(b.pLong0,b.pShort0) - Math.max(a.pLong0,a.pShort0));
              const REFINE_M = Math.min(UNIV_TARGET_MAX, picksRaw.length);
              if(!REFINE_M){ reason = (reason!=="ok"?reason:"no_candidates"); }

              // Refine with depth + costs + EV — Steps 4–7
              const refined=[];
              const retLog=(arr)=>{ const r=[]; for(let i=1;i<arr.length;i++) r.push(Math.log(arr[i]/arr[i-1])); return r; };
              const to5m=(k)=>{ if(!k) return []; const c=k.map(x=>+x[4]); const r=[]; for(let i=1;i<c.length;i++) r.push(Math.log(c[i]/c[i-1])); return r.slice(-60); };
              const fBTC=to5m(kBTC15), fETH=to5m(kETH15), fSOL=to5m(kSOL15);

              function exitsATR({side, style, atr_bps, adxF, regime, squeezeScore, obi, opposes, last, pHigh10, pLow10, cost_bps}){
                const baseTP=BASE_TP[style]||BASE_TP.trend;
                const baseSL=BASE_SL[style]||BASE_SL.trend;

                let sl_atr = baseSL;
                // Regime: widen in chop/squeeze, tighten in strong trend
                if(regime==="meanrevert" || squeezeScore>0.40) sl_atr *= 1.25;
                if(adxF>0.65 && regime==="trend") sl_atr *= 0.95;
                // OBI oppose
                if(Math.abs(obi)>0.15 && opposes) sl_atr *= 1.10;

                let sl_bps = Math.round(sl_atr*atr_bps);
                let tp_bps = Math.round(baseTP*atr_bps);

                // Structure floor: Donchian(10) + 0.15*ATR
                const struct = side==="long"
                  ? (pLow10 && last>0 ? ((last - pLow10)/last)*10000 : 0)
                  : (pHigh10&& last>0 ? ((pHigh10 - last)/last)*10000 : 0);
                const struct_bps = Math.max(0, Math.round(struct + 0.15*atr_bps));
                sl_bps = Math.max(sl_bps, struct_bps);

                // Friction
                sl_bps = Math.max(sl_bps, cost_bps+2);

                // Bounds
                const slMin = Math.round(SL_ATR_MIN*atr_bps), slMax=Math.round(SL_ATR_MAX*atr_bps);
                const tpMin = Math.round(TP_ATR_MIN*atr_bps), tpMax=Math.round(TP_ATR_MAX*atr_bps);
                sl_bps = clamp(sl_bps, slMin, slMax);
                tp_bps = clamp(tp_bps, tpMin, tpMax);
                const rrr = tp_bps>0 && sl_bps>0 ? +(tp_bps/sl_bps).toFixed(2) : 0;

                return { tp_bps, sl_bps, rrr, tp_atr:+(tp_bps/atr_bps).toFixed(2), sl_atr:+(sl_bps/atr_bps).toFixed(2) };
              }

              for(let idx=0; idx<REFINE_M; idx++){
                const p=picksRaw[idx];
                const c=p.c;
                const book=bookMap.get(c.symbol); if(!book?.bid||!book?.ask) continue;
                const mid=(book.bid+book.ask)/2;

                const depth=await fetchDepth(c.symbol);
                let obi=0, slipL=p.spreadBps/2, slipS=p.spreadBps/2, fillL=0, fillS=0;
                if(depth?.asks?.length && depth?.bids?.length){
                  const ob=obiWeighted(depth,OBI_TOPN);
                  obi=ob.obi;
                  const buy=vwapFill(depth.asks, Math.max(50,SIGNAL_NOTIONAL));
                  const sell=vwapFill(depth.bids, Math.max(50,SIGNAL_NOTIONAL));
                  slipL = buy.px? Math.max(0, Math.round((buy.px - mid)/mid*10000)) : slipL;
                  slipS = sell.px? Math.max(0, Math.round((mid - sell.px)/mid*10000)) : slipS;
                  fillL = Math.min(1, buy.filledUSD/Math.max(1,SIGNAL_NOTIONAL));
                  fillS = Math.min(1, sell.filledUSD/Math.max(1,SIGNAL_NOTIONAL));
                }
                // Micro p-nudges (capped ±0.06)
                const obiAdj = clamp(obi*0.10, -0.06, +0.06);

                let pLong=clamp(p.pLong0 + (obi>0?+obiAdj:-obiAdj)*0.8, 0.05, 0.95);
                let pShort=clamp(p.pShort0+ (obi<0?+(-obiAdj):+(obiAdj))*(-0.8), 0.05, 0.95);

                // Flip guard
                const lastSide=state.cooldown_side?.[c.base];
                if(lastSide && lastSide.side && lastSide.ts_ms && Date.now()-lastSide.ts_ms<FLIP_GUARD_MS){
                  if(lastSide.side==="long") pShort = Math.max(0.05, pShort-0.03);
                  if(lastSide.side==="short") pLong  = Math.max(0.05, pLong -0.03);
                }

                const costLong=FEES_BPS + Math.max(Math.round(p.spreadBps/2), slipL);
                const costShort=FEES_BPS + Math.max(Math.round(p.spreadBps/2), slipS);

                // Confidence
                const y = retLog(p.c5.slice(-61));
                const X1=fBTC.slice(-y.length), X2=fETH.slice(-y.length), X3=fSOL.slice(-y.length);
                const {R2} = olsR2(y,[X1,X2,X3]);
                const liq = liqPct.get(c.symbol)||0.5;
                const dp = Math.abs(pLong - pShort);
                let nConf = 46 + 26*clamp((p.adx5-16)/14,0,1) + 22*liq + 10*Math.abs(obi) - 8*dp;
                nConf = Math.round(clamp(nConf, 32, 132));

                // Tie drop
                const p_lcbL=wilsonLCB(pLong,nConf,WILSON_Z);
                const p_lcbS=wilsonLCB(pShort,nConf,WILSON_Z);
                if(dp<0.03 && Math.max(p_lcbL,p_lcbS) < 0.56) continue;

                // Decide side on reference EV later; compute exits per side first
                const last=c.pHigh10?p.c5.at(-1):p.c5.at(-1);

                const exLong = exitsATR({
                  side:"long", style: (p.trendAlign? "trend": (p.squeezeScore>0.25? "breakout":"mr")),
                  atr_bps:p.atr_bps, adxF:clamp((p.adx5-16)/14,0,1), regime: (regime.regime),
                  squeezeScore: p.squeezeScore, obi, opposes: (obi<0), last,
                  pHigh10:p.pHigh10, pLow10:p.pLow10, cost_bps:costLong
                });
                const exShort= exitsATR({
                  side:"short", style: (!p.trendAlign? "trend": (p.squeezeScore>0.25? "breakout":"mr")),
                  atr_bps:p.atr_bps, adxF:clamp((p.adx5-16)/14,0,1), regime: (regime.regime),
                  squeezeScore: p.squeezeScore, obi, opposes: (obi>0), last,
                  pHigh10:p.pHigh10, pLow10:p.pLow10, cost_bps:costShort
                });

                // EVs
                const ev_p_long  = Math.round(p_lcbL*exLong.tp_bps  - (1-p_lcbL)*exLong.sl_bps  - costLong);
                const ev_p_short = Math.round(p_lcbS*exShort.tp_bps - (1-p_lcbS)*exShort.sl_bps - costShort);

                const ev_w_long  = Math.round(p_lcbL*EV_WORKER_TP_BPS - (1-p_lcbL)*EV_WORKER_SL_BPS - costLong);
                const ev_w_short = Math.round(p_lcbS*EV_WORKER_TP_BPS - (1-p_lcbS)*EV_WORKER_SL_BPS - costShort);

                const side = (()=>{
                  // decide by reference EV depending on EV_MODE preliminarily,
                  // fallback to higher p_lcb if EV_MODE=off or alpha~0
                  const evRefL = EV_MODE==="worker"? ev_w_long
                                 : EV_MODE==="pusher"? ev_p_long
                                 : EV_MODE==="both"? Math.round(EV_BLEND_W*ev_w_long + (1-EV_BLEND_W)*ev_p_long)
                                 : 0;
                  const evRefS = EV_MODE==="worker"? ev_w_short
                                 : EV_MODE==="pusher"? ev_p_short
                                 : EV_MODE==="both"? Math.round(EV_BLEND_W*ev_w_short + (1-EV_BLEND_W)*ev_p_short)
                                 : 0;
                  if(EV_MODE==="off" || alpha<=0){
                    return (p_lcbL>=p_lcbS) ? "long":"short";
                  }else{
                    return (evRefL>=evRefS) ? "long":"short";
                  }
                })();

                const fillSide = side==="long"? fillL : fillS;
                const costSide = side==="long"? costLong : costShort;
                const exSide   = side==="long"? exLong : exShort;
                const p_final  = side==="long"? pLong  : pShort;
                const p_lcb    = side==="long"? p_lcbL : p_lcbS;
                const ev_p     = side==="long"? ev_p_long : ev_p_short;
                const ev_w     = side==="long"? ev_w_long : ev_w_short;

                const ev_ref = (()=>{
                  if(EV_MODE==="off") return 0;
                  if(EV_MODE==="worker") return ev_w;
                  if(EV_MODE==="pusher") return ev_p;
                  return Math.round(EV_BLEND_W*ev_w + (1-EV_BLEND_W)*ev_p);
                })();

                // Dynamic EV floor (strict base)
                const fees_rel = Math.round(FEES_BPS * (regime.regime==="trend"? 0.6 : 0.8));
                const micro_adj = Math.round( 2*(1-(liqPct.get(c.symbol)||0.5)) + Math.max(0,12-p.spreadBps)/12 + 8*Math.max(0, 0.70 - (fillSide||0)) );
                let floor_base = Math.max(5, fees_rel, micro_adj);
                if((liqPct.get(c.symbol)||0.5)>=0.8 && p.spreadBps<=6 && (fillSide||0)>=0.85) floor_base = Math.max(0, floor_base-1);
                const floor_eff = Math.max(EV_MIN_BPS, Math.round(floor_base - (1-alpha)*EV_SLACK_MAX_BPS));

                // Fill gate
                const fill_min = ((liqPct.get(c.symbol)||0.5)>=0.8 && p.spreadBps<=6) ? 0.60 : 0.65;
                const passFill = (fillSide||0) >= fill_min;

                // EV gate
                const passEV = (alpha<=0 && EV_MODE==="off") ? true : (ev_ref >= floor_eff);

                // Selection score
                const score = Math.round(
                  1000*(alpha*ev_ref) + 100*((1-alpha)*((p_lcb-0.5)*100)) + 5*((liqPct.get(c.symbol)||0)) - 2*(p.spreadBps)
                );

                // Pack refined
                const refinedItem = {
                  symbol:c.symbol, base:c.base, quote:c.quote, qv:c.qv,
                  side, p_win:+p_final.toFixed(3), p_lcb:+p_lcb.toFixed(3),
                  tp_bps: exSide.tp_bps, sl_bps: exSide.sl_bps, rrr: exSide.rrr,
                  tp_atr_mult: exSide.tp_atr, sl_atr_mult: exSide.sl_atr,
                  spread_bps: p.spreadBps, cost_bps: costSide,
                  adx:+(p.adx5||0).toFixed(1), atr_bps:p.atr_bps,
                  regime: regime.regime, style: (side==="long"? (p.trendAlign? "trend": (p.squeezeScore>0.25? "breakout":"mr"))
                                            : (!p.trendAlign? "trend": (p.squeezeScore>0.25? "breakout":"mr"))),
                  n_conf: nConf, obi:+obi.toFixed(3), squeeze: +p.squeezeScore.toFixed(2),
                  liq_pct:+(liqPct.get(c.symbol)||0.5).toFixed(3),
                  fill_prob: +((fillSide||0)).toFixed(2),
                  beta_r2:+(R2||0).toFixed(2),
                  ev_pusher_bps: ev_p, ev_worker_bps: ev_w, ev_bps: ev_ref, ev_mode: EV_MODE,
                  floor_eff, passEV, passFill, score,
                  ret5:(()=>{ const r=[]; for(let i=1;i<p.c5.length;i++) r.push(Math.log(p.c5[i]/p.c5[i-1])); return r.slice(-36); })()
                };

                refined.push(refinedItem);
              }

              // Rank refined candidates
              refined.sort((a,b)=>
                   b.passEV - a.passEV
                || b.passFill - a.passFill
                || b.score - a.score
                || b.p_lcb - a.p_lcb
                || b.ev_bps - a.ev_bps
                || b.qv - a.qv
              );

              // Strict picks (A+): up to 1–3, correlation cap, EV/fill/spread gates
              const CORE_CORR_MAX=0.84;
              const rho=(a,b)=>corr(a.ret5||[],b.ret5||[]);
              const maxStrict = throttle ? Math.min(2, MAX_STRICT_PICKS) : MAX_STRICT_PICKS;

              const strictPicks=[];
              for(const cand of refined){
                if(strictPicks.length>=maxStrict) break;
                if(cand.spread_bps>MAX_SPREAD_BPS) continue;
                if(!cand.passFill) continue;
                if(!cand.passEV) continue;
                if(cand.p_lcb<0.58) continue;
                if(cand.beta_r2>0.80) continue;
                let ok=true; for(const s of strictPicks){ if(rho(cand,s)>CORE_CORR_MAX){ ok=false; break; } }
                if(ok) strictPicks.push(cand);
              }

              let selected=[], selectionTier="none", forced=false, usedSpreadCap=MAX_SPREAD_BPS;
              if(strictPicks.length>0){
                selected=strictPicks.slice(0,Math.max(1,Math.min(3, strictPicks.length)));
                selectionTier="strict";
                reason = (reason!=="ok"?reason:"strict");
              }else{
                // Fallback Tier 1 (gentle relax)
                const OF_CORR_MAX=0.90;
                const fallback1=[];
                for(const cand of refined){
                  if(fallback1.length>=MAX_FALLBACK_PICKS) break;
                  if(cand.spread_bps>RELAXED_SPREAD_BPS) continue;
                  if(cand.fill_prob<0.55) continue;
                  const floor_relaxed = Math.max(EV_MIN_BPS, cand.floor_eff - 2);
                  const passEV_relaxed = (alpha<=0 && EV_MODE==="off") ? true : (cand.ev_bps >= floor_relaxed);
                  if(!passEV_relaxed) continue;
                  let ok=true; for(const s of fallback1){ if(rho(cand,s)>OF_CORR_MAX){ ok=false; break; } }
                  if(ok) fallback1.push(cand);
                }
                if(fallback1.length>0){
                  selected=fallback1;
                  selectionTier="fallback_t1";
                  forced=true;
                  usedSpreadCap=RELAXED_SPREAD_BPS;
                  reason = (reason!=="ok"?reason:"fallback_t1");
                }else{
                  // Fallback Tier 2: mega-caps with last-resort spread
                  const MEGAS=new Set(["BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT","DOGEUSDT"]);
                  const fallback2=[];
                  for(const cand of refined){
                    if(!MEGAS.has(cand.symbol)) continue;
                    if(cand.spread_bps>LAST_RESORT_SPREAD_BPS) continue;
                    if(!cand.passFill) continue; // keep normal fill
                    if(!( (alpha<=0 && EV_MODE==="off") ? true : (cand.ev_bps >= Math.max(EV_MIN_BPS, cand.floor_eff)) )) continue;
                    fallback2.push(cand);
                    if(fallback2.length>=Math.min(3,MAX_FALLBACK_PICKS)) break;
                  }
                  if(fallback2.length>0){
                    selected=fallback2;
                    selectionTier="fallback_t2";
                    forced=true;
                    usedSpreadCap=LAST_RESORT_SPREAD_BPS;
                    reason = (reason!=="ok"?reason:"fallback_t2");
                  }else{
                    reason = (reason!=="ok"?reason:"filtered_by_caps");
                  }
                }
              }

              // Sizing & TTL
              const size_mult = 0.6 + 0.4*alpha;
              const wEv = softmax(selected.map(x=>x.ev_bps||0), 20);

              const picks = selected.map((x,i)=>{
                // TTL base longer in trend, cut -10% if forced; stagger 10–20s by rank
                const adxF=clamp((Number(x.adx||0)-16)/14,0,1);
                let ttl = Math.round( 720 + 220*adxF + 140*(x.squeeze||0) );
                ttl = clamp(ttl, TTL_MIN, TTL_MAX);
                if(forced) ttl = Math.round(ttl*0.90);
                ttl += 10 + Math.min(20, i*10);

                const baseSz = x.sl_bps>0 ? Math.min(220, Math.round(wEv[i]*TARGET_PORT_RISK_BPS/x.sl_bps*100)) : 0;
                const finalSz = Math.max(0, Math.round(baseSz * size_mult * (forced?FALLBACK_SIZE_FACTOR:1.0)));

                return {
                  symbol: x.base,
                  symbol_full: x.symbol,
                  quote: x.quote,
                  side: x.side, rank:i+1,
                  ttl_sec: ttl,
                  p_win:x.p_win, p_lcb:x.p_lcb,
                  tp_bps:x.tp_bps, sl_bps:x.sl_bps, rrr:x.rrr,
                  exp_lcb_bps: Math.round((x.p_lcb*x.tp_bps) - ((1-x.p_lcb)*x.sl_bps) - x.cost_bps),
                  ev_bps: x.ev_bps, ev_mode: x.ev_mode,
                  spread_bps:x.spread_bps, cost_bps:x.cost_bps,
                  adx:x.adx, atr_bps:x.atr_bps, n_conf:x.n_conf, obi:x.obi,
                  regime:x.regime, style:x.style,
                  liq_pct:x.liq_pct, fill_prob:x.fill_prob,
                  quality_tag: selectionTier,
                  worker_sl_bps: EV_WORKER_SL_BPS, worker_tp_bps: EV_WORKER_TP_BPS,
                  size_bps: finalSz
                };
              });

              // Save cooldown + pending
              try{
                const nowMs=Date.now(); const ideasTs=new Date(nowMs).toISOString();
                for(const p of picks){
                  const bk=bookMap.get(p.symbol_full); const mid=bk? (bk.bid+bk.ask)/2 : 0;
                  state.cooldown[p.symbol]=nowMs;
                  state.cooldown_side[p.symbol]={ side:p.side, ts_ms:nowMs };
                  state.pending.push({
                    ts:ideasTs, ts_ms:nowMs, symbolFull:p.symbol_full, base:p.symbol, quote:p.quote, side:p.side,
                    entry_price:mid, hold_sec:p.ttl_sec, tp_bps:p.tp_bps, sl_bps:p.sl_bps, regime:p.regime, cost_bps:p.cost_bps
                  });
                }
                if(state.pending.length>550) state.pending=state.pending.slice(-550);
                state.last_ts=new Date().toISOString();
                await saveState(persist,state);
              }catch(e){ log("state save warn", e?.message||e); }

              // POST (always)
              const metaExtra = {
                exchange:"mexc", exchange_base: BASE,
                counts:{ universe:universe.length, pre:picksRaw.length, refined:refined.length, selected:selected.length },
                filters:{
                  dyn_min_qv:dynMinQV, univ_target_min:UNIV_TARGET_MIN, univ_target_max:UNIV_TARGET_MAX,
                  spread_caps:{ strict:MAX_SPREAD_BPS, relaxed:RELAXED_SPREAD_BPS, last_resort:LAST_RESORT_SPREAD_BPS },
                  ema_fast:EMA_FAST, ema_slow:EMA_SLOW, adx_p:ADX_P, atr_p:ATR_P, vwap_5m_win:VWAP_5M_WIN,
                  depth_limit: DEPTH_LIMIT, obi_topn: OBI_TOPN,
                  cooldown_min: COOLDOWN_MS/60000, flip_guard_min: FLIP_GUARD_MS/60000,
                  fees_bps:FEES_BPS, notional_usd:NOTIONAL, signal_notional_usd:SIGNAL_NOTIONAL
                },
                ev:{ impact_pct:EV_IMPACT_PCT, mode:EV_MODE, blend_w:EV_BLEND_W, slack_max_bps:EV_SLACK_MAX_BPS, min_bps:EV_MIN_BPS,
                     worker:{ sl_bps:EV_WORKER_SL_BPS, r:EV_WORKER_R, tp_bps:EV_WORKER_TP_BPS, floor_bps:EV_WORKER_FLOOR_BPS } },
                dd_gate:{ pnl24_bps, peak_dd_bps, throttle },
                tod: { active: S_H!=null && E_H!=null, start:S_H, end:E_H },
                tier: selectionTier, spread_cap_used: usedSpreadCap
              };
              const payload={ ts:new Date().toISOString(), mode:"normal", source:"external_pusher", meta:{ origin:"github_actions", reason, ...(metaExtra||{}) }, top_n:selected.length||0, ideas:picks||[] };

              console.log(`[gha] pushing ${selected.length} ideas (${selectionTier}) alpha=${alpha.toFixed(2)} EV_MODE=${EV_MODE} to ${PUSH_URL}`);
              try{
                const r=await fetchWithTimeout(PUSH_URL,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":`Bearer ${PUSH_TOKEN}` }, body: JSON.stringify(payload) },15000);
                let txt=""; try{ txt=await r.text(); }catch{}
                console.log(`[gha] push status ${r?.status||"ERR"} ${(txt||"").slice(0,400)}`);
              }catch(e){
                console.log(`[gha] push failed ${e?.message||e}`);
              }

            }catch(e){
              // Graceful fallback: always push minimal payload so tail shows a [push] line
              reason = reason!=="ok"?reason:"data_error";
              const payload={ ts:new Date().toISOString(), mode:"normal", source:"external_pusher", meta:{ origin:"github_actions", reason, error:(e?.message||String(e)).slice(0,220) }, top_n:0, ideas:[] };
              console.log(`[gha] pushing 0 ideas to ${PUSH_URL}`);
              try{
                const r=await fetchWithTimeout(PUSH_URL,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":`Bearer ${PUSH_TOKEN}` }, body: JSON.stringify(payload) },15000);
                let txt=""; try{ txt=await r.text(); }catch{}
                console.log(`[gha] push status ${r?.status||"ERR"} ${(txt||"").slice(0,200)}`);
              }catch(e2){
                console.log(`[gha] push failed ${e2?.message||e2}`);
              }
            }
          })();
          NODE
          EXIT_CODE=$?

          # Shell-level fallback (in case node crashed before posting)
          set -e
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo "[gha] pusher exited with code $EXIT_CODE — sending minimal payload so tail shows a [push] line"

            # 1) Fallback health GET (guaranteed Worker hit)
            health_url="${WORKER_PUSH_URL/\/signals\/push/\/health}"
            echo "[gha] fallback health GET ${health_url}"
            http_code_h=$(curl -sS -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${PUSH_TOKEN}" --max-time 8 "${health_url}" || true)
            echo "[gha] fallback health status ${http_code_h}"

            # 2) Minimal POST with 0 ideas
            now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            payload='{"ts":"'"$now"'","mode":"normal","source":"external_pusher","meta":{"origin":"github_actions","reason":"fallback_node_error"},"top_n":0,"ideas":[]}'
            echo "[gha] pushing 0 ideas to ${WORKER_PUSH_URL}"
            http_code=$(curl -sS -o /tmp/push_resp.txt -w "%{http_code}" -X POST \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer ${PUSH_TOKEN}" \
              --data "${payload}" \
              --max-time 12 \
              "${WORKER_PUSH_URL}" || true)
            body="$(head -c 400 /tmp/push_resp.txt || true)"
            echo "[gha] push status ${http_code} ${body}"
            exit 0
          fi
