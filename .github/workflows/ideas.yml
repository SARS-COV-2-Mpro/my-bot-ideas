name: Ideas Pusher (MEXC ULTIMATE EV@Pusher+, PRIME v6.2 Calibrated HeavyTail MP-Top20+Top3)

on:
  workflow_dispatch:
  schedule:
    - cron: "*/30 * * * *"

permissions:
  contents: read

concurrency:
  group: ideas-mexc-ultimate
  cancel-in-progress: true

jobs:
  push:
    runs-on: ubuntu-latest
    timeout-minutes: 12
    env:
      # Required secrets
      WORKER_PUSH_URL: ${{ secrets.WORKER_PUSH_URL }}
      PUSH_TOKEN: ${{ secrets.PUSH_TOKEN }}

      # Optional: Gist state persistence
      GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
      GIST_ID: ${{ secrets.GIST_ID }}

      # Only these 3 come from repo/org Variables (everything else is coded inside)
      DIRECTION: ${{ vars.DIRECTION }}         # "both" | "long" | "short"
      ALWAYS3_ENABLE: ${{ vars.ALWAYS3_ENABLE }}  # "true" or "false"
      FORCE_SIZE_BPS: ${{ vars.FORCE_SIZE_BPS }}  # integer bps per idea (0 = risk-based sizing)

    steps:
      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Run pusher (v6.2 — GP-Cls + Heavy-tail sims + Bandit + Symmetric guards + Safe fallback top-up)
        shell: bash
        run: |
          set -euo pipefail

          if [[ -z "${WORKER_PUSH_URL:-}" || -z "${PUSH_TOKEN:-}" ]]; then
            echo "[gha] Missing WORKER_PUSH_URL or PUSH_TOKEN"
            exit 1
          fi

          set +e
          node - <<'NODE'
          (async ()=>{
            'use strict';

            // ---------------- Utils ----------------
            const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
            const tanh=(x)=>Math.tanh(x);
            const sum=(a)=>a.reduce((x,y)=>x+y,0);
            const mean=(a)=>a.length?sum(a)/a.length:0;
            const std=(a)=>{const m=mean(a); let v=0; for(const x of a)v+=(x-m)*(x-m); return a.length>1?Math.sqrt(v/(a.length-1)):0;};
            const ema=(arr,p)=>{ if(!arr||arr.length<p) return null; const k=2/(p+1); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; for(let i=p;i<arr.length;i++) e=arr[i]*k+e*(1-k); return e; };
            const emaSeries=(arr,p)=>{ if(!arr||arr.length<p) return null; const k=2/(p+1); const out=Array(arr.length).fill(null); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; out[p-1]=e; for(let i=p;i<arr.length;i++){ e=arr[i]*k+e*(1-k); out[i]=e; } return out; };
            const rsi=(cl,p=14)=>{ if(!cl||cl.length<=p) return null; let g=0,l=0; for(let i=1;i<=p;i++){ const d=cl[i]-cl[i-1]; g+=Math.max(0,d); l+=Math.max(0,-d); } let ag=g/p, al=l/p; for(let i=p+1;i<cl.length;i++){ const d=cl[i]-cl[i-1]; ag=(ag*(p-1)+Math.max(0,d))/p; al=(al*(p-1)+Math.max(0,-d))/p; } const rs=al===0?100:ag/al; return 100-100/(1+rs); };
            function kalman1D(obs,{q=1e-5,r=1e-3,x0=null,p0=1e-2}={}){
              if(!obs?.length) return [];
              let x=(x0==null?obs[0]:x0), p=p0;
              const out=[];
              for(const z of obs){
                p+=q;
                const K=p/(p+r);
                x=x + K*(z-x);
                p=(1-K)*p;
                out.push(x);
              }
              return out;
            }
            const computeADX_ATR=(h,l,c,p=14)=>{ const n=c.length; if(n<p+2) return null; const TR=[],plusDM=[],minusDM=[];
              for(let i=1;i<n;i++){ const up=h[i]-h[i-1], down=l[i-1]-l[i]; plusDM.push((up>down&&up>0)?up:0); minusDM.push((down>up&&down>0)?down:0);
                TR.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1]))); }
              let trN=0,pdmN=0,ndmN=0; for(let i=0;i<p;i++){ trN+=TR[i]; pdmN+=plusDM[i]; ndmN+=minusDM[i]; }
              let pDI=100*(pdmN/(trN||1)), nDI=100*(ndmN/(trN||1)); let dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1), adx=dx;
              for(let i=p;i<TR.length;i++){ trN=trN-(trN/p)+TR[i]; pdmN=pdmN-(pdmN/p)+plusDM[i]; ndmN=ndmN-(ndmN/p)+minusDM[i];
                pDI=100*(pdmN/(trN||1)); nDI=100*(ndmN/(trN||1)); dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1); adx=((adx*(p-1))+dx)/p; }
              const atr=trN/p; return { adx, atr, trLast: TR.at(-1) };
            };
            const vwapAnchored=(h,l,c,v,win)=>{ if(!c?.length) return null; const n=c.length,s=Math.max(0,n-win); let pv=0,vv=0; for(let i=s;i<n;i++){ const tp=(h[i]+l[i]+c[i])/3; const vol=+v[i]||0; pv+=tp*vol; vv+=vol; } return vv>0?pv/vv:c.at(-1); };
            const corr=(a,b)=>{ const n=Math.min(a?.length||0,b?.length||0); if(n<5) return 0; const as=a.slice(-n), bs=b.slice(-n); const ma=mean(as), mb=mean(bs); let num=0,da=0,db=0; for(let i=0;i<n;i++){ const xa=as[i]-ma, xb=bs[i]-mb; num+=xa*xb; da+=xa*xa; db+=xb*xb; } const den=Math.sqrt(da*db)||1; return num/den; };
            const wilsonLCB=(p,n,z=1.34)=>{ if(n<=0) return p; const z2=z*z; const a=p + z2/(2*n); const b=z*Math.sqrt((p*(1-p)+z2/(4*n))/n); const c=1+z2/n; return clamp((a-b)/c, 0, 1); };
            const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
            const jitter=(ms)=>ms + Math.floor(Math.random()*ms*0.25);
            const softmax=(arr,t=20)=>{ const m=Math.max(...arr,0); const ex=arr.map(x=>Math.exp((x-m)/t)); const s=ex.reduce((a,b)=>a+b,0)||1; return ex.map(x=>x/s); };
            const sigmoid=(z)=>1/(1+Math.exp(-z));

            // RNG
            let bmSpare=null;
            const randn=()=>{ if(bmSpare!=null){ const v=bmSpare; bmSpare=null; return v; } let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); const r=Math.sqrt(-2*Math.log(u)); const th=2*Math.PI*v; bmSpare=r*Math.sin(th); return r*Math.cos(th); };
            function randt(df){ if(df<=2) df=2.01; const z=randn(); let x2=0; for(let i=0;i<Math.floor(df);i++){ const z2=randn(); x2+=z2*z2; } const frac=df-Math.floor(df); if(frac>0){ const zf=randn(); x2+=frac*zf*zf; } const chi=x2||1e-6; return z / Math.sqrt(chi/df); }

            // IO snapshot for counts
            const fs = require('fs');
            function snapCounts(partial){
              try{
                const prev = fs.existsSync('/tmp/pusher_counts.json')
                  ? JSON.parse(fs.readFileSync('/tmp/pusher_counts.json','utf8')||'{}')
                  : {};
                const next = { ...prev, ...partial };
                fs.writeFileSync('/tmp/pusher_counts.json', JSON.stringify(next));
              }catch{}
            }
            
            // ---- Crypto + stable stringify for hashes ----
            const crypto = require('crypto');
            const stableStringify=(obj)=>{
              const seen=new WeakSet();
              const sort=(v)=>{
                if(v===null||typeof v!=='object') return v;
                if(seen.has(v)) return null;
                seen.add(v);
                if(Array.isArray(v)) return v.map(sort);
                const keys=Object.keys(v).sort();
                const o={}; for(const k of keys) o[k]=sort(v[k]); return o;
              };
              return JSON.stringify(sort(obj));
            };
            const sha256Hex=(s)=>crypto.createHash('sha256').update(String(s)).digest('hex');

            // ------------- Heavy-tail Monte Carlo (t + bootstrap) -------------
            function pathEVHeavy({entry,tp_bps,sl_bps,side,retSeries,mu,sigma,steps,N=192,cost_bps=10,t_df=5,boot_block=3}){
              const up=(side==="long"), tpF=tp_bps/10000, slF=sl_bps/10000; let ev=0, wins=0; const rets=retSeries||[];
              const boot1=()=>{ if(rets.length<8) return Array(steps).fill(0).map(()=> sigma*Math.sqrt(1/steps)*randn()); const out=[]; while(out.length<steps){ const start=Math.floor(Math.random()*(rets.length-boot_block)); for(let k=0;k<boot_block && out.length<steps;k++) out.push(rets[start+k]||0); } return out.slice(0,steps); };
              for(let n=0;n<N;n++){
                const mode=(n%2===0)?"t":"boot";
                let S=entry, tp=up? entry*(1+tpF):entry*(1-tpF), sl=up? entry*(1-slF):entry*(1+slF);
                let pnl_bps=0,win=0;
                const rs=(mode==="t")? Array(steps).fill(0).map(()=> mu + sigma*randt(t_df)/Math.sqrt(steps)) : boot1();
                for(let t=0;t<steps;t++){
                  const r=rs[t];
                  S=S*(1+r);
                  if(up){ if(S>=tp){ pnl_bps=tp_bps-cost_bps; win=1; break;} if(S<=sl){ pnl_bps=-sl_bps-cost_bps; win=0; break;} }
                  else { if(S<=tp){ pnl_bps=tp_bps-cost_bps; win=1; break;} if(S>=sl){ pnl_bps=-sl_bps-cost_bps; win=0; break;} }
                  if(t===steps-1){ const ret=up? (S/entry-1):(entry/S-1); pnl_bps=Math.round(ret*10000)-cost_bps; win=pnl_bps>0?1:0; }
                }
                ev+=pnl_bps; wins+=win;
              }
              const p=wins/N, ev_mean=ev/N;
              return { p, ev_bps:Math.round(ev_mean) };
            }

            // ------------- t-copula VaR/ES -------------
            function cholesky(A){
              const n=A.length; const L=Array.from({length:n},()=>Array(n).fill(0));
              for(let i=0;i<n;i++){
                for(let j=0;j<=i;j++){
                  let s=0; for(let k=0;k<j;k++) s+=L[i][k]*L[j][k];
                  const v=A[i][j]-s;
                  if(i===j){ if(v<=1e-12) return null; L[i][j]=Math.sqrt(Math.max(v,1e-12)); }
                  else { L[i][j]=v/(L[j][j]||1e-12); }
                }
              }
              return L;
            }
            function choleskySafe(S){
              const L=cholesky(S);
              if(L) return L;
              const n=S.length;
              const Sc=S.map((r,i)=> r.map((v,j)=> v + (i===j?1e-6:0)));
              return cholesky(Sc);
            }
            function sampleMultiT(muVec,Sigma,df=6,M=1000){
              const n=muVec.length;
              const L=choleskySafe(Sigma); if(!L) return [];
              const out=[];
              for(let m=0;m<M;m++){
                const z=Array(n).fill(0).map(()=>randn());
                const y=Array(n).fill(0);
                for(let i=0;i<n;i++){ let s=0; for(let k=0;k<=i;k++) s+=L[i][k]*z[k]; y[i]=s; }
                let chi=0; for(let i=0;i<df;i++){ const zc=randn(); chi+=zc*zc; }
                const scale=Math.sqrt(df/Math.max(1e-9,chi));
                out.push(y.map((yi,i)=> (muVec[i]||0) + yi*scale));
              }
              return out;
            }
            function portfolioVaR_ES_tCopula(picks, df=6){
              if(!picks.length) return { VaR95_bps:0, ES95_bps:0 };
              const n=picks.length, mu=Array(n).fill(0), sd=Array(n).fill(0);
              for(let i=0;i<n;i++){
                const r5=picks[i].ret5||[]; const rMean=mean(r5), rStd=std(r5)||1e-4;
                const steps=Math.max(1, Math.round((picks[i].ttl_sec||600)/300));
                mu[i]=rMean*steps*10000;
                sd[i]=rStd*Math.sqrt(steps)*10000;
              }
              const R=Array.from({length:n},()=>Array(n).fill(0));
              for(let i=0;i<n;i++){
                for(let j=0;j<n;j++) R[i][j]=corr(picks[i].ret5||[], picks[j].ret5||[]);
                R[i][i]=1;
              }
              const Sigma=Array.from({length:n},()=>Array(n).fill(0));
              for(let i=0;i<n;i++) for(let j=0;j<n;j++) Sigma[i][j]=R[i][j]*sd[i]*sd[j];
              const draws=sampleMultiT(mu,Sigma,df,1200);
              if(!draws.length) return { VaR95_bps:0, ES95_bps:0 };
              const w0=picks.map(p=> p.size_bps||0); const ws=sum(w0)||1; const w=w0.map(x=> x/ws);
              const port=draws.map(d=> d.reduce((acc,di,ii)=> acc + w[ii]*di, 0));
              port.sort((a,b)=>a-b);
              const idx=Math.floor(0.05*port.length);
              const VaR95=port[idx]||0;
              const ES=mean(port.slice(0,idx+1));
              return { VaR95_bps:Math.round(VaR95), ES95_bps:Math.round(ES) };
            }

            // ---------- Config (only 3 envs used; rest are coded here) ----------
            const UA="gh-actions-ideas-mexc-ultimate/6.2-prime (+https://github.com/)";
            async function fetchWithTimeout(url,opts={},ms=12000){ const ac=new AbortController(); const t=setTimeout(()=>ac.abort(),ms); try{ return await fetch(url,{...opts,signal:ac.signal,headers:{"User-Agent":UA,...(opts?.headers||{})}});} finally{ clearTimeout(t);} }
            async function getJSON(url,ms=12000,tries=2){ for(let a=0;a<tries;a++){ try{ const r=await fetchWithTimeout(url,{},ms); if(r?.ok){ return await r.json(); } }catch{} await sleep(jitter(220)); } return null; }

            const DIRECTION=(process.env.DIRECTION||"both").trim().toLowerCase();
            const ALWAYS3_ENV_RAW = (process.env.ALWAYS3_ENABLE ?? "").toString();
            const ALWAYS3_ENABLE = /^(true|1|yes|y|on)$/i.test(ALWAYS3_ENV_RAW.trim());
            console.log("[env] ALWAYS3_ENABLE raw:", JSON.stringify(ALWAYS3_ENV_RAW.trim()));
            const FORCE_SIZE_BPS=Number(process.env.FORCE_SIZE_BPS||"0")||0;

            const EXCHANGE="mexc";
            const MEXC_BASES=["https://api.mexc.com","https://www.mexc.com"];
            const TOP_N=3;
            const MAX_SPREAD_BPS=12;
            const FEES_BPS=10;
            const LONG_MAX_COST_BPS=16;
            const MAX_COST_BPS_HARD=15;
            const MR_SPREAD_MAX_BPS=8;
            const EXP_LCB_MIN_BPS=18;
            const EXP_LCB_MIN_BPS_FB=16;
            const NOTIONAL=3000;
            const MEXC_DEPTH_LIMIT=50;
            const OBI_TOPN=12;
            const MIN_VOL_1H_USD=5_000_000;
            const DEPTH_1P_MIN_USD=200_000;
            const EMA_FAST=21, EMA_SLOW=50, ADX_P=14, ATR_P=14;
            const K1M=240, K5M=300, K15M=120, K1H=96;
            const VWAP_5M_WIN=36;
            const TARGET_PORT_RISK_BPS=52;
            const TTL_MIN=540, TTL_MAX=1200;
            const MOMENTUM_SIZE_FACTOR=0.5;
            const NO_LONG_DOWN_ENABLE=true;
            const LONG_DOWN_RSI_CUTOFF=40;
            const LONG_MR_DIVERGENCE_REQ=true;
            const LONG_EDGE_MULT_MIN=4;
            const LONG_BOUNCE_SL_ATR=0.50;
            const LONG_BOUNCE_TP_ATR=0.90;
            const LONG_BOUNCE_HOLD_MIN_SEC=900;
            const LONG_BOUNCE_HOLD_MAX_SEC=2400;
            const LONG_ENTRY_BOUNCE_OFFSET=0.0015;
            const LONG_SIMILARITY_RHO=0.84;
            const LONG_KILL_MIN_TRADES=20;
            const LONG_KILL_WINRATE=0.20;
            const LONG_KILL_SIZE_MULT=0.5;
            const ALWAYS3_SIZE_FACTOR=0.15;
            const ALWAYS3_REQUIRE_BTC_GREEN=true;
            const FALLBACK_SHORT_ADX_MIN=16;
            const FALLBACK_PLCB_LONG=0.58;
            const FALLBACK_PLCB_SHORT=0.55;
            const MAX_FALLBACK_SL_BPS = 60;
            const WILSON_Z=1.34;
            const MR_ADX_MAX_DEFAULT=20;
            const MR_SLOPE_MAX_ATR50=0.50;
            const MR_BREAKOUT_DC_N=120;
            const MR_BREAKOUT_RET15_ATR=1.5;
            const MR_LOCKOUT_SEC=1800;
            const UNIV_TARGET_MIN=100, UNIV_TARGET_MAX=120;
            const DYN_QV_MIN=6_000_000;
            const DYN_QV_STEP=5_000_000;
            const STABLES=new Set(["USDT","USDC","USD","USDE","USDD","BUSD","FDUSD","TUSD","DAI","USDP","PAX","USTC","STBL"]);
            const LONG_NAUGHTY_BASES=new Set(["EDU","THE","HEMI","COOKIE","MNT","ASTER","AVNT","VANA","ETHFI","SIGN","STBL"]);
            const ALLOWED=new Set(DIRECTION==="both"? ["long","short"] : [DIRECTION]);
            const PUSH_URL=process.env.WORKER_PUSH_URL||"";
            const PUSH_TOKEN=process.env.PUSH_TOKEN||"";
            const HEALTH_URL=(()=>{ try{ const u=new URL(PUSH_URL); return `${u.origin}${u.pathname.replace(/\/signals\/push(\?.*)?$/,"/health")}`;}catch{return PUSH_URL.replace(/\/signals\/push(\?.*)?$/,"/health");}})();

            // ---------- MEXC Adapter ----------
            async function pickMexcBase(){ for(const b of MEXC_BASES){ try{ const r=await fetchWithTimeout(`${b}/api/v3/time`,{},4000); if(r?.ok) return b; }catch{} } throw new Error("No healthy MEXC base"); }
            const BASE=await pickMexcBase();
            const api=(path,params={})=>{ const u=new URL(path,BASE); for(const [k,v] of Object.entries(params)){ if(v!==undefined&&v!==null) u.searchParams.set(k,String(v)); } return u.toString(); };
            async function fetchK(sym,interval,limit,startTime,endTime){ const u=api("/api/v3/klines",{symbol:sym,interval,limit,startTime,endTime}); const r=await getJSON(u,10000,2); return Array.isArray(r)?r:null; }
            async function fetchDepth(symbol){ return await getJSON(api("/api/v3/depth",{symbol,limit:MEXC_DEPTH_LIMIT}), 10000, 2); }
            async function fetchAll24hr(){
              let all = await getJSON(api("/api/v3/ticker/24hr"), 10000, 2);
              if(Array.isArray(all) && all.length) return all;
              const exi=await getJSON(api("/api/v3/exchangeInfo"), 10000, 2);
              const syms=(exi?.symbols||[]).filter(s=>s.status==="TRADING").map(s=>s.symbol).slice(0,300);
              const out=[]; for(let i=0;i<syms.length;i+=24){ const chunk=syms.slice(i,i+24); const got=await Promise.all(chunk.map(s=>getJSON(api("/api/v3/ticker/24hr",{symbol:s}),6000,1))); for(const x of got) if(x) out.push(x); await sleep(180); }
              return out;
            }
            async function fetchBookTicker(symbol){ return await getJSON(api("/api/v3/ticker/bookTicker",{symbol}), 8000, 1); }

            // ---------- Provenance ----------
            async function getMexcTime(){ const j=await getJSON(api("/api/v3/time"), 8000, 2); const st=+j?.serverTime||Date.now(); return { mexc_server_time_ms: st, mexc_time_offset_ms: st - Date.now() }; }
            function buildConfigHash(){
              const cfg = {
                EXCHANGE, TOP_N, MAX_SPREAD_BPS, EXP_LCB_MIN_BPS, EXP_LCB_MIN_BPS_FB,
                FEES_BPS, LONG_MAX_COST_BPS, MAX_COST_BPS_HARD, MR_SPREAD_MAX_BPS,
                NOTIONAL, MEXC_DEPTH_LIMIT, OBI_TOPN, MIN_VOL_1H_USD, DEPTH_1P_MIN_USD,
                EMA_FAST, EMA_SLOW, ADX_P, ATR_P, VWAP_5M_WIN, TTL_MIN, TTL_MAX,
                TARGET_PORT_RISK_BPS, MOMENTUM_SIZE_FACTOR,
                NO_LONG_DOWN_ENABLE, LONG_DOWN_RSI_CUTOFF, LONG_MR_DIVERGENCE_REQ,
                LONG_EDGE_MULT_MIN, LONG_BOUNCE_SL_ATR, LONG_BOUNCE_TP_ATR,
                LONG_BOUNCE_HOLD_MIN_SEC, LONG_BOUNCE_HOLD_MAX_SEC, LONG_ENTRY_BOUNCE_OFFSET,
                LONG_SIMILARITY_RHO, LONG_KILL_MIN_TRADES, LONG_KILL_WINRATE, LONG_KILL_SIZE_MULT,
                ALWAYS3_ENABLE, ALWAYS3_SIZE_FACTOR, ALWAYS3_REQUIRE_BTC_GREEN,
                FALLBACK_SHORT_ADX_MIN, FALLBACK_PLCB_LONG, FALLBACK_PLCB_SHORT,
                MR_ADX_MAX_DEFAULT, MR_SLOPE_MAX_ATR50, MR_BREAKOUT_DC_N, MR_BREAKOUT_RET15_ATR, MR_LOCKOUT_SEC,
                STABLES:[...STABLES], LONG_NAUGHTY_BASES:[...LONG_NAUGHTY_BASES], DIRECTION
              };
              return "sha256:"+sha256Hex(stableStringify(cfg));
            }
            const pusher_version="mexc-ultimate-6.2-prime";
            const code_commit_sha=(process.env.GITHUB_SHA||"").slice(0,40);
            const run_id=new Date().toISOString()+"#6.2";
            const mexcTime=await getMexcTime();
            const config_hash=buildConfigHash();
            let run_prov={ run_id, code_commit_sha, pusher_version, config_hash, exchange_base:BASE, ...mexcTime, p_model:{ gp_hash:null, calib_type:"mixed", calib_n:0 } };
            console.log("[step] provenance:", { run_id, base: BASE, direction: DIRECTION, always3: ALWAYS3_ENABLE, force_size_bps: FORCE_SIZE_BPS });
          })();
          NODE
          EXIT_CODE=$?
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo "[gha] node exited early ($EXIT_CODE)"; exit 1
          fi

      - name: Run pusher (selection/push) — Section 2/2
        shell: bash
        run: |
          set -euo pipefail

          node - <<'NODE'
          (async ()=>{
            'use strict';

            // ---------- Small utils ----------
            const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
            const tanh=(x)=>Math.tanh(x);
            const sum=(a)=>a.reduce((x,y)=>x+y,0);
            const mean=(a)=>a.length?sum(a)/a.length:0;
            const std=(a)=>{const m=mean(a); let v=0; for(const x of a)v+=(x-m)*(x-m); return a.length>1?Math.sqrt(v/(a.length-1)):0;};
            const ema=(arr,p)=>{ if(!arr||arr.length<p) return null; const k=2/(p+1); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; for(let i=p;i<arr.length;i++) e=arr[i]*k+e*(1-k); return e; };
            const emaSeries=(arr,p)=>{ if(!arr||arr.length<p) return null; const k=2/(p+1); const out=Array(arr.length).fill(null); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; out[p-1]=e; for(let i=p;i<arr.length;i++){ e=arr[i]*k+e*(1-k); out[i]=e; } return out; };
            const rsi=(cl,p=14)=>{ if(!cl||cl.length<=p) return null; let g=0,l=0; for(let i=1;i<=p;i++){ const d=cl[i]-cl[i-1]; g+=Math.max(0,d); l+=Math.max(0,-d); } let ag=g/p, al=l/p; for(let i=p+1;i<cl.length;i++){ const d=cl[i]-cl[i-1]; ag=(ag*(p-1)+Math.max(0,d))/p; al=(al*(p-1)+Math.max(0,-d))/p; } const rs=al===0?100:ag/al; return 100-100/(1+rs); };
            function kalman1D(obs,{q=1e-5,r=1e-3,x0=null,p0=1e-2}={}){
              if(!obs?.length) return [];
              let x=(x0==null?obs[0]:x0), p=p0;
              const out=[];
              for(const z of obs){
              p+=q;
              const K=p/(p+r);
              x=x + K*(z-x);
              p=(1-K)*p;
              out.push(x);
              }
              return out;
            }
            const corr=(a,b)=>{ const n=Math.min(a?.length||0,b?.length||0); if(n<5) return 0; const as=a.slice(-n), bs=b.slice(-n); const ma=mean(as), mb=mean(bs); let num=0,da=0,db=0; for(let i=0;i<n;i++){ const xa=as[i]-ma, xb=bs[i]-mb; num+=xa*xb; da+=xa*xa; db+=xb*xb; } const den=Math.sqrt(da*db)||1; return num/den; };
            const wilsonLCB=(p,n,z=1.34)=>{ if(n<=0) return p; const z2=z*z; const a=p + z2/(2*n); const b=z*Math.sqrt((p*(1-p)+z2/(4*n))/n); const c=1+z2/n; return clamp((a-b)/c, 0, 1); };
            const softmax=(arr,t=20)=>{ const m=Math.max(...arr,0); const ex=arr.map(x=>Math.exp((x-m)/t)); const s=ex.reduce((a,b)=>a+b,0)||1; return ex.map(x=>x/s); };
            const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
            const jitter=(ms)=>ms + Math.floor(Math.random()*ms*0.25);

            // Randoms
            let bmSpare=null;
            const randn=()=>{ if(bmSpare!=null){ const v=bmSpare; bmSpare=null; return v; } let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); const r=Math.sqrt(-2*Math.log(u)); const th=2*Math.PI*v; bmSpare=r*Math.sin(th); return r*Math.cos(th); };
            function randt(df){ if(df<=2) df=2.01; const z=randn(); let x2=0; for(let i=0;i<Math.floor(df);i++){ const z2=randn(); x2+=z2*z2; } const frac=df-Math.floor(df); if(frac>0){ const zf=randn(); x2+=frac*zf*zf; } const chi=x2||1e-6; return z / Math.sqrt(chi/df); }

            // IO counts snapshot for fallback curl if needed
            const fs=require('fs');
            function snapCounts(partial){
              try{
                const prev = fs.existsSync('/tmp/pusher_counts.json')
                  ? JSON.parse(fs.readFileSync('/tmp/pusher_counts.json','utf8')||'{}')
                  : {};
                const next = { ...prev, ...partial };
                fs.writeFileSync('/tmp/pusher_counts.json', JSON.stringify(next));
              }catch{}
            }

            // Matrix + crypto utils
            const crypto=require('crypto');
            const stableStringify=(obj)=>{
              const seen=new WeakSet();
              const sort=(v)=>{
                if(v===null||typeof v!=='object') return v;
                if(seen.has(v)) return null;
                seen.add(v);
                if(Array.isArray(v)) return v.map(sort);
                const keys=Object.keys(v).sort();
                const o={}; for(const k of keys) o[k]=sort(v[k]); return o;
              };
              return JSON.stringify(sort(obj));
            };
            const sha256Hex=(s)=>crypto.createHash('sha256').update(String(s)).digest('hex');

            // Indicators
            const computeADX_ATR=(h,l,c,p=14)=>{ const n=c.length; if(n<p+2) return null; const TR=[],plusDM=[],minusDM=[];
              for(let i=1;i<n;i++){ const up=h[i]-h[i-1], down=l[i-1]-l[i]; plusDM.push((up>down&&up>0)?up:0); minusDM.push((down>up&&down>0)?down:0);
                TR.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1]))); }
              let trN=0,pdmN=0,ndmN=0; for(let i=0;i<p;i++){ trN+=TR[i]; pdmN+=plusDM[i]; ndmN+=minusDM[i]; }
              let pDI=100*(pdmN/(trN||1)), nDI=100*(ndmN/(trN||1)); let dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1), adx=dx;
              for(let i=p;i<TR.length;i++){ trN=trN-(trN/p)+TR[i]; pdmN=pdmN-(pdmN/p)+plusDM[i]; ndmN=ndmN-(ndmN/p)+minusDM[i];
                pDI=100*(pdmN/(trN||1)); nDI=100*(ndmN/(trN||1)); dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1); adx=((adx*(p-1))+dx)/p; }
              const atr=trN/p; return { adx, atr, trLast: TR.at(-1) };
            };
            const vwapAnchored=(h,l,c,v,win)=>{ if(!c?.length) return null; const n=c.length,s=Math.max(0,n-win); let pv=0,vv=0; for(let i=s;i<n;i++){ const tp=(h[i]+l[i]+c[i])/3; const vol=+v[i]||0; pv+=tp*vol; vv+=vol; } return vv>0?pv/vv:c.at(-1); };

            // Heavy-tail MC and VaR/ES
            function pathEVHeavy({entry,tp_bps,sl_bps,side,retSeries,mu,sigma,steps,N=192,cost_bps=10,t_df=5,boot_block=3}){
              const up=(side==="long"), tpF=tp_bps/10000, slF=sl_bps/10000; let ev=0, wins=0; const rets=retSeries||[];
              const boot1=()=>{ if(rets.length<8) return Array(steps).fill(0).map(()=> sigma*Math.sqrt(1/steps)*randn()); const out=[]; while(out.length<steps){ const start=Math.floor(Math.random()*(rets.length-boot_block)); for(let k=0;k<boot_block && out.length<steps;k++) out.push(rets[start+k]||0); } return out.slice(0,steps); };
              for(let n=0;n<N;n++){
                const mode=(n%2===0)?"t":"boot";
                let S=entry, tp=up? entry*(1+tpF):entry*(1-tpF), sl=up? entry*(1-slF):entry*(1+slF);
                let pnl_bps=0,win=0;
                const rs=(mode==="t")? Array(steps).fill(0).map(()=> mu + sigma*randt(t_df)/Math.sqrt(steps)) : boot1();
                for(let t=0;t<steps;t++){
                  const r=rs[t];
                  S=S*(1+r);
                  if(up){ if(S>=tp){ pnl_bps=tp_bps-cost_bps; win=1; break;} if(S<=sl){ pnl_bps=-sl_bps-cost_bps; win=0; break;} }
                  else { if(S<=tp){ pnl_bps=tp_bps-cost_bps; win=1; break;} if(S>=sl){ pnl_bps=-sl_bps-cost_bps; win=0; break;} }
                  if(t===steps-1){ const ret=up? (S/entry-1):(entry/S-1); pnl_bps=Math.round(ret*10000)-cost_bps; win=pnl_bps>0?1:0; }
                }
                ev+=pnl_bps; wins+=win;
              }
              const p=wins/N, ev_mean=ev/N;
              return { p, ev_bps:Math.round(ev_mean) };
            }
            function cholesky(A){
              const n=A.length; const L=Array.from({length:n},()=>Array(n).fill(0));
              for(let i=0;i<n;i++){
                for(let j=0;j<=i;j++){
                  let s=0; for(let k=0;k<j;k++) s+=L[i][k]*L[j][k];
                  const v=A[i][j]-s;
                  if(i===j){ if(v<=1e-12) return null; L[i][j]=Math.sqrt(Math.max(v,1e-12)); }
                  else { L[i][j]=v/(L[j][j]||1e-12); }
                }
              }
              return L;
            }
            function choleskySafe(S){
              const L=cholesky(S);
              if(L) return L;
              const n=S.length;
              const Sc=S.map((r,i)=> r.map((v,j)=> v + (i===j?1e-6:0)));
              return cholesky(Sc);
            }
            function sampleMultiT(muVec,Sigma,df=6,M=1000){
              const n=muVec.length;
              const L=choleskySafe(Sigma); if(!L) return [];
              const out=[];
              for(let m=0;m<M;m++){
                const z=Array(n).fill(0).map(()=>randn());
                const y=Array(n).fill(0);
                for(let i=0;i<n;i++){ let s=0; for(let k=0;k<=i;k++) s+=L[i][k]*z[k]; y[i]=s; }
                let chi=0; for(let i=0;i<df;i++){ const zc=randn(); chi+=zc*zc; }
                const scale=Math.sqrt(df/Math.max(1e-9,chi));
                out.push(y.map((yi,i)=> (muVec[i]||0) + yi*scale));
              }
              return out;
            }
            function portfolioVaR_ES_tCopula(picks, df=6){
              if(!picks.length) return { VaR95_bps:0, ES95_bps:0 };
              const n=picks.length, mu=Array(n).fill(0), sd=Array(n).fill(0);
              for(let i=0;i<n;i++){
                const r5=picks[i].ret5||[]; const rMean=mean(r5), rStd=std(r5)||1e-4;
                const steps=Math.max(1, Math.round((picks[i].ttl_sec||600)/300));
                mu[i]=rMean*steps*10000;
                sd[i]=rStd*Math.sqrt(steps)*10000;
              }
              const R=Array.from({length:n},()=>Array(n).fill(0));
              for(let i=0;i<n;i++){
                for(let j=0;j<n;j++) R[i][j]=corr(picks[i].ret5||[], picks[j].ret5||[]);
                R[i][i]=1;
              }
              const Sigma=Array.from({length:n},()=>Array(n).fill(0));
              for(let i=0;i<n;i++) for(let j=0;j<n;j++) Sigma[i][j]=R[i][j]*sd[i]*sd[j];
              const draws=sampleMultiT(mu,Sigma,df,1200);
              if(!draws.length) return { VaR95_bps:0, ES95_bps:0 };
              const w0=picks.map(p=> p.size_bps||0); const ws=sum(w0)||1; const w=w0.map(x=> x/ws);
              const port=draws.map(d=> d.reduce((acc,di,ii)=> acc + w[ii]*di, 0));
              port.sort((a,b)=>a-b);
              const idx=Math.floor(0.05*port.length);
              const VaR95=port[idx]||0;
              const ES=mean(port.slice(0,idx+1));
              return { VaR95_bps:Math.round(VaR95), ES95_bps:Math.round(ES) };
            }

            // ---------- Config (3 envs only) ----------
            const UA="gh-actions-ideas-mexc-ultimate/6.2-prime (+https://github.com/)";
            async function fetchWithTimeout(url,opts={},ms=12000){ const ac=new AbortController(); const t=setTimeout(()=>ac.abort(),ms); try{ return await fetch(url,{...opts,signal:ac.signal,headers:{"User-Agent":UA,...(opts?.headers||{})}});} finally{ clearTimeout(t);} }
            async function getJSON(url,ms=12000,tries=2){ for(let a=0;a<tries;a++){ try{ const r=await fetchWithTimeout(url,{},ms); if(r?.ok){ return await r.json(); } }catch{} await sleep(jitter(220)); } return null; }

            const DIRECTION=(process.env.DIRECTION||"both").trim().toLowerCase();
            const ALWAYS3_ENV_RAW = (process.env.ALWAYS3_ENABLE ?? "").toString();
            const ALWAYS3_ENABLE = /^(true|1|yes|y|on)$/i.test(ALWAYS3_ENV_RAW.trim());
            console.log("[env] ALWAYS3_ENABLE raw:", JSON.stringify(ALWAYS3_ENV_RAW.trim()));
            const FORCE_SIZE_BPS=Number(process.env.FORCE_SIZE_BPS||"0")||0;

            const EXCHANGE="mexc";
            const MEXC_BASES=["https://api.mexc.com","https://www.mexc.com"];
            const TOP_N=3;
            const MAX_SPREAD_BPS=12;
            const FEES_BPS=10;
            const LONG_MAX_COST_BPS=16;
            const MAX_COST_BPS_HARD=15;
            const MR_SPREAD_MAX_BPS=8;
            const EXP_LCB_MIN_BPS=18;
            const EXP_LCB_MIN_BPS_FB=16;
            const NOTIONAL=3000;
            const MEXC_DEPTH_LIMIT=50;
            const OBI_TOPN=12;
            const MIN_VOL_1H_USD=5_000_000;
            const DEPTH_1P_MIN_USD=200_000;
            const EMA_FAST=21, EMA_SLOW=50, ADX_P=14, ATR_P=14;
            const K1M=240, K5M=300, K15M=120, K1H=96;
            const VWAP_5M_WIN=36;
            const TARGET_PORT_RISK_BPS=52;
            const TTL_MIN=540, TTL_MAX=1200;
            const MOMENTUM_SIZE_FACTOR=0.5;
            const NO_LONG_DOWN_ENABLE=true;
            const LONG_DOWN_RSI_CUTOFF=40;
            const LONG_MR_DIVERGENCE_REQ=true;
            const LONG_EDGE_MULT_MIN=4;
            const LONG_BOUNCE_SL_ATR=0.50;
            const LONG_BOUNCE_TP_ATR=0.90;
            const LONG_BOUNCE_HOLD_MIN_SEC=900;
            const LONG_BOUNCE_HOLD_MAX_SEC=2400;
            const LONG_ENTRY_BOUNCE_OFFSET=0.0015;
            const LONG_SIMILARITY_RHO=0.84;
            const LONG_KILL_MIN_TRADES=20;
            const LONG_KILL_WINRATE=0.20;
            const LONG_KILL_SIZE_MULT=0.5;
            const ALWAYS3_SIZE_FACTOR=0.15;
            const ALWAYS3_REQUIRE_BTC_GREEN=true;
            const FALLBACK_SHORT_ADX_MIN=16;
            const FALLBACK_PLCB_LONG=0.58;
            const FALLBACK_PLCB_SHORT=0.55;
            const MAX_FALLBACK_SL_BPS = 60;
            const WILSON_Z=1.34;
            const MR_ADX_MAX_DEFAULT=20;
            const MR_SLOPE_MAX_ATR50=0.50;
            const MR_BREAKOUT_DC_N=120;
            const MR_BREAKOUT_RET15_ATR=1.5;
            const MR_LOCKOUT_SEC=1800;
            const UNIV_TARGET_MIN=100, UNIV_TARGET_MAX=120;
            const DYN_QV_MIN=6_000_000;
            const DYN_QV_STEP=5_000_000;
            const STABLES=new Set(["USDT","USDC","USD","USDE","USDD","BUSD","FDUSD","TUSD","DAI","USDP","PAX","USTC","STBL"]);
            const LONG_NAUGHTY_BASES=new Set(["EDU","THE","HEMI","COOKIE","MNT","ASTER","AVNT","VANA","ETHFI","SIGN","STBL"]);
            const ALLOWED=new Set(DIRECTION==="both"? ["long","short"] : [DIRECTION]);
            const PUSH_URL=process.env.WORKER_PUSH_URL||"";
            const PUSH_TOKEN=process.env.PUSH_TOKEN||"";
            const HEALTH_URL=(()=>{ try{ const u=new URL(PUSH_URL); return `${u.origin}${u.pathname.replace(/\/signals\/push(\?.*)?$/,"/health")}`;}catch{return PUSH_URL.replace(/\/signals\/push(\?.*)?$/,"/health");}})();

            // Adapter
            async function pickMexcBase(){ for(const b of MEXC_BASES){ try{ const r=await fetchWithTimeout(`${b}/api/v3/time`,{},4000); if(r?.ok) return b; }catch{} } throw new Error("No healthy MEXC base"); }
            const BASE=await pickMexcBase();
            const api=(path,params={})=>{ const u=new URL(path,BASE); for(const [k,v] of Object.entries(params)){ if(v!==undefined&&v!==null) u.searchParams.set(k,String(v)); } return u.toString(); };
            async function fetchAll24hr(){
              let all = await getJSON(api("/api/v3/ticker/24hr"), 10000, 2);
              if(Array.isArray(all) && all.length) return all;
              const exi=await getJSON(api("/api/v3/exchangeInfo"), 10000, 2);
              const syms=(exi?.symbols||[]).filter(s=>s.status==="TRADING").map(s=>s.symbol).slice(0,300);
              const out=[]; for(let i=0;i<syms.length;i+=24){ const chunk=syms.slice(i,i+24); const got=await Promise.all(chunk.map(s=>getJSON(api("/api/v3/ticker/24hr",{symbol:s}),6000,1))); for(const x of got) if(x) out.push(x); await sleep(180); }
              return out;
            }
            async function fetchK(sym,interval,limit,startTime,endTime){ const u=api("/api/v3/klines",{symbol:sym,interval,limit,startTime,endTime}); const r=await getJSON(u,10000,2); return Array.isArray(r)?r:null; }
            async function fetchBookTicker(symbol){ return await getJSON(api("/api/v3/ticker/bookTicker",{symbol}), 8000, 1); }
            async function fetchDepth(symbol){ return await getJSON(api("/api/v3/depth",{symbol,limit:MEXC_DEPTH_LIMIT}), 10000, 2); }

            // Provenance
            async function getMexcTime(){ const j=await getJSON(api("/api/v3/time"), 8000, 2); const st=+j?.serverTime||Date.now(); return { mexc_server_time_ms: st, mexc_time_offset_ms: st - Date.now() }; }
            const run_id=new Date().toISOString()+"#6.2";
            const code_commit_sha=(process.env.GITHUB_SHA||"").slice(0,40);
            const mexcTime=await getMexcTime();
            function cfgHash(){ const cfg={ EXCHANGE, TOP_N, MAX_SPREAD_BPS, FEES_BPS, LONG_MAX_COST_BPS, MAX_COST_BPS_HARD, MR_SPREAD_MAX_BPS, EXP_LCB_MIN_BPS, EXP_LCB_MIN_BPS_FB, NOTIONAL, OBI_TOPN, MEXC_DEPTH_LIMIT, MIN_VOL_1H_USD, DEPTH_1P_MIN_USD, EMA_FAST, EMA_SLOW, ADX_P, ATR_P, VWAP_5M_WIN, TTL_MIN, TTL_MAX, TARGET_PORT_RISK_BPS, MOMENTUM_SIZE_FACTOR, NO_LONG_DOWN_ENABLE, LONG_DOWN_RSI_CUTOFF, LONG_MR_DIVERGENCE_REQ, LONG_EDGE_MULT_MIN, LONG_BOUNCE_SL_ATR, LONG_BOUNCE_TP_ATR, LONG_BOUNCE_HOLD_MIN_SEC, LONG_BOUNCE_HOLD_MAX_SEC, LONG_ENTRY_BOUNCE_OFFSET, LONG_SIMILARITY_RHO, LONG_KILL_MIN_TRADES, LONG_KILL_WINRATE, LONG_KILL_SIZE_MULT, ALWAYS3_ENABLE, ALWAYS3_SIZE_FACTOR, ALWAYS3_REQUIRE_BTC_GREEN, FALLBACK_SHORT_ADX_MIN, FALLBACK_PLCB_LONG, FALLBACK_PLCB_SHORT, MR_ADX_MAX_DEFAULT, MR_SLOPE_MAX_ATR50, MR_BREAKOUT_DC_N, MR_BREAKOUT_RET15_ATR, MR_LOCKOUT_SEC, DYN_QV_MIN, DYN_QV_STEP, STABLES:[...STABLES], LONG_NAUGHTY_BASES:[...LONG_NAUGHTY_BASES], DIRECTION }; return "sha256:"+sha256Hex(stableStringify(cfg));}
            const config_hash=cfgHash();
            const pusher_version="mexc-ultimate-6.2-prime";
            console.log("[step] start selection", { run_id, base: BASE, direction: DIRECTION, always3: ALWAYS3_ENABLE, force_size_bps: FORCE_SIZE_BPS });

            // State (lightweight, no training needed here)
            async function loadState(){
              const token=process.env.GIST_TOKEN, id=process.env.GIST_ID;
              const init={ v:"mexc-ultimate-6.2-prime", schema_version:"1.2.0", append_only:true, run:{ run_id, code_commit_sha, pusher_version, config_hash, exchange_base:BASE, ...mexcTime }, cooldown:{}, cooldown_side:{}, pending:[], equity:[], closed:[], calibration:{ platt:{}, isotonic:{}, last_fit_ts:0 }, metrics:{ global:{ ttl_n:0, closed_n:0, ttl_pct:0 }, by_key:{} }, drift:{}, sym_stats:{}, push_log:[] };
              if(!token||!id) return { state:init, persist:null };
              try{ const r=await fetchWithTimeout(`https://api.github.com/gists/${id}`,{ headers:{Authorization:`Bearer ${token}`,"Accept":"application/vnd.github+json","User-Agent":UA}}); if(!r.ok) return { state:init, persist:null }; const g=await r.json(); const c=g.files?.["state.json"]?.content; const s=c?JSON.parse(c):init; s.run={ ...(s.run||{}), run_id, code_commit_sha, pusher_version, config_hash, exchange_base:BASE, ...mexcTime }; return { state:s, persist:{id,token} }; }catch{ return { state:init, persist:null }; }
            }
            async function saveState(persist,state){
              if(!persist) return; try{ await fetchWithTimeout(`https://api.github.com/gists/${persist.id}`,{ method:"PATCH", headers:{Authorization:`Bearer ${persist.token}`,"Accept":"application/vnd.github+json","Content-Type":"application/json","User-Agent":UA}, body: JSON.stringify({ files:{ "state.json":{ content: JSON.stringify(state) } } }) }); }catch{}
            }
            const { state, persist } = await loadState();

            // Universe
            const ALL24=await fetchAll24hr();
            const QUOTES=["USDT","USDC","USD"];
            const split=(sym)=>{ for(const q of QUOTES) if(sym.endsWith(q)) return { base:sym.slice(0,-q.length), quote:q }; return null; };
            const all=[];
            for(const t of ALL24||[]){
              const sym=t.symbol||t.s; if(!sym) continue;
              const sq=split(sym); if(!sq) continue;
              if(STABLES.has(sq.base)) continue;
              const qv=+(t.quoteVolume||t.q||0); if(!isFinite(qv)||qv<=0) continue;
              all.push({ symbol:sym, base:sq.base, quote:sq.quote, qv });
            }
            all.sort((a,b)=>b.qv-a.qv);
            let dynMinQV=Math.max(DYN_QV_MIN, 1_000_000), filt=all.filter(x=>x.qv>=dynMinQV);
            while(filt.length<UNIV_TARGET_MIN && dynMinQV>1_000_000){ dynMinQV=Math.max(1_000_000, dynMinQV-DYN_QV_STEP); filt=all.filter(x=>x.qv>=dynMinQV); }
            const universe=filt.slice(0,UNIV_TARGET_MAX);
            console.log("[stats] universe", { universe: universe.length, dyn_min_qv: dynMinQV });

            // Books snapshot
            const booksRaw=await getJSON(api("/api/v3/ticker/bookTicker"),10000,2) || [];
            const bookMap=new Map(booksRaw.map(b=>[b.symbol,{ bid:+b.bidPrice, ask:+b.askPrice }]));

            // Benchmarks
            const BTC="BTCUSDT", ETH="ETHUSDT", SOL="SOLUSDT";
            const kBTC15=await fetchK(BTC,"15m",K15M), kETH15=await fetchK(ETH,"15m",K15M), kSOL15=await fetchK(SOL,"15m",K15M);
            const kBTC1H=await fetchK(BTC,"1h",K1H);
            const uptrendTF=(k,fast=EMA_FAST,slow=EMA_SLOW)=>{ if(!k?.length) return {up:false,last:null}; const c=k.map(x=>+x[4]); const emF=ema(c,fast), emS=ema(c,slow); const last=c.at(-1); return { up:(last>=emF && last>=emS), last }; };
            const btc15=uptrendTF(kBTC15), btc1h=uptrendTF(kBTC1H);
            let btcRoc15=0; try{ const c=kBTC15?.map(x=>+x[4])||[]; const prev3=c.at(-4)||c.at(-2)||c.at(-1)||0; const last=c.at(-1)||0; btcRoc15=prev3? (last/prev3 - 1) : 0; }catch{}
            const btcGreen=(btc15.up && btc1h.up && btcRoc15>0.001);
            snapCounts({ universe: universe.length });

            // Regime weights (lightweight meta)
            function regimeFeatures(k15){
              if(!k15||k15.length<ADX_P+5) return [];
              const h=k15.map(x=>+x[2]), l=k15.map(x=>+x[3]), c=k15.map(x=>+x[4]);
              const {adx}=computeADX_ATR(h,l,c,ADX_P)||{adx:0};
              const roc=(c.at(-1)/c.at(-5)-1);
              const winS=20, retW=[]; for(let i=c.length-winS;i<c.length;i++) retW.push((c[i]/c[i-1])-1);
              const bbWidth=std(retW)*Math.sqrt(winS);
              const atr=(computeADX_ATR(h,l,c,ADX_P)||{atr:1}).atr||1;
              const kelWidth=atr/c.at(-1);
              const squeeze=kelWidth>0? (bbWidth/kelWidth):1;
              return [roc, clamp((adx-10)/30,0,1), clamp((1.15-squeeze)/0.45,0,1)];
            }
            const seqFeat=[]; const rollSeq=(k)=>{ if(!k) return; for(let i=5;i<Math.min(k.length,80);i++){ const seg=k.slice(i-5,i+1); const f=regimeFeatures(seg); if(f.length) seqFeat.push(f); } };
            rollSeq(kBTC15); rollSeq(kETH15);
            const weightsReg=(()=>{ if(seqFeat.length<10) return { wTrend:0.45,wMR:0.45,wBO:0.10 }; const last=seqFeat.slice(-12), roc=mean(last.map(x=>x[0]||0)), adxN=mean(last.map(x=>x[1]||0)), sq=mean(last.map(x=>x[2]||0)); const wTrend=clamp(0.4+0.3*adxN+0.2*roc,0.2,0.7), wMR=clamp(0.6-0.3*adxN+0.1*(1-sq),0.2,0.6); const wBO=clamp(1-(wTrend+wMR),0.05,0.25); return {wTrend,wMR,wBO}; })();

            // Prefilter
            const picksRaw=[]; const pfStats={ total:0, dropped:{ cooldown:0, book:0, spread:0, k5:0, adxatr:0, atrRange:0 }, kept:0 };
            const COOLDOWN_MS=3*60*60*1000;
            const B=10;
            for(let i=0;i<universe.length;i+=B){
              const batch=await Promise.all(universe.slice(i,i+B).map(async c=>{
                try{
                  pfStats.total++;
                  const book=bookMap.get(c.symbol); if(!book?.bid||!book?.ask){ pfStats.dropped.book++; return null; }
                  const mid=(book.bid+book.ask)/2; if(!(mid>0)){ pfStats.dropped.book++; return null; }
                  const spreadBps=Math.round(((book.ask-book.bid)/mid)*10000); if(spreadBps>MAX_SPREAD_BPS){ pfStats.dropped.spread++; return null; }

                  const k5=await fetchK(c.symbol,"5m",K5M); if(!k5||k5.length<Math.max(EMA_SLOW+200,ATR_P+50)){ pfStats.dropped.k5++; return null; }
                  const k15=await fetchK(c.symbol,"15m",K15M); const k1h=await fetchK(c.symbol,"1h",K1H);

                  const c5_raw=k5.map(x=>+x[4]); 
                  const c5=kalman1D(c5_raw,{q:1e-4,r:5e-4,x0:c5_raw[0],p0:1e-2});
                  const h5=k5.map(x=>+x[2]), l5=k5.map(x=>+x[3]), v5=k5.map(x=>+x[5]);
                  const em21=emaSeries(c5,EMA_FAST), em50s=emaSeries(c5,EMA_SLOW), em200s=emaSeries(c5,200);
                  const em50=em50s?.at(-1), em200=em200s?.at(-1), em50Prev=em50s?.at(-51);
                  const { adx:adx5, atr:atr5 } = computeADX_ATR(h5,l5,c5,ADX_P)||{};
                  if(!(adx5&&atr5)){ pfStats.dropped.adxatr++; return null; }
                  const last=c5.at(-1), atr_bps=Math.round((atr5/last)*10000); if(atr_bps<4||atr_bps>260){ pfStats.dropped.atrRange++; return null; }

                  const k15c=k15?.map(x=>+x[4])||[], k1hc=k1h?.map(x=>+x[4])||[];
                  const em15f=k15c.length?ema(k15c,EMA_FAST):null, em15s=k15c.length?ema(k15c,EMA_SLOW):null;
                  const em1hf=k1hc.length?ema(k1hc,EMA_FAST):null, em1hs=k1hc.length?ema(k1hc,EMA_SLOW):null;

                  const vwap5=vwapAnchored(h5,l5,c5,v5,VWAP_5M_WIN);
                  const prev=c5.at(-2), prev3=c5.at(-4), roc5=(last/prev)-1, roc15=(last/prev3)-1;

                  const upF=last>=em21?.at(-1), upS=last>=em50, up15=(em15f&&em15s)? (last>=em15f && last>=em15s):true, up1h=(em1hf&&em1hs)? (last>=em1hf && last>=em1hs):true;
                  const z_vwap=(last-vwap5)/(atr5||1); const rsi14=rsi(c5,14);

                  const trendBias=(em50!=null && em200!=null)? (em50>em200?"long_only": em50<em200?"short_only":"both") : "both";
                  const slope_atr50=(em50!=null && em50Prev!=null)? Math.abs(em50-em50Prev)/(50*(atr5||1)) : 0;

                  const highs=h5, lows=l5; const win=MR_BREAKOUT_DC_N;
                  const dcHi=Math.max(...highs.slice(-win)), dcLo=Math.min(...lows.slice(-win));
                  const atrPct=(atr5/last), ret15abs=Math.abs((last/(c5.at(-4)||last))-1);
                  const breakout=(last>dcHi) || (last<dcLo) || (ret15abs>=MR_BREAKOUT_RET15_ATR*atrPct);
                  const mrLocked=breakout;

                  const em20s=emaSeries(c5,20), em20=em20s?.at(-1);
                  const noShortUp=((em20!=null&&em50!=null)? (em20>em50 && last>em20):false) || ((rsi14||0)>60);
                  const noLongDown= NO_LONG_DOWN_ENABLE && (((em20!=null&&em50!=null)? (em20<em50 && last<em20):false) || ((rsi14||100)<LONG_DOWN_RSI_CUTOFF));

                  const bb=(function boll(cl,win=20,k=2){ const seg=cl.slice(-win); const ma=mean(seg), s=std(seg)||1e-6; return { up:ma+k*s, dn:ma-k*s, z:(cl.at(-1)-ma)/s }; })(c5,20,2);
                  const rsiPrev3=rsi(c5.slice(0,-2),14), rsiPrev5=rsi(c5.slice(0,-4),14);
                  const rsiLowerHigh=(rsiPrev5!=null && rsiPrev3!=null && rsi14!=null)? (rsiPrev3>rsiPrev5 && rsi14<rsiPrev3):false;
                  const rsiHigherLow=(rsiPrev5!=null && rsiPrev3!=null && rsi14!=null)? (rsiPrev3<rsiPrev5 && rsi14>rsiPrev3):false;
                  const obvNeg=(function obv(close,vol){ let obv=0; for(let i=1;i<close.length;i++){ const d=close[i]-close[i-1]; if(d>0) obv+=vol[i]; else if(d<0) obv-=vol[i]; } const prev=(()=>{ let o=0; for(let i=1;i<Math.max(2,close.length-10);i++){ const d=close[i]-close[i-1]; if(d>0) o+=vol[i]; else if(d<0) o-=vol[i]; } return o; })(); return (obv-prev)<0; })(c5,v5);
                  const obvPos=!obvNeg;

                  const fadeShortDivergenceOK=((bb.up!=null && last>bb.up) && rsiLowerHigh) || ((bb.z||0)>2 && obvNeg);
                  const fadeLongDivergenceOK_raw=((bb.dn!=null && last<bb.dn) && rsiHigherLow) || ((bb.z||0)<-2 && obvPos);
                  const fadeLongDivergenceOK = LONG_MR_DIVERGENCE_REQ ? fadeLongDivergenceOK_raw : true;

                  const adxF=clamp((adx5-16)/14,0,1), s1=tanh(roc5/0.0030), s2=tanh(roc15/0.0065);
                  const sideTrend=(0.6*roc5+0.4*roc15)>=0?"long":"short";
                  const trendAlign=(sideTrend==="long" && upF&&upS&&up15&&up1h) || (sideTrend==="short" && !upF&&!upS&&(!up15||!up1h));
                  let pTrend = clamp(0.5 + 0.27*(0.6*s1+0.4*s2)*(trendAlign?1.0:0.7)*adxF, 0.32, 0.93);

                  const sideMR=z_vwap>0?"short":"long";
                  const sMR=tanh(Math.abs(z_vwap))*Math.sign(-z_vwap);
                  const rsiEdge=(rsi14!=null)? (rsi14-50)/50 : 0;
                  let pMR = clamp(0.5 + 0.23*(0.7*sMR + 0.3*(-rsiEdge))*(1-adxF), 0.35, 0.90);

                  const boUp=(last>dcHi), boDn=(last<dcLo);
                  let boBase=(boUp||boDn?1.0:0.35)*(0.6+0.4*adxF);
                  { const winS=20, retW=[]; for(let i=c5.length-winS;i<c5.length;i++) retW.push((c5[i]/c5[i-1])-1); const bbWidth=std(retW)*Math.sqrt(winS); const kelWidth=(atr5/last); const sqRatio=kelWidth>0? (bbWidth/kelWidth):1; const sqScore=clamp((1.15-sqRatio)/0.45,0,1); boBase*=(1+0.4*sqScore); }
                  const sideBO= boUp?"long": boDn?"short": ((0.6*roc5+0.4*roc15)>=0?"long":"short");
                  let pBO = clamp(0.5 + 0.29*(boBase*(sideBO==="long"?1:-1)), 0.35, 0.96);

                  const wT=0.45, wM=0.45, wB=0.10;
                  const pLong0=clamp(wT*(sideTrend==="long"?pTrend:1-pTrend)+ wM*(sideMR==="long"?pMR:1-pMR)+ wB*(sideBO==="long"?pBO:1-pBO),0.30,0.97);
                  const pShort0=clamp(wT*(sideTrend==="short"?pTrend:1-pTrend)+ wM*(sideMR==="short"?pMR:1-pMR)+ wB*(sideBO==="short"?pBO:1-pBO),0.30,0.97);

                  const vol1h_est_usd=c.qv/24;

                  return { c, k5, k15, c5, h5, l5, v5, adx5, atr_bps:atr_bps, spreadBps,
                    pLong0, pShort0, upF, upS, up15, up1h, z_vwap, rsi14, trendAlign, em20, em50, em200, slope_atr50, dcHi, dcLo, breakout, mrLocked,
                    noShortUp, noLongDown, fadeShortDivergenceOK, fadeLongDivergenceOK,
                    vol1h_est_usd, trendBias };
                }catch{ return null; }
              }));
              for(const x of batch) if(x){ picksRaw.push(x); pfStats.kept++; }
            }
            console.log("[stats] prefilter", pfStats);
            snapCounts({ pre: picksRaw.length });

            // Refine with depth
            const refined=[];
            for(let idx=0; idx<picksRaw.length; idx++){
              try{
                const p=picksRaw[idx], c=p.c;
                const book=bookMap.get(c.symbol); if(!book?.bid||!book?.ask) continue;
                const mid=(book.bid+book.ask)/2;

                const depth=await fetchDepth(c.symbol);
                let obi=0, slipL=p.spreadBps/2, slipS=p.spreadBps/2, fillL=0, fillS=0, depth1pUSD=0;
                if(depth?.asks?.length && depth?.bids?.length){
                  const computeOBI=(depth, topN=12)=>{
                    const w=(i)=>Math.exp(-i*0.18); let bidNot=0, askNot=0;
                    for(let i=0;i<Math.min(topN, depth.bids.length); i++){ const p=+depth.bids[i][0], q=+depth.bids[i][1]; if(p>0&&q>0) bidNot += p*q*w(i); }
                    for(let i=0;i<Math.min(topN, depth.asks.length); i++){ const p=+depth.asks[i][0], q=+depth.asks[i][1]; if(p>0&&q>0) askNot += p*q*w(i); }
                    return (bidNot+askNot>0) ? (bidNot-askNot)/(bidNot+askNot) : 0;
                  };
                  const vwapFillLevels=(levels,targetUSD)=>{ let remain=targetUSD,val=0,qty=0; for(const [ps,qs] of levels){ const p=+ps, q=+qs; if(!(p>0&&q>0)) continue; const can=p*q, take=Math.min(remain,can), tq=take/p; val+=p*tq; qty+=tq; remain-=take; if(remain<=1e-6) break; } return { px: qty>0? val/qty : null, filledUSD: (targetUSD-remain) }; };
                  obi = computeOBI(depth, OBI_TOPN);
                  const buy=vwapFillLevels(depth.asks, Math.max(50,NOTIONAL)), sell=vwapFillLevels(depth.bids, Math.max(50,NOTIONAL));
                  slipL= buy.px? Math.max(0, Math.round((buy.px-mid)/mid*10000)) : slipL;
                  slipS= sell.px? Math.max(0, Math.round((mid-sell.px)/mid*10000)) : slipS;
                  fillL=Math.min(1, buy.filledUSD/Math.max(1,NOTIONAL));
                  fillS=Math.min(1, sell.filledUSD/Math.max(1,NOTIONAL));
                  const depthWithinPctUSD=(depth, mid, pct=0.01)=>{ const askLim=mid*(1+pct), bidLim=mid*(1-pct); let asksUSD=0, bidsUSD=0; for(const [ps,qs] of depth.asks){ const p=+ps, q=+qs; if(!(p>0&&q>0)) continue; if(p<=askLim) asksUSD += p*q; else break; } for(const [ps,qs] of depth.bids){ const p=+ps, q=+qs; if(!(p>0&&q>0)) continue; if(p>=bidLim) bidsUSD += p*q; else break; } return { bidsUSD, asksUSD }; };
                  const d1=depthWithinPctUSD(depth, mid, 0.01);
                  depth1pUSD = (d1.asksUSD||0)+(d1.bidsUSD||0);
                }

                const envAllowed=(dir)=>ALLOWED.has(dir);
                const shortAllowedByTrend=!p.noShortUp;
                const coinUpMultiTF=(p.up15 && p.up1h);
                const coinNotNaughty = !LONG_NAUGHTY_BASES.has(c.base.toUpperCase());

                const costLong=FEES_BPS + Math.max(Math.round(p.spreadBps/2), slipL);
                const costShort=FEES_BPS + Math.max(Math.round(p.spreadBps/2), slipS);
                if(Math.max(costLong,costShort)>MAX_COST_BPS_HARD) continue;
                if(p.vol1h_est_usd < MIN_VOL_1H_USD) continue;
                if(depth1pUSD < DEPTH_1P_MIN_USD) continue;

                const allowedShort = envAllowed("short") && (p.trendBias!=="long_only") && shortAllowedByTrend;
                let allowedLong = envAllowed("long") && (p.trendBias!=="short_only") && coinUpMultiTF && coinNotNaughty && (costLong <= LONG_MAX_COST_BPS) && !p.noLongDown;

                const pLong_raw = p.pLong0;
                const pShort_raw = p.pShort0;
                const strongTrend=(p.adx5>Math.max(22,MR_ADX_MAX_DEFAULT)) || (p.slope_atr50>MR_SLOPE_MAX_ATR50);
                const regime = p.mrLocked ? "trend" : (strongTrend? "trend":"meanrevert");
                const pLong = pLong_raw;
                const pShort = pShort_raw;

                const pLong_lcb=wilsonLCB(pLong,80,WILSON_Z), pShort_lcb=wilsonLCB(pShort,80,WILSON_Z);

                const yR=[]; for(let i=1;i<p.c5.length;i++) yR.push(Math.log(p.c5[i]/p.c5[i-1]));
                const mu5=mean(yR)||0, sig5=Math.max(1e-4,std(yR));
                const entryMid=mid;
                const hold_base=clamp(Math.round((weightsReg.wTrend > weightsReg.wMR ? 720:560)+240*clamp((p.adx5-16)/14,0,1)), TTL_MIN, TTL_MAX);
                const stepsBase=Math.max(1,Math.round(hold_base/300));

                const allowMR=(side)=>{
                  if(side==="long" && !allowedLong) return false;
                  if(side==="short" && !allowedShort) return false;
                  if(!(p.spreadBps<=MR_SPREAD_MAX_BPS)) return false;
                  if(p.mrLocked) return false;
                  if(!(p.adx5<=MR_ADX_MAX_DEFAULT && p.slope_atr50<=MR_SLOPE_MAX_ATR50)) return false;
                  return true;
                };

                let candLong=null;
                if(allowedLong){
                  const mrOk = allowMR("long") && (LONG_MR_DIVERGENCE_REQ ? p.fadeLongDivergenceOK : true);
                  const styleL = mrOk ? "mr" : (strongTrend ? "momentum":"trend");
                  let holdL = mrOk ? clamp(Math.round(Math.max(1800, hold_base)), 1200, 3600) : clamp(Math.round(Math.max(LONG_BOUNCE_HOLD_MIN_SEC, Math.min(hold_base, LONG_BOUNCE_HOLD_MAX_SEC))), LONG_BOUNCE_HOLD_MIN_SEC, LONG_BOUNCE_HOLD_MAX_SEC);
                  let slL, tpL;
                  if(styleL==="mr"){ slL=Math.round(LONG_BOUNCE_SL_ATR*p.atr_bps); tpL=Math.round(LONG_BOUNCE_TP_ATR*p.atr_bps); }
                  else { slL=Math.round(clamp(p.atr_bps*0.50, Math.round(0.35*p.atr_bps), Math.round(0.65*p.atr_bps)));
                         tpL=Math.round(clamp(p.atr_bps*0.95, Math.round(0.60*p.atr_bps), Math.round(1.20*p.atr_bps))); }
                  const simL=pathEVHeavy({entry:entryMid,tp_bps:tpL,sl_bps:slL,side:"long",retSeries:yR,mu:mu5,sigma:sig5,steps:stepsBase,N:192,cost_bps:costLong,t_df:5,boot_block:3});
                  const evLongLCB=Math.round(pLong_lcb*tpL - (1-pLong_lcb)*slL - costLong);
                  if(tpL>=LONG_EDGE_MULT_MIN*costLong && evLongLCB>=EXP_LCB_MIN_BPS){ candLong={ side:"long", p_lcb:pLong_lcb, p_raw:pLong_raw, cost_bps:costLong, tp_bps:tpL, sl_bps:slL, exp_lcb_bps:evLongLCB, exp_bps:simL.ev_bps, hold_sec:holdL, style:styleL, regime, fill_prob:+fillL.toFixed(2) }; }
                }

                let candShort=null;
                if(allowedShort){
                  const mrOk = allowMR("short") && p.fadeShortDivergenceOK;
                  const styleS = mrOk ? "mr" : (strongTrend ? "momentum":"trend");
                  const holdS = mrOk ? clamp(Math.round(Math.max(1800, hold_base)), 1200, 3600) : hold_base;
                  let slS, tpS;
                  if(styleS==="mr"){ const sl=Math.round(clamp(0.5,0.4,0.6)*p.atr_bps), tp=Math.round(clamp(1.0,0.8,1.2)*p.atr_bps); slS=sl; tpS=tp; }
                  else { slS=Math.round(clamp(p.atr_bps*0.55, Math.round(0.35*p.atr_bps), Math.round(0.75*p.atr_bps)));
                         tpS=Math.round(clamp(p.atr_bps*1.00, Math.round(0.70*p.atr_bps), Math.round(1.40*p.atr_bps))); }
                  const simS=pathEVHeavy({entry:entryMid,tp_bps:tpS,sl_bps:slS,side:"short",retSeries:yR,mu:mu5,sigma:sig5,steps:stepsBase,N:192,cost_bps:costShort,t_df:5,boot_block:3});
                  const evShortLCB=Math.round(pShort_lcb*tpS - (1-pShort_lcb)*slS - costShort);
                  if(tpS>=Math.max(3,3)*costShort && evShortLCB>=EXP_LCB_MIN_BPS){ candShort={ side:"short", p_lcb:pShort_lcb, p_raw:pShort_raw, cost_bps:costShort, tp_bps:tpS, sl_bps:slS, exp_lcb_bps:evShortLCB, exp_bps:simS.ev_bps, hold_sec:holdS, style:styleS, regime, fill_prob:+fillS.toFixed(2) }; }
                }

                let chosen=candLong&&candShort? (candLong.exp_lcb_bps>=candShort.exp_lcb_bps? candLong : candShort) : (candLong||candShort||null);
                if(!chosen) continue;

                const liq=1; // simplified
                const score=clamp(Math.round(60 + 30*(chosen.p_lcb-0.5)*2 + 12*clamp((p.adx5-16)/14,0,1) - Math.min(12, Math.max(0,(p.spreadBps-5)/2))), 1, 99);

                refined.push({
                  symbol:c.symbol, base:c.base, quote:c.quote, qv:c.qv,
                  side:chosen.side, p_lcb:+chosen.p_lcb.toFixed(3), p_raw:+chosen.p_raw.toFixed(3),
                  p_win:+(Math.max(p.pLong0,p.pShort0)).toFixed(3),
                  exp_bps:chosen.exp_bps, exp_lcb_bps:chosen.exp_lcb_bps,
                  tp_bps:chosen.tp_bps, sl_bps:chosen.sl_bps, rrr:+(chosen.tp_bps/Math.max(1,chosen.sl_bps)).toFixed(2),
                  spread_bps:p.spreadBps, cost_bps:chosen.cost_bps,
                  adx:+(p.adx5||0).toFixed(1), atr_bps:p.atr_bps, regime:chosen.regime, style:chosen.style,
                  score, n_conf:Math.round(60+40*clamp((p.adx5-16)/14,0,1)), obi:+obi.toFixed(3),
                  hold_sec:chosen.hold_sec, liq_pct:+liq.toFixed(3),
                  ret5:(()=>{ const r=[]; for(let i=1;i<p.c5.length;i++) r.push(Math.log(p.c5[i]/p.c5[i-1])); return r.slice(-36); })(),
                  fill_prob: chosen.fill_prob,
                  dyn_floor: Math.max(EXP_LCB_MIN_BPS, 8 + Math.max(0,12-(p.spreadBps||0))/2),
                  rsi14:p.rsi14, z_vwap:p.z_vwap,
                  vol1h_est_usd:p.vol1h_est_usd, depth1p_usd:depth1pUSD,
                  direction_env: DIRECTION, side_bias:p.trendBias,
                  entry_book: { bid: book.bid, ask: book.ask },
                  slip_bps_long: slipL, slip_bps_short: slipS,
                  spread_bps_entry: p.spreadBps
                });
              }catch(e){ console.log("[warn] refine", e?.message||e); }
            }
            refined.sort((a,b)=> b.exp_lcb_bps - a.exp_lcb_bps || b.exp_bps - a.exp_bps || b.score - a.score || (b.qv||0)-(a.qv||0));
            snapCounts({ refined: refined.length });
            console.log("[stats] refined", { refined: refined.length });

            // Strict selection
            const strictOk=(cand)=>{
              const common = cand.p_lcb>=0.60
                && cand.exp_lcb_bps>=Math.max(cand.dyn_floor, EXP_LCB_MIN_BPS)
                && (cand.fill_prob||0)>=0.65
                && cand.spread_bps<=MAX_SPREAD_BPS;
              if(!common) return false;
              if(cand.side==="long"){ if(cand.cost_bps>LONG_MAX_COST_BPS) return false; if(cand.tp_bps < LONG_EDGE_MULT_MIN*cand.cost_bps) return false; }
              else { if(cand.cost_bps>Math.max(FEES_BPS+8,18)) return false; }
              return true;
            };
            const TARGET_K=Math.min(3, TOP_N);
            const selected=[];
            for(const cand of refined){
              if(selected.length>=TARGET_K) break;
              if(!strictOk(cand)) continue;
              let ok=true; for(const s of selected){ const r=corr(cand.ret5||[],s.ret5||[]); if(cand.side==="long" && s.side==="long" && r>LONG_SIMILARITY_RHO) { ok=false; break; } if(r>0.90){ ok=false; break; } }
              if(ok) selected.push(cand);
            }
            console.log("[stats] strict", { strict_selected: selected.length, target: TARGET_K });

            // Fallback top-up (ALWAYS3_ENABLE=true)
            const fallbackAdded=[];
            const fbDrop={ tf:0, cost:0, plcblow:0, edge:0, naughty:0, spread:0, sim:0, shortADX:0 };
            const fbConsidered = []; // candidates that passed fallback gates (pre-correlation)
            if(ALWAYS3_ENABLE && selected.length < TARGET_K){
              const have=new Set(selected.map(s=>s.symbol));
              const tryAdd= async (candList)=>{
                for(const cand of candList){
                  if(selected.length>=TARGET_K) break;
                  if(have.has(cand.symbol)) continue;
                  
                  // Per-key kill switch (placeholder for future implementation)
                  // const key = `${cand.side}_${cand.regime}`;
                  // if(state.metrics?.by_key?.[key]?.n > 60 && state.metrics.by_key[key].auc < 0.5) continue;
                  
                  if(cand.side==="long"){
                    const btcOK = ALWAYS3_REQUIRE_BTC_GREEN ? btcGreen : true;
                    if(!btcOK || !(cand.fill_prob||0)>=0.55){ fbDrop.tf++; continue; }
                    if(LONG_NAUGHTY_BASES.has(cand.base.toUpperCase())){ fbDrop.naughty++; continue; }
                    if(cand.spread_bps>MAX_SPREAD_BPS){ fbDrop.spread++; continue; }
                    if(cand.cost_bps>LONG_MAX_COST_BPS){ fbDrop.cost++; continue; }
                    if(!(cand.p_lcb>=FALLBACK_PLCB_LONG)){ fbDrop.plcblow++; continue; }
                    if(!(cand.exp_lcb_bps>=EXP_LCB_MIN_BPS_FB)){ fbDrop.edge++; continue; }
                  }else{
                    if(cand.adx < FALLBACK_SHORT_ADX_MIN){ fbDrop.shortADX++; continue; }
                    if(!(cand.p_lcb>=FALLBACK_PLCB_SHORT)){ fbDrop.plcblow++; continue; }
                    if(!(cand.exp_lcb_bps>=EXP_LCB_MIN_BPS_FB)){ fbDrop.edge++; continue; }
                  }
                  
                  fbConsidered.push({
                    symbol: cand.symbol,
                    side: cand.side,
                    p_lcb: cand.p_lcb,
                    ev: cand.exp_lcb_bps,
                    score: cand.score ?? 0,
                    adx: cand.adx,
                    atr_bps: cand.atr_bps
                  });

                  let ok=true; for(const s of selected){ const r=corr(cand.ret5||[],s.ret5||[]); if((cand.side === "long" && s.side === "long" && r > LONG_SIMILARITY_RHO) || r > 0.90) { ok = false; break; } }
                  if(!ok){ fbDrop.sim++; continue; }

                  selected.push({ ...cand, mp_fill:true, tier:"fallback" });
                  fallbackAdded.push(cand.symbol);
                  have.add(cand.symbol);
                }
              };

              if (refined.length === 0) {
                let fbCands = [];
                for (const p of picksRaw) {
                  try {
                    const book = bookMap.get(p.c.symbol);
                    if (!book?.bid || !book?.ask) continue;
                    const costL = FEES_BPS + Math.max(0, Math.round(p.spreadBps/2));
                    const costS = FEES_BPS + Math.max(0, Math.round(p.spreadBps/2));
                    if (Math.max(costL, costS) > MAX_COST_BPS_HARD) continue;
                    
                    const pLong_lcb = wilsonLCB(p.pLong0, 80, WILSON_Z);
                    const pShort_lcb= wilsonLCB(p.pShort0,80, WILSON_Z);
                    
                    const strongTrend = (p.adx5 > 22) || (p.slope_atr50 > MR_SLOPE_MAX_ATR50);
                    const regime = p.mrLocked ? "trend" : (strongTrend ? "trend" : "meanrevert");
                    const style = regime === "meanrevert" ? "mr" : (strongTrend ? "momentum" : "trend");
                    const atr = Math.max(4, Math.min(260, p.atr_bps||0));

                    if (ALLOWED.has("long")) {
                      let slL = Math.min(Math.round(Math.max(0.5*atr, 0.35*atr)), MAX_FALLBACK_SL_BPS);
                      const tpL = Math.round(Math.max(0.9*atr, 0.6*atr));
                      const evL = Math.round(pLong_lcb*tpL - (1-pLong_lcb)*slL - costL);
                      
                      const btcOK = ALWAYS3_REQUIRE_BTC_GREEN ? (btcGreen===true) : true;
                      const allowedLong = btcOK && p.up15 && p.up1h && !p.noLongDown && !LONG_NAUGHTY_BASES.has(p.c.base.toUpperCase()) && p.vol1h_est_usd >= MIN_VOL_1H_USD && costL <= LONG_MAX_COST_BPS;
                      const mrOk = !p.mrLocked && p.fadeLongDivergenceOK && p.adx5 <= MR_ADX_MAX_DEFAULT && p.slope_atr50 <= MR_SLOPE_MAX_ATR50 && p.spreadBps <= MR_SPREAD_MAX_BPS;
                      
                      if (allowedLong && (regime!=="meanrevert" || mrOk) && pLong_lcb>=FALLBACK_PLCB_LONG && evL>=EXP_LCB_MIN_BPS_FB) {
                        fbCands.push({
                          symbol:p.c.symbol, base:p.c.base, quote:p.c.quote, qv:p.c.qv, side:"long", p_lcb:+pLong_lcb.toFixed(3), p_raw:+p.pLong0.toFixed(3),
                          exp_bps:0, exp_lcb_bps:evL, tp_bps:tpL, sl_bps:slL, rrr:+(tpL/Math.max(1,slL)).toFixed(2),
                          spread_bps:p.spreadBps, cost_bps:costL, adx:+(p.adx5||0).toFixed(1), atr_bps:atr, regime, style,
                          score: 60, n_conf:60, obi: p.obi||0, hold_sec:720, liq_pct: p.liq_pct || 0,
                          ret5:(()=>{ const r=[]; for(let i=1;i<p.c5.length;i++) r.push(Math.log(p.c5[i]/p.c5[i-1])); return r.slice(-36); })(), fill_prob:0.7, dyn_floor:EXP_LCB_MIN_BPS_FB,
                          rsi14:p.rsi14, z_vwap:p.z_vwap, vol1h_est_usd:p.vol1h_est_usd, depth1p_usd:0,
                          direction_env:DIRECTION, side_bias:p.trendBias, entry_book:{ bid:book.bid, ask:book.ask }, slip_bps_long:Math.round(p.spreadBps/2), slip_bps_short:Math.round(p.spreadBps/2), spread_bps_entry:p.spreadBps
                        });
                      }
                    }
                    if (ALLOWED.has("short")) {
                      let slS = Math.min(Math.round(0.55*atr), MAX_FALLBACK_SL_BPS);
                      const tpS = Math.round(1.0*atr);
                      const evS = Math.round(pShort_lcb*tpS - (1-pShort_lcb)*slS - costS);
                      if (p.adx5>=FALLBACK_SHORT_ADX_MIN && p.spreadBps<=MAX_SPREAD_BPS && pShort_lcb>=FALLBACK_PLCB_SHORT && evS>=EXP_LCB_MIN_BPS_FB) {
                        fbCands.push({
                          symbol:p.c.symbol, base:p.c.base, quote:p.c.quote, qv:p.c.qv, side:"short", p_lcb:+pShort_lcb.toFixed(3), p_raw:+p.pShort0.toFixed(3),
                          exp_bps:0, exp_lcb_bps:evS, tp_bps:tpS, sl_bps:slS, rrr:+(tpS/Math.max(1,slS)).toFixed(2),
                          spread_bps:p.spreadBps, cost_bps:costS, adx:+(p.adx5||0).toFixed(1), atr_bps:atr, regime, style,
                          score: 60, n_conf:60, obi: p.obi||0, hold_sec:720, liq_pct: p.liq_pct || 0,
                          ret5:(()=>{ const r=[]; for(let i=1;i<p.c5.length;i++) r.push(Math.log(p.c5[i]/p.c5[i-1])); return r.slice(-36); })(), fill_prob:0.7, dyn_floor:EXP_LCB_MIN_BPS_FB,
                          rsi14:p.rsi14, z_vwap:p.z_vwap, vol1h_est_usd:p.vol1h_est_usd, depth1p_usd:0,
                          direction_env:DIRECTION, side_bias:p.trendBias, entry_book:{ bid:book.bid, ask:book.ask }, slip_bps_long:Math.round(p.spreadBps/2), slip_bps_short:Math.round(p.spreadBps/2), spread_bps_entry:p.spreadBps
                        });
                      }
                    }
                  } catch {}
                }
                fbCands.sort((a,b)=> b.exp_lcb_bps - a.exp_lcb_bps || b.rrr - a.rrr || (b.qv||0)-(a.qv||0));
                
                // TODO: Depth check for top 4-6 fbCands before tryAdd
                await tryAdd(fbCands);
              }
              
              if (refined.length > 0) await tryAdd(refined);
              
              const fbTop5 = [...fbConsidered].sort((a,b) => b.ev - a.ev || b.score - a.score).slice(0,5);
              const fbMinScorePass = fbConsidered.length ? Math.min(...fbConsidered.map(x => x.score ?? 0)) : null;
              console.log("[log] fallback.top5_considered", { top5: fbTop5, min_score_pass: fbMinScorePass, considered: fbConsidered.length, pushed: fallbackAdded.length, drops: fbDrop });
            }
            console.log("[stats] final selection", { selected: selected.length });
            
            snapCounts({ selected: selected.length });

            // Assemble picks
            const wEv=softmax(selected.map(x=>x.exp_lcb_bps),20);
            let picks = selected.map((x,i)=>{
              const bk=bookMap.get(x.symbol); const mid=(bk?.bid && bk?.ask)? ((+bk.bid + +bk.ask)/2) : null;
              const slF=x.sl_bps/10000, tpF=x.tp_bps/10000;
              let entry_limit=null, tp_abs=null, sl_abs=null, entry_policy="limit_at_old_sl";
              if(mid!=null){
                if(x.side==="long"){
                  const baseline = mid*(1 - Math.max(0.001, slF*0.5));
                  entry_limit = baseline;
                  tp_abs = entry_limit*(1 + tpF);
                  sl_abs = entry_limit*(1 - slF);
                  entry_policy="smart_limit";
                }else{
                  entry_limit = mid*(1 + slF);
                  tp_abs = entry_limit*(1 - tpF);
                  sl_abs = entry_limit*(1 + slF);
                }
              }
              const ttl=clamp(Math.round((x.hold_sec||720)+i*12), TTL_MIN, TTL_MAX);

              // Sizing
              let size_bps=0;
              if(FORCE_SIZE_BPS>0) size_bps=Math.round(FORCE_SIZE_BPS);
              else{
                const base = x.sl_bps>0? Math.min(220, Math.round((wEv[i]*TARGET_PORT_RISK_BPS/x.sl_bps)*100)) : 0;
                size_bps = Math.round(base * ((x.style==="momentum")? clamp(MOMENTUM_SIZE_FACTOR,0.25,0.6):1.0));
              }
              if(x.mp_fill) size_bps = Math.round(size_bps * ALWAYS3_SIZE_FACTOR);

              // TODO: Implement per-key kill switch based on state.metrics
              try{
                const last200=(state.closed||[]).slice(-200);
                const longs=last200.filter(r=>r.side==="long");
                const n=longs.length, wins=longs.filter(r=>(r.pnl_bps||0)>0).length, pnlSum=sum(longs.map(r=>r.pnl_bps||0));
                const wr = n>0? wins/n : 1;
                const killActive=(n>=LONG_KILL_MIN_TRADES)&&((wr<LONG_KILL_WINRATE)|| (pnlSum<0));
                if(killActive && x.side==="long") size_bps=Math.max(4, Math.round(size_bps*LONG_KILL_SIZE_MULT));
              }catch{}

              const exec_policy = { exec:"maker_or_strict_limit", max_slip_bps:3, prefer_post_only: (x.spread_bps||99)<=6 && (x.depth1p_usd||0)>=DEPTH_1P_MIN_USD };
              const entry_ts_ms = Date.now(); const ttl_ts_ms = entry_ts_ms + ttl*1000;
              return { symbol:x.base, symbol_full:x.symbol, quote:x.quote,
                side:x.side, rank:i+1, ttl_sec:ttl, p_win:x.p_win, p_lcb:x.p_lcb, p_raw:x.p_raw, calib_key:`${x.side}_${String(x.regime).includes("mean")?"mr":"trend"}`,
                tp_bps:x.tp_bps, sl_bps:x.sl_bps, rrr:+(x.tp_bps/Math.max(1,x.sl_bps)).toFixed(2),
                exp_lcb_bps:x.exp_lcb_bps, ev_bps:x.exp_bps,
                spread_bps:x.spread_bps, cost_bps:x.cost_bps, adx:x.adx, atr_bps:x.atr_bps, n_conf:x.n_conf, obi:x.obi||0,
                regime:x.regime, style:x.style, liq_pct:x.liq_pct, fill_prob:x.fill_prob||0.5,
                entry_policy, entry_type:"limit", activation:"on_fill", entry_mid:mid, entry_limit, tp_abs, sl_abs,
                size_bps, tier:(x.mp_fill?"fallback":"strict"), mp_fill:!!x.mp_fill,
                gp_feat:[ clamp((x.adx-16)/14,0,1), clamp(x.side==="long"? (x.z_vwap??0) : -(x.z_vwap??0), -3,3), x.side==="long"? ((x.rsi14??50)/100) : ((100-(x.rsi14??50))/100), 0.0, 0.0 ],
                ret5:x.ret5, direction_env:x.direction_env, side_bias:x.side_bias,
                vol1h_est_usd:x.vol1h_est_usd, depth1p_usd:x.depth1p_usd||0, exec:exec_policy,
                mgmt:{ be_at_r:0.6, partial_take_at_r:0.7, partial_take_pct:0.4, trail_atr_mult:0.5 },
                trade_id: `${x.symbol}:${entry_ts_ms}`, entry_ts_ms, ttl_ts_ms,
                entry_book: x.entry_book, spread_bps_entry: x.spread_bps_entry, slip_bps_entry: x.side==="long" ? (x.slip_bps_long??null) : (x.slip_bps_short??null),
                depth1p_entry_usd: x.depth1p_usd, obi_entry:x.obi||0,
                notional_usd: NOTIONAL, size_bps,
                run_id: run_id, code_commit_sha: code_commit_sha, pusher_version: pusher_version,
                config_hash: config_hash, exchange_base: BASE,
                mexc_server_time_ms: mexcTime.mexc_server_time_ms, mexc_time_offset_ms: mexcTime.mexc_time_offset_ms,
                p_model:{ gp_hash:"lite", calib_type:"mixed", calib_n:0 }, calib_type:"raw", calib_n:0,
                events: [{ ts_ms: entry_ts_ms, type:"selected", meta:{ tier: (x.mp_fill?"fallback":"strict"), score: x.score } }]
              };
            });

            // Cap fallback risk to 25%
            try{
              const fb=picks.filter(p=>p.mp_fill);
              const fbRisk=fb.reduce((a,p)=> a + (p.size_bps||0)*Math.max(1,p.sl_bps||1), 0);
              const cap = 0.25 * TARGET_PORT_RISK_BPS * 100;
              if(fbRisk > cap && fbRisk>0){
                const scale = cap/fbRisk;
                for (const p of fb) p.size_bps = Math.max(0, Math.round(p.size_bps * scale));
              }
            }catch{}

            // VaR/ES throttle
            try{
              const varStats=portfolioVaR_ES_tCopula(picks, 6);
              const ES_LIMIT=-220;
              if(varStats.ES95_bps < ES_LIMIT){
                const scale=clamp(ES_LIMIT/Math.min(-1e-6, varStats.ES95_bps), 0.35,1);
                picks=picks.map(p=>({...p, size_bps: Math.round(p.size_bps*scale)}));
                console.log("[step] var/es throttle", { ...varStats, scale });
              }else{
                console.log("[ok] var/es", varStats);
              }
            }catch(e){ console.log("[warn] var/es", e?.message||e); }

            // Persist state
            try{
              const nowMs=Date.now();
              state.last_ts=new Date().toISOString();
              await saveState(persist,state);
              console.log("[ok] state saved", { pending: state.pending.length, closed: (state.closed||[]).length });
            }catch(e){ console.log("[warn] state save", e?.message||e); }

            // POST
            const meta={
              exchange:"mexc", exchange_base:BASE,
              counts:{ universe:universe.length, refined:refined.length, selected:picks.length },
              tier:(ALWAYS3_ENABLE?"strict_plus_fallback":"strict"),
              run:{ run_id, code_commit_sha, pusher_version, config_hash, exchange_base:BASE, ...mexcTime }
            };
            const payload={ ts:new Date().toISOString(), mode:"normal", source:"external_pusher", meta:{ origin:"github_actions", ...meta }, top_n:picks.length||0, ideas:picks||[] };
            console.log(`[step] pushing ${picks.length} ideas to ${PUSH_URL}`);
            try{
              const r=await fetchWithTimeout(PUSH_URL,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":`Bearer ${PUSH_TOKEN}` }, body: JSON.stringify(payload) },15000);
              let txt=""; try{ txt=await r.text(); }catch{} console.log("[ok] push status", r?.status||"ERR", (txt||"").slice(0,300));
            }catch(e){ console.log("[warn] push failed", e?.message||e); }

          })();
          NODE

          EXIT_CODE=$?
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo "[gha] section-2 node failed ($EXIT_CODE); sending minimal payload"
            if [[ -n "${WORKER_PUSH_URL:-}" ]]; then
              if [[ -f /tmp/pusher_counts.json ]]; then counts=$(cat /tmp/pusher_counts.json); else counts='{}'; fi
              now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
              payload='{"ts":"'"$now"'","mode":"normal","source":"external_pusher","meta":{"origin":"github_actions","reason":"section2_error","counts":'"$counts"'},"top_n":0,"ideas":[]}'
              curl -sS -o /tmp/push_resp.txt -w "%{http_code}" -X POST \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer ${PUSH_TOKEN}" \
                --data "${payload}" \
                --max-time 12 \
                "${WORKER_PUSH_URL}" || true
            fi
            exit 0
          fi
