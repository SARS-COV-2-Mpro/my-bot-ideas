name: Ideas Pusher (MEXC Ultimate 7.7.7)

on:
  workflow_dispatch:
  schedule:
    - cron: "*/25 * * * *" # runs every 25 minutes

permissions:
  contents: read

concurrency:
  group: ideas-mexc-ultimate
  cancel-in-progress: true

jobs:
  push:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    env:
      # Required secrets
      WORKER_PUSH_URL: ${{ secrets.WORKER_PUSH_URL }}
      PUSH_TOKEN: ${{ secrets.PUSH_TOKEN }}
      WORKER_PUSH_URL_V2: ${{ secrets.WORKER_PUSH_URL_V2 }}

      # Required for trade reconciliation
      MEXC_API_KEY: ${{ secrets.MEXC_API_KEY }}
      MEXC_SECRET_KEY: ${{ secrets.MEXC_SECRET_KEY }}

      # Optional (safe defaults inside the script)
      GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
      GIST_ID: ${{ secrets.GIST_ID }}

      # Exchange + tuning knobs (via Repo/Org Variables)
      EXCHANGE: mexc
      MIN_QV_USD: ${{ vars.MIN_QV_USD }}
      TOP_N: ${{ vars.TOP_N }}
      MAX_SPREAD_BPS: ${{ vars.MAX_SPREAD_BPS }}
      EXP_LCB_MIN_BPS: ${{ vars.EXP_LCB_MIN_BPS }}
      FEES_BPS: ${{ vars.FEES_BPS }}
      NOTIONAL_USD: ${{ vars.NOTIONAL_USD }}
      MEXC_DEPTH_LIMIT: ${{ vars.MEXC_DEPTH_LIMIT }}
      OBI_TOPN: ${{ vars.OBI_TOPN }}
      ACTIVE_UTC_START: ${{ vars.ACTIVE_UTC_START }}
      ACTIVE_UTC_END: ${{ vars.ACTIVE_UTC_END }}
      MEXC_BASE: ${{ vars.MEXC_BASE }}
      FORCE_SIZE_BPS: ${{ vars.FORCE_SIZE_BPS }}

      # New Confidence Model Knobs
      DIRECTION: ${{ vars.DIRECTION }}
      MR_SLOPE_MAX_ATR50: ${{ vars.MR_SLOPE_MAX_ATR50 }}
      MR_BREAKOUT_DC_N: ${{ vars.MR_BREAKOUT_DC_N }}
      MR_BREAKOUT_RET15_ATR: ${{ vars.MR_BREAKOUT_RET15_ATR }}
      MR_LOCKOUT_SEC: ${{ vars.MR_LOCKOUT_SEC }}
      MAX_COST_BPS_HARD: ${{ vars.MAX_COST_BPS_HARD }}
      MIN_VOL_1H_USD: ${{ vars.MIN_VOL_1H_USD }}
      DEPTH_1P_MIN_USD: ${{ vars.DEPTH_1P_MIN_USD }}
      NO_LONG_DOWN_ENABLE: ${{ vars.NO_LONG_DOWN_ENABLE }}
      LONG_DOWN_RSI_CUTOFF: ${{ vars.LONG_DOWN_RSI_CUTOFF }}
      LONG_MR_DIVERGENCE_REQ: ${{ vars.LONG_MR_DIVERGENCE_REQ }}
      LONG_EDGE_MULT_MIN: ${{ vars.LONG_EDGE_MULT_MIN }}
      LONG_BOUNCE_SL_ATR: ${{ vars.LONG_BOUNCE_SL_ATR }}
      LONG_BOUNCE_TP_ATR: ${{ vars.LONG_BOUNCE_TP_ATR }}
      LONG_SIMILARITY_RHO: ${{ vars.LONG_SIMILARITY_RHO }}

      # New (MTF + Provenance + Align)
      MIN_TF_ALIGN: ${{ vars.MIN_TF_ALIGN }} # default handled in script
      TF_WEIGHTS: ${{ vars.TF_WEIGHTS }}     # e.g. {"1m":0.1,"5m":0.3,"15m":0.25,"1h":0.2,"4h":0.15}
      STRATEGY_NAME: ${{ vars.STRATEGY_NAME }}
      MODEL_VERSION: ${{ vars.MODEL_VERSION }}
      SCHEMA_VERSION: ${{ vars.SCHEMA_VERSION }}
      GIT_SHA: ${{ github.sha }}

    steps:
      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Run pusher (strict pre-clean + plan + push)
        shell: bash
        run: |
          set -euo pipefail

          # Hard fail on misconfig to maintain guarantees
          for k in WORKER_PUSH_URL PUSH_TOKEN GIST_TOKEN GIST_ID MEXC_API_KEY MEXC_SECRET_KEY; do
            if [[ -z "${!k:-}" ]]; then
              echo "[gha] FATAL: Missing required env $k"
              exit 1
            fi
          done

          set +e
          node - <<'NODE'
          (async ()=>{
          'use strict';
          const crypto = require('crypto');

          // ---------------- Utils ----------------
          const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
          const tanh=(x)=>Math.tanh(x);
          const sum=(a)=>a.reduce((x,y)=>x+y,0);
          const mean=(a)=>a.length?sum(a)/a.length:0;
          const std=(a)=>{ const m=mean(a); let v=0; for(const x of a) v+=(x-m)*(x-m); return a.length>1?Math.sqrt(v/(a.length-1)):0; };
          const ema=(arr,p)=>{ if(!arr||arr.length<p) return null; const k=2/(p+1); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; for(let i=p;i<arr.length;i++) e=arr[i]*k+e*(1-k); return e; };
          const rsi=(cl,p=14)=>{ if(!cl||cl.length<=p) return null; let g=0,l=0; for(let i=1;i<=p;i++){ const d=cl[i]-cl[i-1]; g+=Math.max(0,d); l+=Math.max(0,-d); } let ag=g/p, al=l/p; for(let i=p+1;i<cl.length;i++){ const d=cl[i]-cl[i-1]; ag=(ag*(p-1)+Math.max(0,d))/p; al=(al*(p-1)+Math.max(0,-d))/p; } const rs=al===0?100:ag/al; return 100-100/(1+rs); };
          const computeADX_ATR=(h,l,c,p=14)=>{ const n=c.length; if(n<p+2) return null; const TR=[],plusDM=[],minusDM=[]; for(let i=1;i<n;i++){ const up=h[i]-h[i-1], down=l[i-1]-l[i]; plusDM.push((up>down&&up>0)?up:0); minusDM.push((down>up&&down>0)?down:0); TR.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1]))); } let trN=0,pdmN=0,ndmN=0; for(let i=0;i<p;i++){ trN+=TR[i]; pdmN+=plusDM[i]; ndmN+=minusDM[i]; } let pDI=100*(pdmN/(trN||1)), nDI=100*(ndmN/(trN||1)); let dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1), adx=dx; for(let i=p;i<TR.length;i++){ trN=trN-(trN/p)+TR[i]; pdmN=pdmN-(pdmN/p)+plusDM[i]; ndmN=ndmN-(ndmN/p)+minusDM[i]; pDI=100*(pdmN/(trN||1)); nDI=100*(ndmN/(trN||1)); dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1); adx=((adx*(p-1))+dx)/p; } const atr=trN/p; return { adx, atr }; };
          const vwapAnchored=(h,l,c,v,win)=>{ if(!c?.length) return null; const n=c.length,s=Math.max(0,n-win); let pv=0,vv=0; for(let i=s;i<n;i++){ const tp=(h[i]+l[i]+c[i])/3; const vol=+v[i]||0; pv+=tp*vol; vv+=vol; } return vv>0?pv/vv:c.at(-1); };
          const corr=(a,b)=>{ const n=Math.min(a?.length||0,b?.length||0); if(n<5) return 0; const as=a.slice(-n), bs=b.slice(-n); const ma=mean(as), mb=mean(bs); let num=0,da=0,db=0; for(let i=0;i<n;i++){ const xa=as[i]-ma, xb=bs[i]-mb; num+=xa*xb; da+=xa*xa; db+=xb*xb; } const den=Math.sqrt(da*db)||1; return num/den; };
          const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
          const log=(...a)=>console.log("[gha]",...a);

          // ---------------- HTTP + Concurrency ----------------
          const UA="gh-actions-ideas-mexc-ultimate/strict-clean (+https://github.com/)";
          async function fetchWithTimeout(url, opts={}, ms=15000) {
            const ac=new AbortController(); const t=setTimeout(()=>ac.abort(),ms);
            try { return await fetch(url,{...opts,signal:ac.signal,headers:{"User-Agent":UA,...(opts.headers||{})}}); }
            finally { clearTimeout(t); }
          }
          async function getJSON(url,ms=12000,tries=2){ for(let a=0;a<tries;a++){ try{ const r=await fetchWithTimeout(url,{},ms); if(r?.ok) return await r.json(); }catch{} await sleep(200); } return null; }

          // ---------------- Config / ENV ----------------
          const PUSH_URL = process.env.WORKER_PUSH_URL || "";
          const PUSH_TOKEN = process.env.PUSH_TOKEN || "";
          const PUSH_URL_V2 = process.env.WORKER_PUSH_URL_V2 || "";
          const GIST_ID = process.env.GIST_ID || "";
          const GIST_TOKEN = process.env.GIST_TOKEN || "";
          const MEXC_API_KEY = process.env.MEXC_API_KEY || "";
          const MEXC_SECRET_KEY = process.env.MEXC_SECRET_KEY || "";
          const MEXC_BASES=[process.env.MEXC_BASE,"https://api.mexc.com","https://www.mexc.com"].filter(Boolean);
          const NOTIONAL = Number(process.env.NOTIONAL_USD || "300");
          const COST_BPS = Number(process.env.FEES_BPS || "10");
          const OBI_TOPN = Number(process.env.OBI_TOPN || "12");
          const DEPTH_LIMIT = Number(process.env.MEXC_DEPTH_LIMIT || "50");
          const MIN_VOL_1H_USD = Number(process.env.MIN_VOL_1H_USD || "5000000");
          const DEPTH_1P_MIN_USD = Number(process.env.DEPTH_1P_MIN_USD || "200000");
          const DIRECTION=(process.env.DIRECTION||"both").trim().toLowerCase();
          const LONG_EDGE_MULT_MIN=Number(process.env.LONG_EDGE_MULT_MIN||"4");
          const LONG_BOUNCE_SL_ATR=Number(process.env.LONG_BOUNCE_SL_ATR||"0.50");
          const LONG_BOUNCE_TP_ATR=Number(process.env.LONG_BOUNCE_TP_ATR||"0.90");
          const MAX_SPREAD_BPS = Number(process.env.MAX_SPREAD_BPS || "12");
          const EXP_LCB_MIN_BPS_BASE=Number(process.env.EXP_LCB_MIN_BPS||"12");
          const MIN_TF_ALIGN=(Number(process.env.MIN_TF_ALIGN||"0.60"));
          let TF_WEIGHTS={}; try{ TF_WEIGHTS=JSON.parse(process.env.TF_WEIGHTS||"{}"); }catch{ TF_WEIGHTS={}; }
          const STRATEGY_NAME=(process.env.STRATEGY_NAME||"mexc-ultimate");
          const MODEL_VERSION=(process.env.MODEL_VERSION||"6.4");
          const SCHEMA_VERSION=(process.env.SCHEMA_VERSION||"1");
          const GIT_SHA=(process.env.GIT_SHA||"unknown");
          const TOP_N=Number(process.env.TOP_N||"3");
          const TARGET_PORT_RISK_BPS=52;
          const TTL_MIN=540, TTL_MAX=1200;

          // ---------------- MEXC Adapter ----------------
          async function pickMexcBase(){
            for(const b of MEXC_BASES){ try{ const r=await fetchWithTimeout(`${b}/api/v3/time`,{},6000); if(r?.ok) return b; }catch{} }
            throw new Error("No healthy MEXC base");
          }
          const BASE=await pickMexcBase();
          const api=(path,params={})=>{
            const u=new URL(path,BASE);
            for(const [k,v] of Object.entries(params)) if(v!==undefined&&v!==null) u.searchParams.set(k,String(v));
            return u.toString();
          };
          async function mexcSignedRequest(path, params = {}, method = 'GET') {
            const timestamp = Date.now();
            const queryString = new URLSearchParams({ ...params, timestamp }).toString();
            const signature = crypto.createHmac('sha256', MEXC_SECRET_KEY).update(queryString).digest('hex');
            const url = new URL(path, BASE);
            url.search = queryString + `&signature=${signature}`;
            const options = { method, headers: { 'X-MEXC-APIKEY': MEXC_API_KEY, 'Content-Type': 'application/json', 'User-Agent': UA } };
            try {
              const r = await fetchWithTimeout(url.toString(), options, 15000);
              if (r.ok) return await r.json();
              log(`MEXC req failed ${r.status}`, (await r.text().catch(()=>''))?.slice(0,120));
            } catch(e){ log("MEXC req error", e?.message||e); }
            return null;
          }
          async function fetchOpenOrders(symbol){ return await mexcSignedRequest('/api/v3/openOrders', symbol?{symbol}:{}) || []; }
          async function fetchAll24hr(){ let all=await getJSON(api("/api/v3/ticker/24hr"),12000,2); if(Array.isArray(all)&&all.length) return all; return []; }
          async function fetchK(sym,interval,limit,startTime,endTime){ const u=api("/api/v3/klines",{symbol:sym,interval,limit,startTime,endTime}); const r=await getJSON(u,12000,2); return Array.isArray(r)?r:null; }
          async function fetchBookTicker(symbol){ return await getJSON(api("/api/v3/ticker/bookTicker",{symbol}), 8000, 1); }
          async function fetchDepth(symbol){ return await getJSON(api("/api/v3/depth",{symbol,limit:DEPTH_LIMIT}), 12000, 2); }

          // ---------------- State (Gist) + Strict IO ----------------
          async function getGistState() {
            const r = await fetchWithTimeout(`https://api.github.com/gists/${GIST_ID}`, {
              headers:{Authorization:`Bearer ${GIST_TOKEN}`,"Accept":"application/vnd.github+json","User-Agent":UA}
            }, 15000);
            if(!r.ok) throw new Error(`Gist GET ${r.status}`);
            const g=await r.json();
            const content=g.files?.["state.json"]?.content;
            const s=content? JSON.parse(content) : {};
            return s;
          }
          async function putGistState(newState) {
            const r = await fetchWithTimeout(`https://api.github.com/gists/${GIST_ID}`, {
              method:"PATCH",
              headers:{Authorization:`Bearer ${GIST_TOKEN}`,"Accept":"application/vnd.github+json","Content-Type":"application/json","User-Agent":UA},
              body: JSON.stringify({ files: { "state.json": { content: JSON.stringify(newState) } } })
            }, 20000);
            if(!r.ok){
              const body = await r.text().catch(()=> "");
              throw new Error(`Gist PATCH ${r.status} ${body.slice(0,200)}`);
            }
          }
          const idOf = (p)=> String(p?.client_order_id || p?.clientOrderId || p?.idea_id || "").trim();
          function mergeStates(remote, local) {
            const merged = { ...remote };
            const dropSet = new Set((local.__drop_pending_cids || []).map(x => String(x).trim()).filter(Boolean));

            // pending: remote truth minus drops, plus truly new local
            const remotePending = (remote.pending || []).filter(p => !dropSet.has(idOf(p)));
            const ids = new Set(remotePending.map(idOf));
            const newLocals = (local.pending || []).filter(p => {
              const k=idOf(p); return k && !ids.has(k);
            });
            merged.pending = [...remotePending, ...newLocals];

            // closed: keep remote; overlay learned flags if present locally
            const keyClosed = (c) => {
              const cid = c?.trade_details?.client_order_id || c.client_order_id || c.idea_id || "";
              const tx  = c?.ts_exit_ms || c?.exit_ts_ms || "";
              return `${cid}|${tx}`;
            };
            const localClosedMap = new Map((local.closed || []).map(c => [keyClosed(c), c]));
            merged.closed = (remote.closed || []).map(rc => {
              const lc = localClosedMap.get(keyClosed(rc));
              if (!lc) return rc;
              const learned = Boolean(rc.learned || lc.learned);
              const learned_at_ts = learned ? (rc.learned_at_ts || lc.learned_at_ts || Date.now()) : undefined;
              return { ...rc, learned, learned_at_ts };
            });

            // keep worker-owned stats
            merged.equity = Array.isArray(remote.equity) ? remote.equity : [];
            merged.sym_stats_real = remote.sym_stats_real || {};
            merged.sym_stats = remote.sym_stats || {};
            merged.lastReconcileTs = remote.lastReconcileTs || 0;
            if("fees" in remote) merged.fees = remote.fees;

            // pusher-owned
            merged.cooldown = local.cooldown || {};
            merged.cooldown_side = local.cooldown_side || {};
            merged.mr_lockout = local.mr_lockout || {};
            merged.calibCoeffs = local.calibCoeffs || remote.calibCoeffs || {};

            merged.version_ts = Date.now();
            return merged;
          }
          async function saveStateStrict(local) {
            // Always fetch, merge with dropSet, patch, then re-verify
            const remote1 = await getGistState();
            const toSave = mergeStates(remote1, local);
            await putGistState(toSave);
            const remote2 = await getGistState();

            // verify drops are gone
            const dropSet = new Set((local.__drop_pending_cids || []).map(x => String(x).trim()).filter(Boolean));
            const still = (remote2.pending || []).filter(p => dropSet.has(idOf(p)));
            if (still.length) {
              log("WARN: drop verify failed; retrying once", still.length);
              const retrySave = mergeStates(remote2, local);
              await putGistState(retrySave);
              const remote3 = await getGistState();
              const still2 = (remote3.pending || []).filter(p => dropSet.has(idOf(p)));
              if (still2.length) throw new Error(`Drop verify failed; still present=${still2.length}`);
              return remote3;
            }
            return remote2;
          }

          // ---------------- State Cleanup ----------------
          const DROPPABLE_STATUSES = new Set(["planned","placed","pending","queued","ready"]);
          async function cleanupPendingBeforePlanning(state, heartbeat) {
            // fetch open orders once
            let openAll = [];
            try { openAll = await fetchOpenOrders(); } catch(e){ log("openOrders err", e?.message||e); }
            const byClient = new Map((openAll || []).map(o => [String(o.clientOrderId || o.clientOrderID || "").trim(), o]));
            const zombieSet = new Set((heartbeat?.details || [])
              .filter(d => d.type === "zombie")
              .map(d => String(d.client_order_id || "").trim())
              .filter(Boolean)
            );

            const keep = [];
            const dropCIDs = [];
            let scanned=0, droppable=0, orphans=0;

            for (const p of (state.pending || [])) {
              scanned++;
              const cid = idOf(p);
              const status = (p.status || "planned").toLowerCase();
              const noEntryYet = !p.entry_ts_ms;
              const onEx = cid && byClient.has(cid);
              const orphan = !onEx || zombieSet.has(cid);
              const canDrop = DROPPABLE_STATUSES.has(status) && noEntryYet;

              if (canDrop) droppable++;
              if (canDrop && orphan) { orphans++; dropCIDs.push(cid || p.idea_id || ""); continue; }
              keep.push(p);
            }

            if (dropCIDs.length) {
              state.pending = keep;
              state.__drop_pending_cids = [...new Set([...(state.__drop_pending_cids || []), ...dropCIDs])];
              log(`cleanup: scanned=${scanned} droppable=${droppable} orphans=${orphans} dropped=${dropCIDs.length}`);
            } else {
              log(`cleanup: scanned=${scanned} droppable=${droppable} orphans=${orphans} dropped=0`);
            }
            return { dropped: dropCIDs.length, dropCIDs, scanned, droppable, orphans };
          }

          // ---------------- Main ----------------
          (async () => {
            log("gist_id", GIST_ID.slice(0,8));

            // Health ping (optional)
            try {
              const hu = (()=>{ try{ const u=new URL(PUSH_URL); return `${u.origin}${u.pathname.replace(/\/signals\/push(\?.*)?$/,"/health")}`;}catch{return PUSH_URL.replace(/\/signals\/push(\?.*)?$/,"/health");}})();
              const hr = await fetchWithTimeout(hu, { headers: { "Authorization":"Bearer "+PUSH_TOKEN }}, 6000);
              log("health", hu, hr?.status||"ERR");
            } catch(e){ log("health error", e?.message||e); }

            // 1) Load + strict cleanup + save/verify
            const state0 = await getGistState();
            state0.__drop_pending_cids = state0.__drop_pending_cids || [];
            const heartbeat = await (async()=>{ // lightweight, only for zombie ids
              const res={ mismatches:0, zombies:0, details:[] };
              try{
                const openAll=await fetchOpenOrders();
                const byClient=new Map((openAll||[]).map(o=>[String(o.clientOrderId||o.clientOrderID||"").trim(),o]));
                for(const p of (state0.pending||[])){
                  const cid=String(p.client_order_id||p.clientOrderId||"").trim();
                  if(!cid) continue;
                  if(!byClient.has(cid)){ res.zombies++; res.details.push({type:"zombie",client_order_id:cid}); }
                }
                res.mismatches=res.zombies;
              }catch(e){ log("heartbeat warn", e?.message||e); }
              return res;
            })();

            const cleaned = await cleanupPendingBeforePlanning(state0, heartbeat);
            let stateAfterClean = state0;
            if (cleaned.dropped > 0) {
              const remoteAfter = await saveStateStrict(state0);
              stateAfterClean = remoteAfter;
              log("cleanup persisted; pending now=", (remoteAfter.pending||[]).length);
            } else {
              log("cleanup: nothing to persist");
            }

            // 2) Build and select ideas (condensed strategy logic)
            // Universe
            const ALL24 = await fetchAll24hr();
            const QUOTES=["USDT","USDC","USD"];
            const STABLES=new Set(["USDT","USDC","USD","USDE","USDD","BUSD","FDUSD","TUSD","DRKUSD","DAI","USDP","PAX","USTC"]);
            const split=(sym)=>{ for(const q of QUOTES) if(sym.endsWith(q)) return { base:sym.slice(0,-q.length), quote:q }; return null; };
            const all=[]; for(const t of ALL24||[]){ const sym=t.symbol||t.s; if(!sym) continue; const sq=split(sym); if(!sq) continue; if(STABLES.has(sq.base)) continue; const qv=+(t.quoteVolume||t.q||0); if(!(qv>0)) continue; all.push({ symbol:sym, base:sq.base, quote:sq.quote, qv }); }
            all.sort((a,b)=>b.qv-a.qv);
            const universe=all.slice(0,120);

            const booksRaw=await getJSON(api("/api/v3/ticker/bookTicker"),10000,2) || [];
            const bookMap=new Map(booksRaw.map(b=>[b.symbol,{ bid:+b.bidPrice, ask:+b.askPrice }]));

            // Candidate scan
            const prelim=[];
            for(const c of universe){
              try{
                const lastTs=stateAfterClean.cooldown?.[c.base]||0;
                if(lastTs && (Date.now()-lastTs)<3*60*60*1000) continue;
                const bk = bookMap.get(c.symbol) || await fetchBookTicker(c.symbol);
                const bid=+bk?.bidPrice||+bk?.bid||0, ask=+bk?.askPrice||+bk?.ask||0;
                if(!(bid>0&&ask>0)) continue;
                const mid=(bid+ask)/2, spreadBps=Math.round(((ask-bid)/mid)*10000);
                const k5=await fetchK(c.symbol,"5m",120);
                if(!k5 || k5.length<60) continue;
                const c5=k5.map(x=>+x[4]), h5=k5.map(x=>+x[2]), l5=k5.map(x=>+x[3]), v5=k5.map(x=>+x[5]);
                const adxatr=computeADX_ATR(h5,l5,c5,14)||{};
                const atr_bps=Math.round(((adxatr.atr||0)/(c5.at(-1)||1))*10000);
                if(atr_bps<4||atr_bps>260) continue;
                const vwap5=vwapAnchored(h5,l5,c5,v5,36);
                const last=c5.at(-1), roc1=(last/(c5.at(-2)||last))-1, roc3=(last/(c5.at(-4)||last))-1;
                const z_vwap=(last-vwap5)/((adxatr.atr||1));
                const rsi14=rsi(c5,14)||50;
                const adx5=adxatr.adx||0;
                const adxF=clamp((adx5-16)/14,0,1);
                const pTrend=clamp(0.5+0.27*(0.6*tanh(roc1/0.003)+0.4*tanh(roc3/0.0065))*adxF,0.32,0.93);
                const pMR=clamp(0.5+0.23*(0.7*tanh(Math.abs(z_vwap))*Math.sign(-z_vwap)+0.3*(-(rsi14-50)/50))*(1-adxF),0.35,0.90);
                const pLong0=clamp(0.45*pTrend+0.55*pMR,0.3,0.97);
                const pShort0=clamp(0.45*(1-pTrend)+0.55*(1-pMR),0.3,0.97);
                prelim.push({ c, mid, spreadBps, atr_bps, pLong0, pShort0 });
              }catch{}
            }

            prelim.sort((a,b)=>{
              const aW=Math.max(a.pLong0||0,a.pShort0||0), bW=Math.max(b.pLong0||0,b.pShort0||0);
              const aS=0.6*aW + 0.3*clamp((a.atr_bps-8)/40,0,1) - 0.1*Math.max(0,(a.spreadBps-6)/12);
              const bS=0.6*bW + 0.3*clamp((b.atr_bps-8)/40,0,1) - 0.1*Math.max(0,(b.spreadBps-6)/12);
              return bS-aS;
            });
            const shortlist = prelim.slice(0, 30);

            // Refine shortlist
            const refined=[];
            for (const p of shortlist) {
              try{
                const depth=await fetchDepth(p.c.symbol);
                if(!depth?.bids?.length || !depth?.asks?.length) continue;
                const slipHalf=Math.round(p.spreadBps/2);
                const costLong=COST_BPS + slipHalf, costShort=COST_BPS + slipHalf;
                const tpL=Math.round(LONG_BOUNCE_TP_ATR*p.atr_bps);
                const slL=Math.round(LONG_BOUNCE_SL_ATR*p.atr_bps);
                const expL = Math.round(p.pLong0*tpL - (1-p.pLong0)*slL - costLong);
                const tpS=Math.round(1.0*p.atr_bps);
                const slS=Math.round(0.5*p.atr_bps);
                const expS = Math.round(p.pShort0*tpS - (1-p.pShort0)*slS - costShort);

                let side, tp_bps, sl_bps, p_lcb, ev_bps, cost_bps;
                if (DIRECTION==="long") { side="long"; tp_bps=tpL; sl_bps=slL; p_lcb=p.pLong0; ev_bps=expL; cost_bps=costLong; }
                else if (DIRECTION==="short") { side="short"; tp_bps=tpS; sl_bps=slS; p_lcb=p.pShort0; ev_bps=expS; cost_bps=costShort; }
                else {
                  if (expL >= expS) { side="long"; tp_bps=tpL; sl_bps=slL; p_lcb=p.pLong0; ev_bps=expL; cost_bps=costLong; }
                  else { side="short"; tp_bps=tpS; sl_bps=slS; p_lcb=p.pShort0; ev_bps=expS; cost_bps=costShort; }
                }
                const confBase = Math.round(100*(0.6*p_lcb + 0.4*clamp(ev_bps/Math.max(8, p.atr_bps), -2, 2)));
                const gSpread = clamp(1 - Math.max(0,(p.spreadBps - MAX_SPREAD_BPS))/MAX_SPREAD_BPS, 0.2, 1.1);
                const conf = Math.round(confBase * gSpread);
                refined.push({
                  symbol:p.c.symbol, base:p.c.base, quote:p.c.quote,
                  side, tp_bps, sl_bps, p_lcb:+p_lcb.toFixed(3), ev_bps,
                  atr_bps:p.atr_bps, spread_bps:p.spreadBps, cost_bps,
                  hold_sec: clamp(1200, TTL_MIN, TTL_MAX), confidence: conf
                });
              }catch(e){ log("refine warn", e?.message||e); }
            }

            refined.sort((a,b)=>b.confidence-a.confidence);
            const selected = refined.slice(0, Math.max(1, TOP_N));

            // Build picks
            const uuidv4=()=>{ try{ return crypto.randomUUID(); }catch{ const b=crypto.randomBytes(16); b[6]=(b[6]&0x0f)|0x40; b[8]=(b[8]&0x3f)|0x80; const h=b.toString("hex"); return [h.slice(0,8),h.slice(8,12),h.slice(12,16),h.slice(16,20),h.slice(20)].join("-"); } };
            const mkClientOrderId = (prefix="mxu") => { const raw = (crypto.randomUUID ? crypto.randomUUID() : uuidv4()).replace(/-/g, ""); const base = (prefix + "_" + raw).replace(/[^A-Za-z0-9_-]/g, "").slice(0, 30); return base.padEnd(Math.max(24, base.length), "0"); };
            const picksV2 = selected.map((x,i)=>{
              const bk = bookMap.get(x.symbol);
              const mid = (bk?.bid && bk?.ask) ? ((+bk.bid + +bk.ask)/2) : null;
              let entry_limit=null,tp_abs=null,sl_abs=null;
              if (mid != null) {
                const slF=x.sl_bps/10000, tpF=x.tp_bps/10000;
                if (x.side==="long"){ entry_limit = mid*(1 - Math.max(0.001, slF*0.5)); tp_abs = entry_limit*(1+tpF); sl_abs = entry_limit*(1-slF); }
                else { entry_limit = mid*(1 + Math.max(0.001, slF*0.5)); tp_abs = entry_limit*(1-tpF); sl_abs = entry_limit*(1+slF); }
              }
              const idea_id=uuidv4(); const client_order_id=mkClientOrderId("mxu");
              const ttl = clamp(Math.round((x.hold_sec||720)+i*12), TTL_MIN, TTL_MAX);
              const size_bps = (x.sl_bps>0? Math.min(220, Math.round((TARGET_PORT_RISK_BPS/x.sl_bps)*100)) : 0);
              return {
                idea_id, client_order_id, symbol: x.base, symbol_full: x.symbol, quote: x.quote, side:x.side, rank:i+1,
                target_exchange: "bybit_futures_testnet", market_type:"futures", margin_mode:"isolated", leverage:1,
                entry_policy: "maker_join", exec: { exec: "post_only" },
                entry_mid: mid, entry_limit, tp_abs, sl_abs,
                tp_bps:x.tp_bps, sl_bps:x.sl_bps, rrr:+(x.tp_bps/Math.max(1,x.sl_bps)).toFixed(2),
                exp_lcb_bps:x.ev_bps, ev_bps:x.ev_bps, cost_bps:x.cost_bps,
                p_win:x.p_lcb, p_lcb:x.p_lcb, p_raw:x.p_lcb, calib_key:`side:${x.side}|regime:meanrevert`,
                regime:"meanrevert", ttl_sec: ttl, size_bps,
                predicted:{ ts_ms:Date.now(), p_cal:x.p_lcb, ev_bps:x.ev_bps, confidence_score:x.confidence },
                confidence: x.confidence, reasons:[], reasons_text:[]
              };
            });
            const toV1Compat = (pv2)=>({
              idea_id: pv2.idea_id, client_order_id: pv2.client_order_id, symbol: pv2.symbol, symbol_full: pv2.symbol_full, quote: pv2.quote, side: pv2.side, rank: pv2.rank,
              entry_policy: "smart_swing_limit", entry_type:"limit", activation:"on_fill",
              entry_mid: pv2.entry_mid, entry_limit: pv2.entry_limit, tp_abs: pv2.tp_abs, sl_abs: pv2.sl_abs,
              tp_bps: pv2.tp_bps, sl_bps: pv2.sl_bps, rrr: pv2.rrr, exp_lcb_bps: pv2.exp_lcb_bps, ev_bps: pv2.ev_bps, cost_bps: pv2.cost_bps,
              p_win: pv2.p_lcb, p_lcb: pv2.p_lcb, p_raw: pv2.p_raw, calib_key: pv2.calib_key, regime: pv2.regime, ttl_sec: pv2.ttl_sec, size_bps: pv2.size_bps,
              predicted: { ...pv2.predicted, meta: { strategy: STRATEGY_NAME, model_version: MODEL_VERSION, schema_version: SCHEMA_VERSION, git_sha: GIT_SHA, futures_hint: { target_exchange: pv2.target_exchange, market_type: pv2.market_type, margin_mode: pv2.margin_mode, leverage: pv2.leverage, entry_policy_override: pv2.entry_policy, exec: pv2.exec } } },
              confidence: pv2.confidence, reasons: pv2.reasons, reasons_text: pv2.reasons_text
            });
            let picks = picksV2.map(toV1Compat);

            // 3) Append to state, persist, then push
            try{
              const nowMs = Date.now();
              const ideasTs = new Date(nowMs).toISOString();
              for (const p of picks) {
                stateAfterClean.cooldown = stateAfterClean.cooldown || {}; stateAfterClean.cooldown[p.symbol] = nowMs;
                stateAfterClean.cooldown_side = stateAfterClean.cooldown_side || {}; stateAfterClean.cooldown_side[p.symbol] = { side: p.side, ts_ms: nowMs };
                stateAfterClean.pending = stateAfterClean.pending || [];
                stateAfterClean.pending.push({
                  ts: ideasTs, ts_ms: nowMs, ttl_ts_ms: nowMs + p.ttl_sec*1000,
                  symbolFull: p.symbol_full, base: p.symbol, quote: p.quote, side: p.side,
                  entry_limit: p.entry_limit, tp_abs: p.tp_abs, sl_abs: p.sl_abs,
                  hold_sec: p.ttl_sec, tp_bps: p.tp_bps, sl_bps: p.sl_bps, cost_bps: p.cost_bps, tier: "confidence",
                  p_lcb: p.p_lcb, p_raw: p.p_raw, calib_key: p.calib_key, predicted: p.predicted, regime: p.regime,
                  decision_context: { tfs:["1m","5m","15m","1h","4h"], mtf_weights: TF_WEIGHTS },
                  notional_usd: NOTIONAL, size_bps: p.size_bps,
                  idea_id: p.idea_id, client_order_id: p.client_order_id, trend5m: null,
                  status: "planned", entry_ts_ms: null, entry_price: null, qty: null
                });
              }
              if ((stateAfterClean.pending||[]).length > 550) stateAfterClean.pending = stateAfterClean.pending.slice(-550);
              log("Appended", picks.length, "plans. New pending length=", (stateAfterClean.pending||[]).length);
            }catch(e){ log("append warn", e?.message||e); }

            const afterAppend = await saveStateStrict(stateAfterClean);
            log("Persisted after append. pending=", (afterAppend.pending||[]).length);

            // Push
            const payload = { ts:new Date().toISOString(), mode:"normal", source:"external_pusher",
              meta:{ origin:"github_actions", strategy:STRATEGY_NAME, model_version:MODEL_VERSION, schema_version:SCHEMA_VERSION, git_sha:GIT_SHA },
              top_n:picks.length, ideas:picks };
            log(`pushing ${picks.length} ideas to ${PUSH_URL}`);
            const r = await fetchWithTimeout(PUSH_URL, {
              method:"POST", headers:{ "Content-Type":"application/json", "Authorization":"Bearer "+PUSH_TOKEN }, body: JSON.stringify(payload)
            }, 20000);
            const txt = await r.text().catch(()=> "");
            log("push status", r?.status||"ERR", txt.slice(0,300));
            if (PUSH_URL_V2) {
              const r2 = await fetchWithTimeout(PUSH_URL_V2, {
                method:"POST", headers:{ "Content-Type":"application/json", "Authorization":"Bearer "+PUSH_TOKEN },
                body: JSON.stringify({ ts:new Date().toISOString(), mode:"normal", source:"external_pusher", meta:{origin:"github_actions_v2"}, top_n:picksV2.length, ideas:picksV2 })
              }, 20000);
              const txt2 = await r2.text().catch(()=> "");
              log("push v2 status", r2?.status||"ERR", txt2.slice(0,300));
            }

          })().catch(e=>{ console.error("[gha] FATAL", e?.message||e); process.exit(1); });
          })();
          NODE

          EXIT_CODE=$?

          # Shell-level fallback (in case node crashed before posting)
          set -e
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo "[gha] pusher exited with code $EXIT_CODE â€” sending minimal payload so tail shows a [push] line"
            raw_push_url="$(printf '%s' "${WORKER_PUSH_URL}" | tr -d '\r\n')"
            health_url="$(printf '%s' "${raw_push_url}" | sed -E 's#/signals/push(\?.*)?$#/health#')"
            echo "[gha] fallback health GET ${health_url}"
            http_code_h=$(curl -g -sS -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${PUSH_TOKEN}" --max-time 8 "${health_url}" || true)
            echo "[gha] fallback health status ${http_code_h}"
            now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            payload='{"ts":"'"${now}"'","mode":"normal","source":"external_pusher","meta":{"origin":"github_actions","reason":"fallback_node_error"},"top_n":0,"ideas":[]}'
            echo "[gha] pushing 0 ideas to ${raw_push_url}"
            mkdir -p /tmp
            : > /tmp/push_resp.txt
            http_code=$(curl -g -sS -o /tmp/push_resp.txt -w "%{http_code}" -X POST -H "Content-Type: application/json" -H "Authorization: Bearer ${PUSH_TOKEN}" --data-raw "${payload}" --max-time 12 "${raw_push_url}" || true)
            body="$(head -c 400 /tmp/push_resp.txt || true)"
            echo "[gha] push status ${http_code} ${body}"
            exit 0
          fi
