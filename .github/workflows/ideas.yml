name: Send Trade Ideas ELITE (multi-expert, microstructure, auto-RRR, EV LCB, 3h cooldown)

on:
  schedule:
    - cron: "*/10 * * * *"
  workflow_dispatch: {}

jobs:
  push-ideas:
    runs-on: [self-hosted, Windows, X64]
    timeout-minutes: 15
    concurrency:
      group: send-trade-ideas-elite
      cancel-in-progress: true

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Push Ideas (ELITE)
        # Use Git Bash on Windows to avoid PowerShell execution policy
        shell: bash
        env:
          # Required
          WORKER_PUSH_URL: ${{ secrets.WORKER_PUSH_URL }}
          PUSH_TOKEN: ${{ secrets.PUSH_TOKEN }}

          # Force Binance.com (no .us fallback)
          BINANCE_BASE: https://api1.binance.com

          # Recommended (plain digits)
          FEES_BPS: 12
          NOTIONAL_USD: 150
          MIN_QV_USD: 25000000
          TOP_N: 10
          MAX_SPREAD_BPS: 15
          EXP_LCB_MIN_BPS: 3

          # Optional state for DD throttle + pending eval
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          GIST_ID: ${{ secrets.GIST_ID }}
        run: |
          set -euo pipefail
          echo "[gha] Node version: $(node -v)"
          echo "[gha] Writing script..."
          cat > push-ideas.js <<'JS'
          (async ()=>{
            // ---------- Utils ----------
            const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
            const tanh=(x)=>Math.tanh(x);
            const ema=(arr,p)=>{ if(arr.length<p) return null; const k=2/(p+1); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; for(let i=p;i<arr.length;i++) e=arr[i]*k+e*(1-k); return e; };
            const rsi=(cl,p=14)=>{ if(cl.length<=p) return null; let g=0,l=0; for(let i=1;i<=p;i++){ const d=cl[i]-cl[i-1]; g+=d>0?d:0; l+=d<0?-d:0; } let ag=g/p, al=l/p; for(let i=p+1;i<cl.length;i++){ const d=cl[i]-cl[i-1]; ag=(ag*(p-1)+(d>0?d:0))/p; al=(al*(p-1)+(d<0?-d:0))/p; } const rs=al===0?100:ag/al; return 100-100/(1+rs); };
            const computeADX_ATR=(h,l,c,p=14)=>{ const n=c.length; if(n<p+2) return null; const TR=[],plusDM=[],minusDM=[];
              for(let i=1;i<n;i++){ const up=h[i]-h[i-1], down=l[i-1]-l[i]; plusDM.push((up>down&&up>0)?up:0); minusDM.push((down>up&&down>0)?down:0);
                TR.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1]))); }
              let trN=0,pdmN=0,ndmN=0; for(let i=0;i<p;i++){ trN+=TR[i]; pdmN+=plusDM[i]; ndmN+=minusDM[i]; }
              let pDI=100*(pdmN/(trN||1)), nDI=100*(ndmN/(trN||1)); let dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1), adx=dx;
              for(let i=p;i<TR.length;i++){ trN=trN-(trN/p)+TR[i]; pdmN=pdmN-(pdmN/p)+plusDM[i]; ndmN=ndmN-(ndmN/p)+minusDM[i];
                pDI=100*(pdmN/(trN||1)); nDI=100*(ndmN/(trN||1)); dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1); adx=((adx*(p-1))+dx)/p; }
              const atr=trN/p; return { adx, atr, trLast: TR.at(-1) };
            };
            const vwapAnchored=(h,l,c,v,win)=>{ const n=c.length,s=Math.max(0,n-win); let pv=0,vv=0; for(let i=s;i<n;i++){ const tp=(h[i]+l[i]+c[i])/3; const vol=+v[i]||0; pv+=tp*vol; vv+=vol; } return vv>0?pv/vv:c.at(-1); };
            const corr=(a,b)=>{ const n=Math.min(a.length,b.length); if(n<5) return 0; const as=a.slice(-n), bs=b.slice(-n);
              const ma=as.reduce((x,y)=>x+y,0)/n, mb=bs.reduce((x,y)=>x+y,0)/n; let num=0,da=0,db=0;
              for(let i=0;i<n;i++){ const xa=as[i]-ma, xb=bs[i]-mb; num+=xa*xb; da+=xa*xa; db+=xb*xb; }
              const den=Math.sqrt(da*db); return den===0?0:num/den;
            };
            const wilsonLCB=(p,n,z=1.28)=>{ if(n<=0) return p; const z2=z*z; const a=p + z2/(2*n); const b=z*Math.sqrt((p*(1-p)+z2/(4*n))/n); const c=1+z2/n; return clamp((a-b)/c, 0, 1); };
            const avgAbsRetBps=(c,win=40)=>{ if(c.length<win+1) return null; let s=0; for(let i=c.length-win;i<c.length;i++){ s += Math.abs((c[i]/c[i-1])-1); } return (s/win)*10000; };

            const log=(...a)=>console.log('[gha]',...a);

            // ---------- Config ----------
            let MIN_QV = Number(process.env.MIN_QV_USD||'0') || 25_000_000;
            const TOP_N = Number(process.env.TOP_N||'10');
            const MAX_SPREAD_BPS = Number(process.env.MAX_SPREAD_BPS||'15');
            const EXP_LCB_MIN_BPS = Number(process.env.EXP_LCB_MIN_BPS||'2');

            const EMA_FAST=21, EMA_SLOW=50, ADX_P=14, ATR_P=14;
            const K1M=240, K5M=120, K15M=96, K1H=96;
            const VWAP_5M_WIN=36;

            const COST_BPS = Number(process.env.FEES_BPS||'10');
            const NOTIONAL = Number(process.env.NOTIONAL_USD||'200');

            const COOLDOWN_MS = 3*60*60*1000;
            const DD_24H_LIMIT_BPS=-150, DD_PEAK_LIMIT_BPS=-300;
            const WILSON_Z=1.28;

            // Auto-RRR bounds (ATR multiples)
            const TP_ATR_MIN=0.40, TP_ATR_MAX=2.00;
            const SL_ATR_MIN=0.30, SL_ATR_MAX=1.50;
            const TP_TREND_BASE=1.08, SL_TREND_BASE=0.56;
            const TP_MR_BASE=0.60,  SL_MR_BASE=0.55;
            const TP_BO_BASE=1.25,  SL_BO_BASE=0.55;

            // Time-of-day gating (optional)
            const S_H = process.env.ACTIVE_UTC_START? Number(process.env.ACTIVE_UTC_START): null;
            const E_H = process.env.ACTIVE_UTC_END?   Number(process.env.ACTIVE_UTC_END):   null;
            const nowH = new Date().getUTCHours();
            const todOK = (S_H==null || E_H==null) ? true : (S_H<=E_H ? (nowH>=S_H && nowH<=E_H) : (nowH>=S_H || nowH<=E_H));

            const STABLES=new Set(['USDT','BUSD','USDC','TUSD','FDUSD','DAI','USDP','PAX','USTC','USD']);

            // ---------- Net ----------
            const UA='gh-actions-ideas-elite/1.0 (+https://github.com/)';
            async function fetchWithTimeout(url,opts={},ms=12000){ const ac=new AbortController(); const t=setTimeout(()=>ac.abort(),ms); try{ return await fetch(url,{...opts,signal:ac.signal,headers:{'User-Agent':UA,...(opts.headers||{})}});} finally{ clearTimeout(t);} }
            async function getJSON(url,ms=12000){ const r=await fetchWithTimeout(url,{},ms); if(!r?.ok) return null; try{ return await r.json(); }catch{return null;} }

            // Worker endpoints
            const PUSH_URL=process.env.WORKER_PUSH_URL||'';
            const PUSH_TOKEN=process.env.PUSH_TOKEN||'';
            if(!PUSH_URL||!PUSH_TOKEN){ console.error('[gha] Missing WORKER_PUSH_URL or PUSH_TOKEN'); process.exit(1); }
            const HEALTH_URL=(()=>{ try{ const u=new URL(PUSH_URL); return u.origin+u.pathname.replace(/\/signals\/push(\?.*)?$/,'/health'); }catch{return PUSH_URL.replace(/\/signals\/push(\?.*)?$/,'/health'); }})();

            // Health ping
            log('health GET', HEALTH_URL);
            try{
              const r=await fetchWithTimeout(HEALTH_URL,{ headers:{ 'Authorization':`Bearer ${PUSH_TOKEN}`, 'User-Agent':UA }},5000);
              log('health status', r?.status||'ERR');
            }catch(e){ log('health error', e?.message||e); }

            // ---------- Base selection (force binance.com only) ----------
            const baseCandidates=[
              process.env.BINANCE_BASE,
              'https://api1.binance.com',
              'https://api-gcp.binance.com',
              'https://api2.binance.com',
              'https://api3.binance.com',
              'https://api.binance.com'
            ].filter(Boolean);
            let BASE=null, ALL24=null;
            async function pickBaseAnd24hr(){
              for(const b of baseCandidates){
                try{ const r=await fetchWithTimeout(`${b}/api/v3/ticker/24hr`,{},10000); if(r.ok){ return { base:b, data: await r.json() }; } }catch{}
              } throw new Error('binance.com unreachable (no .us fallback)');
            }
            const api=(path,params={})=>{ const u=new URL(path,BASE); for(const [k,v] of Object.entries(params)){ if(v!==undefined&&v!==null) u.searchParams.set(k,String(v)); } return u.toString(); };
            const fetchK=async(sym,interval,limit,startTime,endTime)=>{ try{ const r=await getJSON(api('/api/v3/klines',{symbol:sym,interval,limit,startTime,endTime})); return Array.isArray(r)?r:null; }catch{return null;} };

            // ---------- Gist state ----------
            async function loadState(){ const token=process.env.GIST_TOKEN, id=process.env.GIST_ID; const init={ v:'elite-ideas-1.0', cooldown:{}, pending:[], equity:[] };
              if(!token||!id) return { state:init, persist:null };
              try{ const r=await fetchWithTimeout(`https://api.github.com/gists/${id}`,{ headers:{Authorization:`Bearer ${token}`,'Accept':'application/vnd.github+json','User-Agent':UA}}); if(!r.ok) return { state:init, persist:null };
                const g=await r.json(); const c=g.files?.['state.json']?.content; return { state: c?JSON.parse(c):init, persist:{id,token} }; }catch{ return { state:init, persist:null }; } }
            async function saveState(persist,state){ if(!persist) return; try{ await fetchWithTimeout(`https://api.github.com/gists/${persist.id}`,{ method:'PATCH', headers:{Authorization:`Bearer ${persist.token}`,'Accept':'application/vnd.github+json','Content-Type':'application/json','User-Agent':UA}, body: JSON.stringify({ files:{ 'state.json':{ content: JSON.stringify(state) } } }) }); }catch{} }
            async function evalPending(state){
              const now=Date.now(); const keep=[];
              for(const p of state.pending||[]){
                if(now < p.ts_ms + p.hold_sec*1000 + 5000){ keep.push(p); continue; }
                const k = await fetchK(p.symbolFull,'1m',K1M, p.ts_ms-60*1000, p.ts_ms+p.hold_sec*1000+60*1000);
                if(!k){ keep.push(p); continue; }
                const highs=k.map(x=>+x[2]), lows=k.map(x=>+x[3]), closes=k.map(x=>+x[4]);
                const entry=p.entry_price, long=p.side==='long', tp=p.tp_bps/10000, sl=p.sl_bps/10000;
                let exitPx=closes.at(-1);
                for(let i=0;i<k.length;i++){
                  const hi=highs[i], lo=lows[i];
                  if(long){ if(hi>=entry*(1+tp)){ exitPx=entry*(1+tp); break; } if(lo<=entry*(1-sl)){ exitPx=entry*(1-sl); break; } }
                  else    { if(lo<=entry*(1-tp)){ exitPx=entry*(1-tp); break; } if(hi>=entry*(1+sl)){ exitPx=entry*(1+sl); break; } }
                }
                const ret = long? (exitPx/entry - 1) : (entry/exitPx - 1);
                const pnl_bps = Math.round(ret*10000) - (p.cost_bps||0);
                state.equity.push({ ts_ms:p.ts_ms, pnl_bps });
              }
              state.pending = keep;
              if(state.equity.length>6000) state.equity = state.equity.slice(-6000);
            }
            const equityStats=(eq)=>{ const day=Date.now()-24*3600*1000; let pnl24=0,cum=0,peak=0,dd=0;
              for(const e of eq){ if(e.ts_ms>=day) pnl24+=e.pnl_bps; cum+=e.pnl_bps; if(cum>peak) peak=cum; dd=Math.min(dd,cum-peak); }
              return { pnl24_bps:Math.round(pnl24), peak_dd_bps:Math.round(dd) };
            };

            // ---------- Main ----------
            let picks=[], reason='ok', metaExtra={};

            try{
              const picked=await pickBaseAnd24hr(); BASE=picked.base; ALL24=picked.data;
              const host = new URL(BASE).host;
              const isUS = /(^|\.)binance\.us$/i.test(host);
              if (isUS) { throw new Error('binance.com unreachable; refusing .us fallback'); }

              log('base', BASE, 'MIN_QV', MIN_QV);

              if(!todOK){ reason='tod_gate'; throw new Error('time-of-day gate'); }

              // Universe build (liquidity-first)
              const QUOTES = ['USDT','FDUSD','BUSD','TUSD','USDC'];
              const split=(sym)=>{ for(const q of QUOTES){ if(sym.endsWith(q)) return { base: sym.slice(0,-q.length), quote:q }; } return null; };
              const all=[]; for(const t of ALL24){ const sym=t.symbol||''; const sq=split(sym); if(!sq) continue; const base=sq.base; if(STABLES.has(base)) continue; const qv=+(t.quoteVolume||0); if(!isFinite(qv)||qv<=0) continue; all.push({ symbol:sym, base, quote:sq.quote, qv }); }
              all.sort((a,b)=>b.qv-a.qv);
              const universe = all.filter(x=>x.qv>=MIN_QV).slice(0,60);
              if(!universe.length){ reason='no_universe'; throw new Error('no liquid symbols'); }

              // Books and regime
              const books=await getJSON(api('/api/v3/ticker/bookTicker'))||[];
              const bookMap=new Map(books.map(b=>[b.symbol,{ bid:+b.bidPrice, ask:+b.askPrice }]));

              const kBTC15=await fetchK('BTCUSDT','15m',K15M);
              const kETH15=await fetchK('ETHUSDT','15m',K15M);
              const kBTC1H=await fetchK('BTCUSDT','1h',K1H);
              const kETH1H=await fetchK('ETHUSDT','1h',K1H);
              const regime=(()=>{
                const f=(k)=>{ if(!k||k.length<ADX_P+5) return null; const h=k.map(x=>+x[2]), l=k.map(x=>+x[3]), c=k.map(x=>+x[4]); const { adx }=computeADX_ATR(h,l,c,ADX_P)||{}; const roc=((c.at(-1)/c.at(-5)) - 1); return { adx:adx||0, roc }; };
                const b=f(kBTC15)||{adx:0,roc:0}, e=f(kETH15)||{adx:0,roc:0};
                const adxAvg=((b.adx||0)+(e.adx||0))/2, dir = Math.sign((b.roc||0)+(e.roc||0));
                const isTrend=adxAvg>=22 && Math.abs(b.roc)>0.001 && Math.abs(e.roc)>0.001;
                const uncertain=adxAvg>=18 && adxAvg<=22;
                return { regime: isTrend?'trend':'meanrevert', adxAvg, dir, uncertain };
              })();
              log('regime', regime.regime, 'adxAvg', regime.adxAvg?.toFixed?.(1)||'');

              // State (DD throttle)
              const { state, persist } = await loadState();
              try{ await evalPending(state); }catch{}
              const { pnl24_bps, peak_dd_bps } = equityStats(state.equity);
              const throttle = (pnl24_bps<=DD_24H_LIMIT_BPS) || (peak_dd_bps<=DD_PEAK_LIMIT_BPS);

              // Liquidity percentile map
              const liqPct=new Map(); for(let i=0;i<universe.length;i++){ liqPct.set(universe[i].symbol,(universe.length===1)?1:1 - i/(universe.length-1)); }

              // Depth + OBI
              async function depthSlipAndObi(symbol, notionalUSD, book){
                const depth=await getJSON(api('/api/v3/depth',{symbol,limit:20}));
                const mid=(book.bid+book.ask)/2;
                const fallback = {
                  longBps: Math.max(0, Math.round((book.ask-mid)/mid*10000)),
                  shortBps: Math.max(0, Math.round((mid-book.bid)/mid*10000)),
                  obi: 0
                };
                if(!depth?.asks?.length || !depth?.bids?.length) return fallback;

                const topN=8;
                let bidNot=0, askNot=0;
                for(let i=0;i<Math.min(topN, depth.bids.length); i++){ const p=+depth.bids[i][0], q=+depth.bids[i][1]; if(p>0&&q>0) bidNot += p*q; }
                for(let i=0;i<Math.min(topN, depth.asks.length); i++){ const p=+depth.asks[i][0], q=+depth.asks[i][1]; if(p>0&&q>0) askNot += p*q; }
                const obi = (bidNot+askNot>0) ? (bidNot-askNot)/(bidNot+askNot) : 0;

                const vwap=(levels,targetUSD)=>{
                  let remain=targetUSD,val=0,qty=0;
                  for(const [ps,qs] of levels){ const p=+ps,q=+qs; if(!(p>0&&q>0)) continue; const can=p*q, take=Math.min(remain,can), tq=take/p;
                    val+=p*tq; qty+=tq; remain-=take; if(remain<=1e-6) break; }
                  return qty>0? val/qty : null;
                };
                const tgt=Math.max(50, NOTIONAL);
                const buy=vwap(depth.asks,tgt), sell=vwap(depth.bids,tgt);
                return {
                  longBps: buy ? Math.max(0, Math.round((buy - mid)/mid*10000)) : fallback.longBps,
                  shortBps: sell? Math.max(0, Math.round((mid - sell)/mid*10000)) : fallback.shortBps,
                  obi
                };
              }

              const computeAutoRRR=({regime,p,adx,atr_bps,cost_bps,spread_bps,trend_align,style})=>{
                const adxF=clamp((adx-16)/14,0,1);
                let baseR = style==='trend' ? (1.4+0.8*adxF) : style==='mr' ? (1.05+0.20*(1-adxF)) : (1.6+0.9*adxF);
                baseR *= (1 + 0.4*clamp(p-0.55,-0.2,0.35));
                const rLo = style==='mr' ? 0.95 : 1.1;
                const rHi = style==='breakout' ? 2.7 : 2.5;
                let prefR = clamp(baseR, rLo, rHi);

                let slATR = style==='trend' ? SL_TREND_BASE : SL_MR_BASE : SL_BO_BASE;
                // bug fix: the above line must be three-way; correct version below:
              };
            })();
          JS
          # The block above is truncated because of message size limits.
          # Replace it with the full JS you already have (unchanged).
          node push-ideas.js
