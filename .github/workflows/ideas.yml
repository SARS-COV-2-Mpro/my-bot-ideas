name: Ideas Pusher (MEXC Ultimate 7.4)

on:
  workflow_dispatch:
  schedule:
    - cron: "*/11 * * * *" # runs every 11 minutes

permissions:
  contents: read

concurrency:
  group: ideas-mexc-ultimate
  cancel-in-progress: true

jobs:
  push:
    runs-on: ubuntu-latest
    timeout-minutes: 12
    env:
      # Required secrets
      WORKER_PUSH_URL: ${{ secrets.WORKER_PUSH_URL }}
      PUSH_TOKEN: ${{ secrets.PUSH_TOKEN }}
      MEXC_API_KEY: ${{ secrets.MEXC_API_KEY }}
      MEXC_SECRET_KEY: ${{ secrets.MEXC_SECRET_KEY }}
      GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
      GIST_ID: ${{ secrets.GIST_ID }}

      # Exchange + tuning knobs (via Repo/Org Variables)
      EXCHANGE: mexc
      MIN_QV_USD: ${{ vars.MIN_QV_USD }}
      TOP_N: ${{ vars.TOP_N }}
      MAX_SPREAD_BPS: ${{ vars.MAX_SPREAD_BPS }}
      EXP_LCB_MIN_BPS: ${{ vars.EXP_LCB_MIN_BPS }}
      FEES_BPS: ${{ vars.FEES_BPS }}
      NOTIONAL_USD: ${{ vars.NOTIONAL_USD }}
      MEXC_DEPTH_LIMIT: ${{ vars.MEXC_DEPTH_LIMIT }}
      OBI_TOPN: ${{ vars.OBI_TOPN }}
      ACTIVE_UTC_START: ${{ vars.ACTIVE_UTC_START }}
      ACTIVE_UTC_END: ${{ vars.ACTIVE_UTC_END }}
      MEXC_BASE: ${{ vars.MEXC_BASE }}
      FORCE_SIZE_BPS: ${{ vars.FORCE_SIZE_BPS }}
      DIRECTION: ${{ vars.DIRECTION }}
      MR_BREAKOUT_DC_N: ${{ vars.MR_BREAKOUT_DC_N }}
      MR_BREAKOUT_RET15_ATR: ${{ vars.MR_BREAKOUT_RET15_ATR }}
      MR_LOCKOUT_SEC: ${{ vars.MR_LOCKOUT_SEC }}
      MAX_COST_BPS_HARD: ${{ vars.MAX_COST_BPS_HARD }}
      MIN_VOL_1H_USD: ${{ vars.MIN_VOL_1H_USD }}
      DEPTH_1P_MIN_USD: ${{ vars.DEPTH_1P_MIN_USD }}
      MIN_TF_ALIGN: ${{ vars.MIN_TF_ALIGN || "0.55" }}

    steps:
      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Run pusher (always-push + clear logs)
        shell: bash
        run: |
          set -euo pipefail

          # Hard fail only on true misconfig (so setup problems aren't hidden)
          if [[ -z "${WORKER_PUSH_URL:-}" || -z "${PUSH_TOKEN:-}" ]]; then
            echo "[gha] Missing WORKER_PUSH_URL or PUSH_TOKEN"
            exit 1
          fi

          set +e
          node - <<'NODE'
          (async ()=>{
          'use strict';
          const crypto = require('crypto');

          const UA = "ideas-pusher/6.9 (+github-actions)";

          async function fetchWithTimeout(resource, options = {}, timeout = 10000) {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);
            try {
              const res = await fetch(resource, {
                ...options,
                signal: controller.signal,
                headers: { "User-Agent": UA, ...(options.headers || {}) }
              });
              return res;
            } finally {
              clearTimeout(id);
            }
          }

          async function getJSON(url, timeout = 10000, retries = 1, options = {}) {
            for (let i = 0; i <= retries; i++) {
              try {
                const r = await fetchWithTimeout(url, options, timeout);
                if (r.ok) return await r.json();
                // non-2xx: read body for debugging, then fall through to retry
                await r.text().catch(() => {});
              } catch (_) {
                // network/timeout -> retry if any left
              }
            }
            return null;
          }

          function depthWithinPctUSD(depth, mid, pct = 0.01) {
            if (!(depth?.bids?.length && depth?.asks?.length && mid > 0)) {
              return { bidsUSD: 0, asksUSD: 0 };
            }
            const bidCut = mid * (1 - pct);
            const askCut = mid * (1 + pct);
            let bidsUSD = 0, asksUSD = 0;

            for (const [ps, qs] of depth.bids) {
              const p = +ps, q = +qs;
              if (!(p >= bidCut && q > 0)) break;
              bidsUSD += p * q;
            }
            for (const [ps, qs] of depth.asks) {
              const p = +ps, q = +qs;
              if (!(p <= askCut && q > 0)) break;
              asksUSD += p * q;
            }
            return { bidsUSD, asksUSD };
          }


          // ---------------- Utils ----------------
          const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
          const sum=(a)=>a.reduce((x,y)=>x+y,0);
          const mean=(a)=>a.length?sum(a)/a.length:0;
          const std = (a) => { const m = mean(a); let v = 0; for (const x of a) v += (x - m) ** 2; return a.length > 1 ? Math.sqrt(v / (a.length - 1)) : 0; };
          const corr = (a, b) => { const n = Math.min(a?.length || 0, b?.length || 0); if (n < 5) return 0; const as = a.slice(-n), bs = b.slice(-n); const ma = mean(as), mb = mean(bs); let num = 0, da = 0, db = 0; for (let i = 0; i < n; i++) { const xa = as[i] - ma, xb = bs[i] - mb; num += xa * xb; da += xa * xa; db += xb * xb; } const den = Math.sqrt(da * db) || 1; return num / den; };
          const ema=(arr,p)=>{ if(!arr||arr.length<p) return null; const k=2/(p+1); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; for(let i=p;i<arr.length;i++) e=arr[i]*k+e*(1-k); return e; };
          const rsi = (cl, p = 14) => {
            if (!cl || cl.length <= p) return null; let g=0,l=0;
            for (let i=1;i<=p;i++) { const d=cl[i]-cl[i-1]; g+=Math.max(0,d); l+=Math.max(0,-d); }
            let ag=g/p,al=l/p;
            for (let i=p+1;i<cl.length;i++) { const d=cl[i]-cl[i-1]; ag=(ag*(p-1)+Math.max(0,d))/p; al=(al*(p-1)+Math.max(0,-d))/p; }
            const rs=al===0?100:ag/al; return 100-100/(1+rs);
          };
          const computeADX_ATR=(h,l,c,p=14)=>{ const n=c.length; if(n<p+2) return null; const TR=[],plusDM=[],minusDM=[]; for(let i=1;i<n;i++){ const up=h[i]-h[i-1], down=l[i-1]-l[i]; plusDM.push((up>down&&up>0)?up:0); minusDM.push((down>up&&down>0)?down:0); TR.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1]))); } let trN=0,pdmN=0,ndmN=0; for(let i=0;i<p;i++){ trN+=TR[i]; pdmN+=plusDM[i]; ndmN+=minusDM[i]; } let pDI=100*(pdmN/(trN||1)), nDI=100*(ndmN/(trN||1)); let dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1), adx=dx; for(let i=p;i<TR.length;i++){ trN=trN-(trN/p)+TR[i]; pdmN=pdmN-(pdmN/p)+plusDM[i]; ndmN=ndmN-(ndmN/p)+minusDM[i]; pDI=100*(pdmN/(trN||1)); nDI=100*(ndmN/(trN||1)); dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1); adx=((adx*(p-1))+dx)/p; } const atr=trN/p; return { adx, atr }; };

          const vwapAnchored=(h,l,c,v,win)=>{ if(!c?.length) return null; const n=c.length,s=Math.max(0,n-win); let pv=0,vv=0; for(let i=s;i<n;i++){ const tp=(h[i]+l[i]+c[i])/3; const vol=+v[i]||0; pv+=tp*vol; vv+=vol; } return vv>0?pv/vv:c.at(-1); };
          const wilsonLCB=(p,n,z=1.34)=>{ if(n<=0) return p; const z2=z*z; const a=p + z2/(2*n); const b=z*Math.sqrt((p*(1-p)+z2/(4*n))/n); const c=1+z2/n; return clamp((a-b)/c, 0, 1); };
          const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
          const log=(...a)=>console.log("[gha]",...a);
          const sigmoid=(z)=>1/(1+Math.exp(-z));
          const kalman1D=(obs,{q=1e-5,r=1e-3,x0=null,p0=1e-2}={})=>{ if(!obs?.length) return []; let x=(x0==null?obs[0]:x0), p=p0; const out=[]; for(const z of obs){ p+=q; const K=p/(p+r); x=x+K*(z-x); p=(1-K)*p; out.push(x); } return out; };
          const getTradeFingerprint=(data)=>{ const str=`${(data.client_order_id || data.idea_id)}:${data.side}:${(data.price_entry||0).toFixed(5)}:${(data.qty||0).toFixed(5)}`; return crypto.createHash('sha1').update(str).digest('hex').slice(0, 16); };
          const slopeBps=(arr, n=12)=>{ if(!arr?.length) return 0; const a=arr.slice(-n); const N=a.length; if(N<3) return 0; const xMean=(N-1)/2; let num=0, den=0; const last=a[N-1]||1; for(let i=0;i<N;i++){ const x=i,y=a[i]; num+=(x-xMean)*y; den+=(x-xMean)*(x-xMean); } const slope=den>0?num/den:0; return Math.round((slope/last)*10000);};

          // ---------- Microstructure / Heavy Features ----------
          const computeOBI = (depth, topN = 12) => {
            if (!depth?.asks?.length || !depth?.bids?.length) return 0;
            const w = (i) => Math.exp(-i * 0.18);
            let bidNot = 0, askNot = 0;
            for (let i=0;i<Math.min(topN, depth.bids.length); i++){ const p=+depth.bids[i][0], q=+depth.bids[i][1]; if(p>0&&q>0) bidNot += p*q*w(i); }
            for (let i=0;i<Math.min(topN, depth.asks.length); i++){ const p=+depth.asks[i][0], q=+depth.asks[i][1]; if(p>0&&q>0) askNot += p*q*w(i); }
            return (bidNot+askNot>0) ? (bidNot-askNot)/(bidNot+askNot) : 0;
          };
          const vwapFillLevels = (levels, targetUSD) => {
            let remain = targetUSD, val = 0, qty = 0;
            for (const [ps, qs] of (levels || [])) {
              const p = +ps, q = +qs; if (!(p > 0 && q > 0)) continue;
              const can = p * q, take = Math.min(remain, can), tq = take / p;
              val += p * tq; qty += tq; remain -= take; if (remain <= 1e-6) break;
            }
            return { px: qty > 0 ? val / qty : null, filledUSD: (targetUSD - remain) };
          };
          const slipFromDepth = (depth, mid, side, notionalUSD) => {
            if (!depth?.asks?.length || !depth?.bids?.length || !(mid > 0)) return { slip_bps: null, fill_prob: null };
            if (side === "long") {
              const buy = vwapFillLevels(depth.asks, Math.max(50, notionalUSD));
              const slip = buy.px ? Math.max(0, Math.round((buy.px - mid) / mid * 10000)) : null;
              const fill = Math.min(1, (buy.filledUSD || 0) / Math.max(1, notionalUSD));
              return { slip_bps: slip, fill_prob: +fill.toFixed(4) };
            } else {
              const sell = vwapFillLevels(depth.bids, Math.max(50, notionalUSD));
              const slip = sell.px ? Math.max(0, Math.round((mid - sell.px) / mid * 10000)) : null;
              const fill = Math.min(1, (sell.filledUSD || 0) / Math.max(1, notionalUSD));
              return { slip_bps: slip, fill_prob: +fill.toFixed(4) };
            }
          };

          // ---------- Metadata + Config ----------
          const STRATEGY_NAME = "mexc-ultimate";
          const MODEL_VERSION = "7.4-stable-tf";
          const SCHEMA_VERSION = "4.4-stable-tf";
          const GIT_SHA = process.env.GITHUB_SHA || process.env.VERCEL_GIT_COMMIT_SHA || process.env.GIT_COMMIT || null;
          const genUUID = ()=> (crypto.randomUUID ? crypto.randomUUID() : crypto.randomBytes(16).toString("hex"));
          const PUSH_URL=process.env.WORKER_PUSH_URL||"", PUSH_TOKEN=process.env.PUSH_TOKEN||"";
          const MEXC_API_KEY = process.env.MEXC_API_KEY || ""; const MEXC_SECRET_KEY = process.env.MEXC_SECRET_KEY || "";
          const MEXC_BASES=[process.env.MEXC_BASE,"https://api.mexc.com","https://www.mexc.com"].filter(Boolean);
          const TOP_N=Number(process.env.TOP_N||"3"), NOTIONAL=Number(process.env.NOTIONAL_USD||"300");
          const DIRECTION=(process.env.DIRECTION||"both").trim().toLowerCase();
          const MR_LOCKOUT_SEC=Number(process.env.MR_LOCKOUT_SEC||"1800");
          const QUOTES = ["USDT", "USDC", "USD"]; const split = (sym) => { for (const q of QUOTES) if (sym.endsWith(q)) return { base: sym.slice(0, -q.length), quote: q }; return null; };

          // Timeframes (candidate set); 3m weight is 0 so it will be ignored in auto-detect
          let TIMEFRAMES = ["1m", "3m", "5m", "15m", "30m", "1h", "4h", "1d"];
          let TF_WEIGHTS = { "1m": 0.18, "3m": 0.00, "5m": 0.26, "15m": 0.22, "30m": 0.16, "1h": 0.10, "4h": 0.06, "1d": 0.02 };
          const TF_CANDLE_LIMITS = { "1m": 300, "3m": 300, "5m": 300, "15m": 300, "30m": 300, "1h": 100, "4h": 100, "1d": 60 };
          const MIN_TF_ALIGN = Number(process.env.MIN_TF_ALIGN || "0.55");
          const RSI_PERIOD = 14, ADX_PERIOD = 14, ROC_SHORT_BARS = 1, ROC_MED_BARS = 3, EMA_FAST=21, EMA_SLOW=50;

          const DEPTH_LIMIT = Number(process.env.MEXC_DEPTH_LIMIT || "50");
          const COST_BPS    = Number(process.env.FEES_BPS || "10");
          const MAX_COST_BPS_HARD = Number(process.env.MAX_COST_BPS_HARD || "9999");
          const COOLDOWN_MS = 3 * 60 * 60 * 1000;
          const TTL_MIN     = 540; // seconds
          const STABLES = new Set(["USDT","USDC","USD","USDE","USDD","BUSD","FDUSD","TUSD","DAI","USDP","PAX","USTC"]);
          const OBI_TOPN = Number(process.env.OBI_TOPN || "12");
          const MAX_SPREAD_BPS = Number(process.env.MAX_SPREAD_BPS || "12");
          const MIN_VOL_1H_USD = Number(process.env.MIN_VOL_1H_USD || "0");
          const EXP_LCB_MIN_BPS = Number(process.env.EXP_LCB_MIN_BPS || "10");
          const MIN_QV_USD = Number(process.env.MIN_QV_USD || "0");
          const DEPTH_1P_MIN_USD = Number(process.env.DEPTH_1P_MIN_USD || "0");

          const ACTIVE_UTC_START = (process.env.ACTIVE_UTC_START||"").trim();
          const ACTIVE_UTC_END   = (process.env.ACTIVE_UTC_END||"").trim();

          function configHash() { const cfg = { TOP_N, NOTIONAL, DIRECTION, MR_LOCKOUT_SEC, MIN_TF_ALIGN, TF_WEIGHTS }; try { return crypto.createHash("sha1").update(JSON.stringify(cfg)).digest("hex").slice(0, 12); } catch { return null; } }
          const CONFIG_HASH = configHash();

          // ---------- HTTP + Network Utils ----------
          const jitter = (ms) => ms + Math.floor(Math.random() * ms * 0.25);

          // ---------- MEXC Adapter ----------
          async function pickMexcBase(){ for(const b of MEXC_BASES){ try{ const r=await fetchWithTimeout(`${b}/api/v3/time`,{},4000); if(r?.ok) return b; }catch{} } throw new Error("No healthy MEXC base"); }
          const BASE=await pickMexcBase();
          const api=(path,params={})=>{ const u=new URL(path,BASE); for(const [k,v] of Object.entries(params)){ if(v!==undefined&&v!==null) u.searchParams.set(k,String(v)); } return u.toString(); };
          async function mexcSignedRequest(path, params={}, method='GET') {
            if (!MEXC_API_KEY || !MEXC_SECRET_KEY) return null;
            const timestamp=Date.now();
            const queryString=new URLSearchParams({...params, timestamp}).toString();
            const signature=crypto.createHmac('sha256',MEXC_SECRET_KEY).update(queryString).digest('hex');
            const url=new URL(path,BASE); url.search=queryString+`&signature=${signature}`;
            const options={method,headers:{'X-MEXC-APIKEY':MEXC_API_KEY,'Content-Type':'application/json'}};
            try { const r=await fetchWithTimeout(url.toString(),options,15000); if(r.ok)return await r.json(); log(`MEXC signed fail: ${r.status}`, (await r.text()||'').slice(0,100)); return null; } catch(e){ log(`MEXC signed error: ${e?.message||e}`); return null; }
          }
          async function fetchMyTrades(symbol,startTime) { return await mexcSignedRequest('/api/v3/myTrades',{symbol,startTime,limit:1000}); }
          async function fetchOrder(symbol,origClientOrderId) { return await mexcSignedRequest('/api/v3/order',{symbol,origClientOrderId}); }
          async function fetchOpenOrders(symbol) { return await mexcSignedRequest('/api/v3/openOrders',{symbol}); }
          async function fetchK(symbol,interval,limit,startTime,endTime){
            const u=api("/api/v3/klines",{symbol,interval,limit,startTime,endTime});
            return await getJSON(u,10000,2);
          }
          async function fetchKlinesMTF(symbol) {
            const allData = {};
            const need = Math.max(RSI_PERIOD + 1, ADX_PERIOD + 1);
            for (const tf of TIMEFRAMES) {
              const limit = TF_CANDLE_LIMITS[tf] || 100;
              const k = await fetchK(symbol, tf, limit);
              if (!k || k.length < need) { log(`MTF Soft Skip: ${symbol} ${tf} missing (${k?.length||0}<${need})`); continue; }
              const closes = k.map(x => +x[4]);
              allData[tf] = {
                ts: k.map(x => +x[0]),
                highs: k.map(x => +x[2]),
                lows: k.map(x => +x[3]),
                closes,
                volumes: k.map(x => +x[5]),
                c_kalman: kalman1D(closes, { q: 1e-4, r: 5e-4 })
              };
            }
            return allData;
          }
          async function resolveSupportedTFs() {
            const testSym = "BTCUSDT";
            const need = Math.max(RSI_PERIOD + 1, ADX_PERIOD + 1);
            const supported = [];
            for (const tf of TIMEFRAMES) {
              if ((TF_WEIGHTS[tf] || 0) <= 0) continue;
              const k = await fetchK(testSym, tf, Math.max(need, 60));
              if (Array.isArray(k) && k.length >= need) supported.push(tf);
            }
            const wSum = supported.reduce((s, tf) => s + (TF_WEIGHTS[tf] || 0), 0) || 1;
            const renorm = {};
            for (const tf of supported) renorm[tf] = (TF_WEIGHTS[tf] || 0) / wSum;
            TIMEFRAMES = supported;
            TF_WEIGHTS = renorm;
            log("Active timeframes:", TIMEFRAMES, "weights:", TF_WEIGHTS);
          }
          async function fetchTickerPrice(symbol){ const u=api("/api/v3/ticker/price",{symbol}); const r=await getJSON(u,5000,2); return r?.price?r.price:null; }
          const conversionRateCache=new Map();
          async function getConversionRate(fromAsset,toAsset) {
            if(fromAsset===toAsset)return 1.0;
            const key=`${fromAsset}/${toAsset}`;
            if(conversionRateCache.has(key))return conversionRateCache.get(key);
            let rate=null;
            const directPair=`${fromAsset}${toAsset}`;
            const reversePair=`${toAsset}${fromAsset}`;
            let price=await fetchTickerPrice(directPair);
            if(price){rate=parseFloat(price);}else{price=await fetchTickerPrice(reversePair); if(price)rate=1.0/parseFloat(price);}
            if(rate)conversionRateCache.set(key,rate); else log(`WARN: Could not get conversion rate for ${key}`);
            return rate;
          }

          // ---------- MTF Indicators (uses dynamic weights) ----------
          function computeMTFIndicators (mtfData, TF_WEIGHTS, RSI_PERIOD, ADX_PERIOD, ROC_SHORT_BARS, ROC_MED_BARS) {
            if (!mtfData) return null;
            let totalWeight = 0, sumRsi = 0, sumAdx = 0, sumAtrBps = 0, sumRocShort = 0, sumRocMed = 0;
            const tfCloses = [];
            for (const [tf, data] of Object.entries(mtfData)) {
              const w = TF_WEIGHTS[tf] || 0; if (w <= 0) continue;
              const { c_kalman: c, highs: h, lows: l } = data; const last = c.at(-1);
              if (!(last > 0)) continue;
              const rsi_tf = rsi(c, RSI_PERIOD);
              const r = computeADX_ATR(h, l, c, ADX_PERIOD) || {};
              const adx_tf = r.adx || 0, atr_tf = r.atr || 0;
              const rocShort_tf = (last / (c.at(-1 - ROC_SHORT_BARS) || last)) - 1;
              const rocMed_tf   = (last / (c.at(-1 - ROC_MED_BARS)   || last)) - 1;
              const atr_bps_tf  = atr_tf ? Math.round((atr_tf / last) * 10000) : 0;
              sumRsi += (rsi_tf ?? 50) * w; sumAdx += adx_tf * w; sumAtrBps += atr_bps_tf * w; sumRocShort += rocShort_tf * w; sumRocMed += rocMed_tf * w; totalWeight += w;
              tfCloses.push(c.slice(-50));
            }
            if (totalWeight < 0.9) return null;
            const avgRsi = sumRsi / totalWeight; const avgAdx = sumAdx / totalWeight; const avgAtrBps = Math.round(sumAtrBps / totalWeight);
            const avgRoc5 = sumRocShort / totalWeight; const avgRoc15 = sumRocMed / totalWeight;
            let tfAlign = 0, alignCount = 0;
            for (let i=0;i<tfCloses.length;i++) for (let j=i+1;j<tfCloses.length;j++){ tfAlign+=corr(tfCloses[i],tfCloses[j]); alignCount++; }
            tfAlign = alignCount > 0 ? clamp(tfAlign / alignCount, 0, 1) : 0;
            return { rsi: avgRsi, adx: avgAdx, atr_bps: avgAtrBps, roc5: avgRoc5, roc15: avgRoc15, tfAlign };
          }

          // ---------- FEATURE LEARNER ----------
          const FEATURE_KEYS = ['rsi', 'adx', 'atr_bps', 'roc5', 'roc15', 'tfAlign', 'z_vwap', 'spread_bps', 'slip_est_bps', 'obi', 'btc_adx'];
          function vectorizeFeatures(features) {
            const vec = new Float32Array(FEATURE_KEYS.length);
            vec[0] = (features.rsi - 50) / 50; vec[1] = (features.adx - 25) / 25; vec[2] = features.atr_bps / 100;
            vec[3] = features.roc5 / 0.005; vec[4] = features.roc15 / 0.01; vec[5] = features.tfAlign;
            vec[6] = clamp(features.z_vwap / 3, -1, 1); vec[7] = -features.spread_bps / 20; vec[8] = -features.slip_est_bps / 15;
            vec[9] = features.obi || 0; vec[10] = ((features.btc_adx || 20) - 20) / 20;
            return vec;
          }
          function getFeatureCoeffs(state, symbol, side, regime) {
            state.feature_coeffs ||= {};
            const symKey = `${symbol}_${side}_${regime}`;
            const globalKey = `global_${side}_${regime}`;
            if (state.feature_coeffs[symKey] && state.feature_coeffs[symKey].n > 5) return state.feature_coeffs[symKey];
            if (state.feature_coeffs[globalKey]) return state.feature_coeffs[globalKey];
            const initialWeights = new Float32Array(FEATURE_KEYS.length).fill(0);
            return { a: 0, b: initialWeights, n: 0 };
          }
          function predictWithFeatures(coeffs, features) {
            const vec = vectorizeFeatures(features);
            let z = coeffs.a;
            for (let i = 0; i < coeffs.b.length; i++) z += coeffs.b[i] * vec[i];
            return sigmoid(z);
          }
          function updateFeatureWeights(state, symbol, side, regime, features, outcome) {
            const symKey = `${symbol}_${side}_${regime}`, globalKey = `global_${side}_${regime}`;
            const update = (key, lr) => {
              const base = getFeatureCoeffs(state, symbol, side, regime);
              state.feature_coeffs[key] ||= { a: base.a, b: new Float32Array(base.b), n: 0 };
              const cur = state.feature_coeffs[key];
              const pred = predictWithFeatures(cur, features);
              const error = outcome - pred;
              const vec = vectorizeFeatures(features);
              cur.a += lr * error; for (let i = 0; i < cur.b.length; i++) cur.b[i] += lr * error * vec[i];
              cur.n++;
            };
            update(symKey, 0.05); update(globalKey, 0.01);
          }

          // ---------- STATE & AUDIT ----------
          async function loadState(){
            const token=process.env.GIST_TOKEN, id=process.env.GIST_ID;
            const init={ v:MODEL_VERSION, cooldown:{}, pending:[], equity:[], closed:[], mr_lockout:{}, sym_stats:{}, calibCoeffs:{}, feature_coeffs:{}, adaptive_exits:{}, cost_model:{ slip_inflation_factor: 1.0 }, calibration_holdout:[] };
            if(!token||!id) return { state:init, persist:null };
            try{
              const r=await fetchWithTimeout(`https://api.github.com/gists/${id}`,{ headers:{Authorization:`Bearer ${token}`,"Accept":"application/vnd.github+json"}});
              if(!r.ok) return { state:init, persist:null };
              const g=await r.json();
              const c=g.files?.["state.json"]?.content;
              const s=c?JSON.parse(c):init;
              s.cooldown||={}; s.pending||=[]; s.equity||=[]; s.closed||[]; s.mr_lockout||={}; s.sym_stats||={}; s.calibCoeffs||={}; s.feature_coeffs||={}; s.adaptive_exits||={}; s.cost_model||={slip_inflation_factor:1.0}; s.calibration_holdout||[];
              return { state:s, persist:{id,token} };
            }catch{ return { state:init, persist:null }; }
          }
          async function pushToSecondaryStore(auditLogs, disagreementLogs) {
            if (auditLogs.length > 0 || disagreementLogs.length > 0) {
              log(`[AUDIT STUB] Would push ${auditLogs.length} audit logs and ${disagreementLogs.length} disagreements to secondary store.`);
            }
            return true;
          }
          function buildTradesCSV(closed) {
            const header = "ts_entry_ms,ts_exit_ms,symbol,side,exit_reason,price_entry,price_exit,qty,pnl_bps,fees_bps,hold_time_sec,p_raw,p_cal,ev_bps,confidence,calib_key,regime,trend5m_dir,trend5m_adx,trend5m_slope_bps,reconciliation_method,reconciliation_agreed\n";
            const rows = (closed || []).map(r => {
              const t = r.predicted_snapshot?.context?.trend5m || {};
              return [
                r.ts_entry_ms??"", r.ts_exit_ms??"", r.symbolFull||r.symbol||"", r.side||"", r.exit_reason??"",
                r.price_entry??"", r.price_exit??"", r.qty??"", r.pnl_bps??"", r.fees_bps??"", r.hold_time_sec??"",
                r.predicted_snapshot?.p_raw??"", r.predicted_snapshot?.p_cal??"", r.predicted_snapshot?.ev_bps??"",
                r.predicted_snapshot?.confidence_score??"", r.calib_key||"", r.regime||"", t.dir||"", t.adx??"",
                t.slope_bps??"", r.reconciliation_method||"unknown", (r.reconciliation_agreed?"true":"false")
              ].join(",");
            }).join("\n");
            return header + rows + "\n";
          }
          async function saveAuditFiles(persist, state, newAuditLogs, disagreementLogs) {
            if (!persist) return;
            try {
              const gistId = persist.id;
              const headers = { Authorization: `Bearer ${persist.token}`, "Accept": "application/vnd.github+json" };
              const getRes = await fetchWithTimeout(`https://api.github.com/gists/${gistId}`,{headers});
              if (!getRes.ok) throw new Error(`Gist fetch fail: ${getRes.status}`);
              const gistData = await getRes.json();
              state.closed=(state.closed||[]).slice(-3000);
              state.calibration_holdout=(state.calibration_holdout||[]).slice(-500);
              const filesToUpdate = {
                "state.json": { content: JSON.stringify(state, null, 2) },
                "trades.csv": { content: buildTradesCSV(state.closed) }
              };
              const appendToLog=async(fname,logs,file)=>{
                if(logs?.length>0){
                  const ex=file?await(await fetchWithTimeout(file.raw_url)).text():"";
                  const nw=logs.map(l=>JSON.stringify(l)).join('\n');
                  filesToUpdate[fname]={content:(ex?ex+'\n':'')+nw};
                }
              };
              await appendToLog("closed_audit.jsonl", newAuditLogs, gistData.files?.["closed_audit.jsonl"]);
              await appendToLog("reconciliation_disagreements.jsonl", disagreementLogs, gistData.files?.["reconciliation_disagreements.jsonl"]);
              await fetchWithTimeout(`https://api.github.com/gists/${gistId}`, {
                method: "PATCH", headers: { ...headers, "Content-Type": "application/json" }, body: JSON.stringify({ files: filesToUpdate })
              });
              await pushToSecondaryStore(newAuditLogs, disagreementLogs);
            } catch (e) { log("saveAuditFiles error", e?.message || e); }
          }

          // ---------- RECONCILIATION ----------
          async function reconcileAndUpdateState(state) {
            if (!state.pending?.length) return { newAuditLogs: [], disagreementLogs: [] };
            const newPending = [], newAuditLogs = [], disagreementLogs = [];
            for (const p of state.pending) {
              const apiResult = await reconcileViaAPI(p);
              const candleResult = await reconcileViaCandles(p);
              let isClosed = false, finalRec = null, agreement = false;
              if (apiResult.status === 'reconciled') {
                isClosed = true; finalRec = apiResult.closedRec;
                agreement = (candleResult.status === 'reconciled' && apiResult.fingerprint === candleResult.fingerprint);
              } else if (candleResult.status === 'reconciled') {
                isClosed = true; finalRec = candleResult.closedRec;
              }
              if (isClosed) {
                const outcome = finalRec.pnl_bps > 0 ? 1 : 0;
                if (agreement) {
                  updateFeatureWeights(state, p.base, p.side, p.regime, p.predicted.features, outcome);
                  state.adaptive_exits[p.regime] ||= { n:0, mfe_sum:0, mae_sum:0 };
                  const ar = state.adaptive_exits[p.regime]; ar.mfe_sum += (candleResult.closedRec.MFE_bps||0); ar.mae_sum += (candleResult.closedRec.MAE_bps||0); ar.n++;
                } else {
                  state.calibration_holdout.push({ p, apiResult, candleResult, finalRec });
                  if (Math.abs((finalRec.slip_realized_bps || 0) - (p.predicted.features.slip_est_bps || 0)) > 5) {
                    state.cost_model.slip_inflation_factor = Math.min(1.5, (state.cost_model.slip_inflation_factor||1) * 1.01);
                  }
                }
                state.equity.push({ ts_ms: finalRec.ts_exit_ms, pnl_bps: finalRec.pnl_bps });
                const sb = state.sym_stats?.[p.base] || { n: 0, wins: 0, pnl_sum: 0 }; sb.n++; if(finalRec.pnl_bps > 0) sb.wins++; sb.pnl_sum += finalRec.pnl_bps; state.sym_stats[p.base] = sb;
                const auditLog = { ...finalRec, reconciliation_agreed: agreement, predicted_snapshot: p.predicted };
                newAuditLogs.push(auditLog); state.closed ||= []; state.closed.push(auditLog);
                if (!agreement) disagreementLogs.push({ idea_id: p.idea_id, ts_ms: Date.now(), api: apiResult, candles: candleResult });
              } else { newPending.push(p); }
            }
            state.pending = newPending; return { newAuditLogs, disagreementLogs };
          }
          async function reconcileViaAPI(p) {
            if(!MEXC_API_KEY||!MEXC_SECRET_KEY) return {status:'skipped_no_keys'};
            let order=null;
            try{ if(p.client_order_id){ order=await fetchOrder(p.symbolFull,p.client_order_id); } }catch{}
            const byOrderId=async(orderId)=>{ const trades=await fetchMyTrades(p.symbolFull,(p.ts_ms||Date.now())-6*3600*1000); return (trades||[]).filter(t=>String(t.orderId)===String(orderId)); };
            let entryFills=[],exitFills=[];
            if(order?.orderId){
              const fills=await byOrderId(order.orderId);
              entryFills=fills.filter(t=>(p.side==='long'?t.isBuyer:!t.isBuyer));
              exitFills =fills.filter(t=>(p.side==='long'? !t.isBuyer:t.isBuyer));
            }else{
              const allTrades=await fetchMyTrades(p.symbolFull,p.ts_ms-30000);
              if(!allTrades?.length) return {status:'no_trades_found'};
              entryFills=allTrades.filter(t=>t.time>=p.ts_ms-15000&&t.time<p.ts_ms+10*60*1000&&(p.side==='long'?t.isBuyer:!t.isBuyer));
              if(!entryFills.length) return {status:'entry_not_found'};
              const firstEntryTime=Math.min(...entryFills.map(t=>t.time));
              exitFills=allTrades.filter(t=>t.time>firstEntryTime&&(p.side==='long'? !t.isBuyer:t.isBuyer));
              if(!exitFills.length) return {status:'exit_not_found'};
            }
            const aggregateFills=async(fills)=>{
              let totalQty=0,totalValue=0,totalFeesQuote=0,makerQty=0;
              for(const fill of fills){
                const qty=parseFloat(fill.qty),price=parseFloat(fill.price);
                totalQty+=qty; totalValue+=qty*price;
                if(fill.commissionAsset===p.quote){ totalFeesQuote+=parseFloat(fill.commission); }
                else {
                  const rate=await getConversionRate(fill.commissionAsset,p.quote||'USDT');
                  if(rate) totalFeesQuote+=parseFloat(fill.commission)*rate;
                }
                const isMaker=(fill.isMaker??fill.maker); if(isMaker) makerQty+=qty;
              }
              return{vwap:totalQty>0?totalValue/totalQty:0,totalQty,totalFeesQuote,makerRatio:totalQty>0?makerQty/totalQty:0};
            };
            const entryAgg=await aggregateFills(entryFills);
            const exitAgg =await aggregateFills(exitFills);
            if(entryAgg.totalQty<=0||exitAgg.totalQty<=0) return {status:'zero_qty'};
            if(Math.abs(entryAgg.totalQty-exitAgg.totalQty)/Math.max(1,entryAgg.totalQty)>0.05) return {status:'qty_mismatch'};
            const ret=p.side==='long'?(exitAgg.vwap/entryAgg.vwap-1):(entryAgg.vwap/exitAgg.vwap-1);
            const fees_bps=(entryAgg.totalFeesQuote+exitAgg.totalFeesQuote)/(entryAgg.vwap*entryAgg.totalQty)*10000;
            const pnl_bps=Math.round(ret*10000-fees_bps);
            const slip_realized_bps=(p.entry_mid>0)?Math.round(((p.side==="long"?entryAgg.vwap-p.entry_mid:p.entry_mid-entryAgg.vwap)/p.entry_mid)*10000):null;
            const ts_entry_ms=Math.min(...entryFills.map(t=>t.time));
            const ts_exit_ms =Math.max(...exitFills.map(t=>t.time));
            const closedRec={...p,reconciliation_method:'api',ts_entry_ms,ts_exit_ms,price_entry:entryAgg.vwap,price_exit:exitAgg.vwap,qty:entryAgg.totalQty,pnl_bps,fees_bps:Math.round(fees_bps),slip_realized_bps,maker_taker_entry:entryAgg.makerRatio>0.5?'maker':'taker',maker_taker_exit:exitAgg.makerRatio>0.5?'maker':'taker',hold_time_sec:Math.round((ts_exit_ms-ts_entry_ms)/1000),raw_api_data:{entry:entryFills,exit:exitFills}};
            return {status:'reconciled',closedRec,fingerprint:getTradeFingerprint(closedRec)};
          }
          async function reconcileViaCandles(p) {
            const now=Date.now();
            const ttl_ts_ms=p.ttl_ts_ms||(p.ts_ms+(p.hold_sec||0)*1000);
            if(now<ttl_ts_ms+5000) return {status:'still_pending'};
            const k=await fetchK(p.symbolFull,"1m",1000,p.ts_ms-60*1000,ttl_ts_ms+120*1000);
            if(!k||k.length<2) return {status:'no_candles'};
            const ts=k.map(x=>+x[0]), highs=k.map(x=>+x[2]), lows=k.map(x=>+x[3]), closes=k.map(x=>+x[4]);
            const long=p.side==="long", entry=p.entry_limit, {tp_abs,sl_abs}=p;
            let iFill=-1;
            for(let i=0;i<k.length;i++){
              if(ts[i]>=p.ts_ms-1000&&ts[i]<=ttl_ts_ms&&(long?(lows[i]<=entry):(highs[i]>=entry))){ iFill=i; break; }
            }
            if(iFill===-1) return {status:'no_fill'};
            const ts_entry_ms=ts[iFill];
            let exit_px=closes.at(-1), exit_reason="ttl", ts_exit_ms=ttl_ts_ms, iExit=k.length-1;
            for(let i=iFill;i<k.length;i++){
              if(ts[i]>ttl_ts_ms){ iExit=i-1; break; }
              if(long?(highs[i]>=tp_abs):(lows[i]<=tp_abs)){ exit_px=tp_abs; exit_reason="tp"; ts_exit_ms=ts[i]; iExit=i; break; }
              if(long?(lows[i]<=sl_abs):(highs[i]>=sl_abs)){ exit_px=sl_abs; exit_reason="sl"; ts_exit_ms=ts[i]; iExit=i; break; }
            }
            const ret=long?(exit_px/entry-1):(entry/exit_px-1);
            const pnl_bps=Math.round(ret*10000)-(p.cost_bps||COST_BPS);
            let mfe=0,mae=0,ts_mfe=null,ts_mae=null;
            for(let i=iFill;i<=iExit;i++){
              const mfe_p=long?((highs[i]/entry)-1)*10000:((entry/lows[i])-1)*10000;
              const mae_p=long?((lows[i]/entry)-1)*10000:((entry/highs[i])-1)*10000;
              if(mfe_p>mfe){mfe=mfe_p;ts_mfe=ts[i];}
              if(mae_p<mae){mae=mae_p;ts_mae=ts[i];}
            }
            const closedRec={...p,reconciliation_method:'candles',ts_entry_ms,ts_exit_ms,price_entry:entry,price_exit:exit_px,exit_reason,pnl_bps,qty:p.notional_usd/entry,hold_time_sec:Math.round((ts_exit_ms-ts_entry_ms)/1000),MFE_bps:Math.round(mfe),MAE_bps:Math.round(mae),ts_mfe_ms:ts_mfe,ts_mae_ms:ts_mae};
            return {status:'reconciled',closedRec,fingerprint:getTradeFingerprint(closedRec)};
          }
          async function heartbeatCheck(state) {
            if(!MEXC_API_KEY||!state.pending?.length) return {mismatches:0,zombies:[]};
            log("Running heartbeat check against open orders...");
            const symbols=[...new Set(state.pending.map(p=>p.symbolFull))];
            const openOrderClientIds=new Set();
            for(const sym of symbols){ const orders=await fetchOpenOrders(sym); if(orders) orders.forEach(o=>openOrderClientIds.add(o.clientOrderId)); await sleep(200); }
            let mismatches=0; const zombies=[]; const now=Date.now();
            for(const p of state.pending){
              const isExpired=now>(p.ttl_ts_ms||0);
              const idToCheck=p.client_order_id||p.idea_id;
              if(!isExpired&&!openOrderClientIds.has(idToCheck)){
                mismatches++; const zombieInfo=`Zombie: Pending idea ${idToCheck} for ${p.symbolFull} not found in open orders.`;
                log(`Heartbeat Mismatch: ${zombieInfo}`);
                zombies.push({idea_id:p.idea_id,client_order_id:idToCheck,symbol:p.symbolFull});
              }
            }
            if(mismatches>0) log(`Heartbeat Warning: Found ${mismatches} zombie pending ideas.`);
            return {mismatches,zombies};
          }

          // ---------- Active Hours (optional) ----------
          function inActiveUTC() {
            if(!ACTIVE_UTC_START || !ACTIVE_UTC_END) return true;
            const now = new Date(); const hh = now.getUTCHours(); const mm = now.getUTCMinutes();
            const toMin=(s)=>{ const [h,m]=s.split(":").map(n=>parseInt(n,10)); return (h*60 + (m||0)); };
            const cur = hh*60 + mm, s = toMin(ACTIVE_UTC_START), e = toMin(ACTIVE_UTC_END);
            if (s===e) return true; // full day
            if (s<e) return cur>=s && cur<e;
            return cur>=s || cur<e; // overnight window
          }

          // ---------- MAIN ----------
          (async function main() {
            try{
              await resolveSupportedTFs();

              const { state, persist } = await loadState();
              const { newAuditLogs, disagreementLogs } = await reconcileAndUpdateState(state);
              const heartbeat = await heartbeatCheck(state);

              const booksRaw=await getJSON(api("/api/v3/ticker/bookTicker"),10000,2) || [];
              const bookMap=new Map(booksRaw.map(b=>[b.symbol,{ bid:+b.bidPrice, ask:+b.askPrice }]));

              const all24hr = await getJSON(api("/api/v3/ticker/24hr"),10000,2) || [];
              const all=[];
              for(const t of all24hr){
                const sq=split(t.symbol);
                const qv=+t.quoteVolume;
                if(sq && !STABLES.has(sq.base) && isFinite(qv) && qv>0) {
                  if (MIN_QV_USD>0 && qv < MIN_QV_USD) continue;
                  all.push({ symbol:t.symbol, base:sq.base, quote:sq.quote, qv });
                }
              }
              all.sort((a,b)=>b.qv-a.qv);
              const universe=all.slice(0,120);
              log("Universe size:", universe.length);

              // If outside active hours, only reconcile/audit and send heartbeat payload with 0 picks
              if (!inActiveUTC()) {
                await saveAuditFiles(persist, state, newAuditLogs, disagreementLogs);
                const payload={ ts:new Date().toISOString(),mode:"inactive_hours",source:"external_pusher",meta:{origin:"github_actions",reason:"inactive_utc", counts:{universe:universe.length,refined:0,selected:0}, heartbeat:{mismatches:heartbeat.mismatches}},top_n:0,ideas:[] };
                if (PUSH_URL&&PUSH_TOKEN) { await fetchWithTimeout(PUSH_URL,{ method:"POST", headers:{"Content-Type":"application/json", "Authorization":"Bearer "+PUSH_TOKEN}, body:JSON.stringify(payload)}); }
                return;
              }

              const picksRaw=[]; const B=8; // gentler on rate limits
              let btc_adx = 0;
              const kBTC1H = await fetchK("BTCUSDT", "1h", 100);
              if (Array.isArray(kBTC1H) && kBTC1H.length >= ADX_PERIOD + 2) {
                const h = kBTC1H.map(k => +k[2]), l = kBTC1H.map(k => +k[3]), c = kBTC1H.map(k => +k[4]);
                btc_adx = (computeADX_ATR(h, l, c, ADX_PERIOD) || {}).adx || 0;
              }

              for(let i=0; i<universe.length; i+=B){
                const batch=await Promise.all(universe.slice(i,i+B).map(async c=>{
                  try{
                    if(state.cooldown?.[c.base] && (Date.now()-state.cooldown[c.base])<COOLDOWN_MS) return null;
                    const book=bookMap.get(c.symbol); if(!book?.bid||!book?.ask) return null;
                    const spreadBps=Math.round(((book.ask-book.bid)/book.bid)*10000);
                    if (spreadBps > MAX_SPREAD_BPS) return null;
                    const vol1h = c.qv/24;
                    if (MIN_VOL_1H_USD > 0 && vol1h < MIN_VOL_1H_USD) return null;

                    const mtfData = await fetchKlinesMTF(c.symbol); if (!mtfData || Object.keys(mtfData).length===0) return null;
                    const mtfInd = computeMTFIndicators(mtfData, TF_WEIGHTS, RSI_PERIOD, ADX_PERIOD, ROC_SHORT_BARS, ROC_MED_BARS);
                    if (!mtfInd || mtfInd.tfAlign < MIN_TF_ALIGN) return null;

                    const { highs: h5, lows: l5, c_kalman: c5, volumes: v5 } = mtfData['5m'] || {};
                    if (!c5?.length || !h5?.length || !l5?.length || !v5?.length) return null;
                    const { atr: atr5m } = computeADX_ATR(h5, l5, c5, ADX_PERIOD) || {};
                    const z_vwap = (c5.at(-1) - vwapAnchored(h5, l5, c5, v5, 36)) / Math.max(1e-9, (atr5m || 1));

                    const mrLocked = (Date.now()<(state.mr_lockout?.[c.symbol]||0));
                    const features = { ...mtfInd, z_vwap, spread_bps: spreadBps, slip_est_bps: 0, obi: 0, btc_adx };
                    return { c, features, mrLocked, mtfData, vol1h_est_usd: vol1h };
                  } catch { return null; }
                }));
                for(const x of batch) if(x) picksRaw.push(x);
                await sleep(3500);
              }

              const refined=[];
              for(const p of picksRaw){
                try{
                  const c=p.c; const book=bookMap.get(c.symbol); const mid=(+book.bid+ +book.ask)/2;
                  const depth=await getJSON(api("/api/v3/depth",{symbol:c.symbol,limit:DEPTH_LIMIT}));
                  if(!depth?.bids?.length || !depth?.asks?.length) continue;

                  const { bidsUSD, asksUSD } = depthWithinPctUSD(depth, mid);
                  const d1p = Math.min(bidsUSD, asksUSD);
                  if (DEPTH_1P_MIN_USD > 0 && d1p < DEPTH_1P_MIN_USD) continue;

                  const { slip_bps: slipL } = slipFromDepth(depth,mid,"long",NOTIONAL);
                  const { slip_bps: slipS } = slipFromDepth(depth,mid,"short",NOTIONAL);

                  const features = { ...p.features, slip_est_bps: Math.round(((slipL||0)+(slipS||0))/2), obi: computeOBI(depth, OBI_TOPN) };
                  const regime=p.mrLocked?"trend":"meanrevert";

                  const pLong0 = predictWithFeatures(getFeatureCoeffs(state,c.base,"long",regime), features);
                  const pShort0 = 1 - predictWithFeatures(getFeatureCoeffs(state,c.base,"short",regime), features);
                  const pLong_lcb = wilsonLCB(pLong0, getFeatureCoeffs(state,c.base,"long",regime).n+10);
                  const pShort_lcb = wilsonLCB(pShort0, getFeatureCoeffs(state,c.base,"short",regime).n+10);

                  const infl = (state.cost_model.slip_inflation_factor||1);
                  const costLong = COST_BPS + (slipL||0) * infl;
                  const costShort= COST_BPS + (slipS||0) * infl;
                  if (costLong > MAX_COST_BPS_HARD && DIRECTION!=="short") continue;
                  if (costShort> MAX_COST_BPS_HARD && DIRECTION!=="long") continue;

                  const ar=state.adaptive_exits[regime]||{n:0};
                  let candLong=null, candShort=null;

                  if(DIRECTION!=="short"){
                    let tp=ar.n>10?(ar.mfe_sum/ar.n)*0.7:features.atr_bps*0.9;
                    let sl=ar.n>10?(ar.mae_sum/ar.n)*-1.2:features.atr_bps*0.5;
                    const evLCB=Math.round(pLong_lcb*tp-(1-pLong_lcb)*sl-costLong);
                    if(evLCB > EXP_LCB_MIN_BPS) candLong={side:"long",p_lcb:pLong_lcb,exp_lcb_bps:evLCB,tp_bps:tp,sl_bps:sl,cost_bps:costLong};
                  }
                  if(DIRECTION!=="long"){
                    let tp=ar.n>10?(ar.mfe_sum/ar.n)*0.7:features.atr_bps*0.9;
                    let sl=ar.n>10?(ar.mae_sum/ar.n)*-1.2:features.atr_bps*0.5;
                    const evLCB=Math.round(pShort_lcb*tp-(1-pShort_lcb)*sl-costShort);
                    if(evLCB > EXP_LCB_MIN_BPS) candShort={side:"short",p_lcb:pShort_lcb,exp_lcb_bps:evLCB,tp_bps:tp,sl_bps:sl,cost_bps:costShort};
                  }
                  const chosen=candLong&&candShort?(candLong.exp_lcb_bps>=candShort.exp_lcb_bps?candLong:candShort):(candLong||candShort||null);
                  if(!chosen) continue;

                  refined.push({...chosen, symbol:c.symbol, base:c.base, features, p, entry_mid:mid, regime});
                } catch(e) { log("refine warn", e?.message||e); }
              }

              const picks=refined
                .sort((a,b)=>b.exp_lcb_bps-a.exp_lcb_bps)
                .slice(0,TOP_N)
                .map((x)=>{
                  const p=x.p, idea_id=genUUID(), decisionTs=Date.now(), mid=x.entry_mid;
                  let entry_limit=null,tp_abs=null,sl_abs=null;
                  if(mid){
                    const slF=x.sl_bps/10000, tpF=x.tp_bps/10000;
                    if(x.side==="long"){ entry_limit=mid*(1-0.0002); tp_abs=entry_limit*(1+tpF); sl_abs=entry_limit*(1-slF); }
                    else { entry_limit=mid*(1+0.0002); tp_abs=entry_limit*(1-tpF); sl_abs=entry_limit*(1+slF); }
                  }
                  const c5 = p.mtfData?.['5m']?.c_kalman || [];
                  const ema21=ema(c5,21)||0, ema50=ema(c5,50)||0;
                  const slope=slopeBps(c5);
                  const trend_dir = (ema21>ema50&&x.features.adx>20)?"up":(ema21<ema50&&x.features.adx>20)?"down":"flat";
                  const trend5m = { tf:"5m",dir:trend_dir,adx:+x.features.adx.toFixed(1),slope_bps:slope,rsi:+x.features.rsi.toFixed(1) };
                  const predicted = { ts_ms:decisionTs, side:x.side, p_cal:x.p_lcb, ev_bps:x.exp_lcb_bps, confidence_score:Math.round(x.p_lcb*100), features:x.features, context:{trend5m}, meta:{schema_version:SCHEMA_VERSION,strategy_name:STRATEGY_NAME,model_version:MODEL_VERSION,git_sha:GIT_SHA,config_hash:CONFIG_HASH} };
                  return { idea_id, client_order_id:idea_id, decision_ts_ms:decisionTs, symbol:x.base, symbol_full:x.symbol, side:x.side, predicted, ...x, entry_limit, tp_abs, sl_abs };
                });

              const nowMs=Date.now();
              for(const p of picks){
                state.cooldown[p.symbol]=nowMs;
                const parts=split(p.symbol_full);
                state.pending.push({
                  idea_id:p.idea_id, client_order_id:p.client_order_id, decision_ts_ms:p.decision_ts_ms, ts_ms:nowMs,
                  ttl_ts_ms:nowMs+(p.ttl_sec||TTL_MIN)*1000,
                  symbolFull:p.symbol_full, base:p.base, quote:parts?.quote||"USDT",
                  side:p.side, entry_mid:p.entry_mid, entry_limit:p.entry_limit, tp_abs:p.tp_abs, sl_abs:p.sl_abs,
                  p_lcb:p.p_lcb, p_raw:p.predicted?.p_raw, calib_key:p.calib_key, regime:p.regime, predicted:p.predicted,
                  notional_usd:NOTIONAL, cost_bps:p.cost_bps
                });
              }

              await saveAuditFiles(persist, state, newAuditLogs, disagreementLogs);
              const payload={ ts:new Date().toISOString(),mode:"normal",source:"external_pusher",meta:{origin:"github_actions",reason:"ok", counts:{universe:universe.length,refined:refined.length,selected:picks.length}, heartbeat:{mismatches:heartbeat.mismatches}},top_n:picks.length||0,ideas:picks||[] };
              log(`Pushing ${picks.length} ideas. Heartbeat mismatches: ${heartbeat.mismatches}`);
              if (PUSH_URL&&PUSH_TOKEN) { await fetchWithTimeout(PUSH_URL,{ method:"POST", headers:{"Content-Type":"application/json", "Authorization":"Bearer "+PUSH_TOKEN}, body:JSON.stringify(payload)}); }
            } catch (e) {
              log("Critical error:", e?.message||e);
              const payload={ts:new Date().toISOString(),meta:{origin:"github_actions",reason:"error",error:e?.message||String(e)},top_n:0,ideas:[]};
              if(PUSH_URL&&PUSH_TOKEN){await fetchWithTimeout(PUSH_URL,{method:"POST",headers:{"Content-Type":"application/json","Authorization":"Bearer "+PUSH_TOKEN},body:JSON.stringify(payload)});}
            }
          })();
          })();
          NODE
          EXIT_CODE=$?

          # Shell-level fallback (in case node crashed before posting)
          set -e
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo "[gha] pusher exited with code $EXIT_CODE — sending minimal payload"
            raw_push_url="$(printf '%s' "${WORKER_PUSH_URL}" | tr -d '\r\n')"
            now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            payload='{"ts":"'"${now}"'","mode":"normal","source":"external_pusher","meta":{"origin":"github_actions","reason":"fallback_node_error"},"top_n":0,"ideas":[]}'
            echo "[gha] pushing 0 ideas to ${raw_push_url}"
            http_code=$(curl -g -sS -o /dev/null -w "%{http_code}" -X POST -H "Content-Type: application/json" -H "Authorization: Bearer ${PUSH_TOKEN}" --data-raw "${payload}" --max-time 12 "${raw_push_url}" || true)
            echo "[gha] push status ${http_code}"
            exit 0
          fi
