(async ()=>{
  'use strict';

  // ---------------- Utils ----------------
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const tanh=(x)=>Math.tanh(x);
  const sum=(a)=>a.reduce((x,y)=>x+y,0);
  const mean=(a)=>a.length?sum(a)/a.length:0;
  const std=(a)=>{ const m=mean(a); let v=0; for(const x of a)v+=(x-m)*(x-m); return a.length>1?Math.sqrt(v/(a.length-1)):0; };
  const ema=(arr,p)=>{ if(!arr||arr.length<p) return null; const k=2/(p+1); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; for(let i=p;i<arr.length;i++) e=arr[i]*k+e*(1-k); return e; };
  const emaSeries=(arr,p)=>{ if(!arr||arr.length<p) return null; const k=2/(p+1); const out=Array(arr.length).fill(null); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; out[p-1]=e; for(let i=p;i<arr.length;i++){ e=arr[i]*k+e*(1-k); out[i]=e; } return out; };
  const rsi=(cl,p=14)=>{ if(!cl||cl.length<=p) return null; let g=0,l=0; for(let i=1;i<=p;i++){ const d=cl[i]-cl[i-1]; g+=Math.max(0,d); l+=Math.max(0,-d); } let ag=g/p, al=l/p; for(let i=p+1;i<cl.length;i++){ const d=cl[i]-cl[i-1]; ag=(ag*(p-1)+Math.max(0,d))/p; al=(al*(p-1)+Math.max(0,-d))/p; } const rs=al===0?100:ag/al; return 100-100/(1+rs); };
  const computeADX_ATR=(h,l,c,p=14)=>{ const n=c.length; if(n<p+2) return null; const TR=[],plusDM=[],minusDM=[];
    for(let i=1;i<n;i++){ const up=h[i]-h[i-1], down=l[i-1]-l[i]; plusDM.push((up>down&&up>0)?up:0); minusDM.push((down>up&&down>0)?down:0);
      TR.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1]))); }
    let trN=0,pdmN=0,ndmN=0; for(let i=0;i<p;i++){ trN+=TR[i]; pdmN+=plusDM[i]; ndmN+=minusDM[i]; }
    let pDI=100*(pdmN/(trN||1)), nDI=100*(ndmN/(trN||1)); let dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1), adx=dx;
    for(let i=p;i<TR.length;i++){ trN=trN-(trN/p)+TR[i]; pdmN=pdmN-(pdmN/p)+plusDM[i]; ndmN=ndmN-(ndmN/p)+minusDM[i];
      pDI=100*(pdmN/(trN||1)); nDI=100*(ndmN/(trN||1)); dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1); adx=((adx*(p-1))+dx)/p; }
    const atr=trN/p; return { adx, atr, trLast: TR.at(-1) };
  };
  const vwapAnchored=(h,l,c,v,win)=>{ if(!c?.length) return null; const n=c.length,s=Math.max(0,n-win); let pv=0,vv=0; for(let i=s;i<n;i++){ const tp=(h[i]+l[i]+c[i])/3; const vol=+v[i]||0; pv+=tp*vol; vv+=vol; } return vv>0?pv/vv:c.at(-1); };
  const corr=(a,b)=>{ const n=Math.min(a?.length||0,b?.length||0); if(n<5) return 0; const as=a.slice(-n), bs=b.slice(-n); const ma=mean(as), mb=mean(bs); let num=0,da=0,db=0; for(let i=0;i<n;i++){ const xa=as[i]-ma, xb=bs[i]-mb; num+=xa*xb; da+=xa*xa; db+=xb*xb; } const den=Math.sqrt(da*db)||1; return num/den; };
  const wilsonLCB=(p,n,z=1.34)=>{ if(n<=0) return p; const z2=z*z; const a=p + z2/(2*n); const b=z*Math.sqrt((p*(1-p)+z2/(4*n))/n); const c=1+z2/n; return clamp((a-b)/c, 0, 1); };
  const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
  const jitter=(ms)=>ms + Math.floor(Math.random()*ms*0.25);
  const softmax=(arr,t=20)=>{ const m=Math.max(...arr,0); const ex=arr.map(x=>Math.exp((x-m)/t)); const s=ex.reduce((a,b)=>a+b,0)||1; return ex.map(x=>x/s); };
  const sigmoid=(z)=>1/(1+Math.exp(-z));
  const logit=(p)=>Math.log((p+1e-12)/(1-(p-1e-12)));

  // RNG
  let bmSpare=null;
  const randn=()=>{ if(bmSpare!=null){ const v=bmSpare; bmSpare=null; return v; } let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); const r=Math.sqrt(-2*Math.log(u)); const th=2*Math.PI*v; bmSpare=r*Math.sin(th); return r*Math.cos(th); };
  function randt(df){ if(df<=2) df=2.01; const z=randn(); let x2=0; for(let i=0;i<Math.floor(df);i++){ const z2=randn(); x2+=z2*z2; } const frac=df-Math.floor(df); if(frac>0){ const zf=randn(); x2+=frac*zf*zf; } const chi=x2||1e-6; return z / Math.sqrt(chi/df); }

  // IO snapshot for counts
  const fs = require('fs');
  function snapCounts(partial){
    try{
      const prev = fs.existsSync('/tmp/pusher_counts.json')
        ? JSON.parse(fs.readFileSync('/tmp/pusher_counts.json','utf8')||'{}')
        : {};
      const next = { ...prev, ...partial };
      fs.writeFileSync('/tmp/pusher_counts.json', JSON.stringify(next));
    }catch{}
  }

  // Kalman (1D RW)
  function kalman1D(obs,{q=1e-5,r=1e-3,x0=null,p0=1e-2}={}){
    if(!obs?.length) return [];
    let x=(x0==null?obs[0]:x0), p=p0;
    const out=[];
    for(const z of obs){
      p+=q;
      const K=p/(p+r);
      x=x + K*(z-x);
      p=(1-K)*p;
      out.push(x);
    }
    return out;
  }

  // ---- Crypto + stable stringify for hashes ----
  const crypto = require('crypto');
  const stableStringify=(obj)=>{
    const seen=new WeakSet();
    const sort=(v)=>{
      if(v===null||typeof v!=='object') return v;
      if(seen.has(v)) return null;
      seen.add(v);
      if(Array.isArray(v)) return v.map(sort);
      const keys=Object.keys(v).sort();
      const o={}; for(const k of keys) o[k]=sort(v[k]); return o;
    };
    return JSON.stringify(sort(obj));
  };
  const sha256Hex=(s)=>crypto.createHash('sha256').update(String(s)).digest('hex');

  // ------------- GP Classification (Laplace) -------------
  function pairwiseD2(X, Y){
    const n=X.length, m=Y.length, d=X[0]?.length||0;
    const M=Array.from({length:n},()=>Array(m).fill(0));
    for(let i=0;i<n;i++) for(let j=0;j<m;j++){ let s=0; for(let k=0;k<d;k++){ const dv=X[i][k]-Y[j][k]; s+=dv*dv; } M[i][j]=s; }
    return M;
  }
  function medianPairwiseDist(X){
    const n=X.length; if(n<2) return 1;
    const idx=[]; for(let i=0;i<n;i+=Math.max(1,Math.floor(n/20))) idx.push(i);
    const d=[]; for(let i=0;i<idx.length;i++) for(let j=i+1;j<idx.length;j++){ const a=X[idx[i]], b=X[idx[j]]; let s=0; for(let k=0;k<a.length;k++){ const dv=a[k]-b[k]; s+=dv*dv; } d.push(Math.sqrt(s)); }
    d.sort((a,b)=>a-b); return d[Math.floor(d.length/2)]||1;
  }
  function rbfKernel(X, Y, ell){
    const inv2l2 = 1/(2*Math.max(1e-9, ell*ell));
    const D2=pairwiseD2(X,Y);
    const K=Array.from({length:D2.length},()=>Array(D2[0].length).fill(0));
    for(let i=0;i<D2.length;i++) for(let j=0;j<D2[0].length;j++) K[i][j]=Math.exp(-D2[i][j]*inv2l2);
    return { K, inv2l2 };
  }
  function cholesky(A){
    const n=A.length; const L=Array.from({length:n},()=>Array(n).fill(0));
    for(let i=0;i<n;i++){
      for(let j=0;j<=i;j++){
        let s=0; for(let k=0;k<j;k++) s+=L[i][k]*L[j][k];
        const v=A[i][j]-s;
        if(i===j){ if(v<=1e-12) return null; L[i][j]=Math.sqrt(Math.max(v,1e-12)); }
        else { L[i][j]=v/(L[j][j]||1e-12); }
      }
    }
    return L;
  }
  function solveChol(L, b){
    const n=L.length, y=Array(n).fill(0), x=Array(n).fill(0);
    for(let i=0;i<n;i++){ let s=0; for(let k=0;k<i;k++) s+=L[i][k]*y[k]; y[i]=(b[i]-s)/(L[i][i]||1e-12); }
    for(let i=n-1;i>=0;i--){ let s=0; for(let k=i+1;k<n;k++) s+=L[k][i]*x[k]; x[i]=(y[i]-s)/(L[i][i]||1e-12); }
    return x;
  }
  function trainGPClass(X, y01, lam=0.10, iters=10){
    const n=X.length; if(n===0) return null;
    const ell = medianPairwiseDist(X) || 1;
    const { K } = rbfKernel(X, X, ell);
    for(let i=0;i<n;i++) K[i][i]+=lam;
    let f=Array(n).fill(0);
    for(let it=0; it<iters; it++){
      const pi=f.map(sigmoid);
      const W=pi.map(p=> p*(1-p)+1e-6), Winv=W.map(w=>1/(w||1e-6));
      const A=Array.from({length:n},(_,i)=> K[i].map((v,j)=> v + (i===j?Winv[i]:0)));
      const ypi=y01.map((yy,i)=> yy - pi[i]);
      const b=Array(n).fill(0); for(let i=0;i<n;i++){ let s=0; for(let j=0;j<n;j++) s+=K[i][j]*ypi[j]; b[i]=s - f[i]; }
      const L=cholesky(A); if(!L) break;
      const h=solveChol(L,b); let maxStep=0; for(let i=0;i<n;i++){ f[i]+=h[i]; maxStep=Math.max(maxStep,Math.abs(h[i])); } if(maxStep<1e-4) break;
    }
    const pi=f.map(sigmoid), W=pi.map(p=> p*(1-p)+1e-6), Winv=W.map(w=>1/(w||1e-6));
    const A=Array.from({length:n},(_,i)=> K[i].map((v,j)=> v + (i===j?Winv[i]:0)));
    const L=cholesky(A); if(!L) return null;
    return { X, y:y01, K, L, f, pi, ell };
  }
  function predictGPClass(model, x){
    if(!model) return { p:0.5, s2:0.2 };
    const { X, L, pi, y, ell } = model;
    const inv2l2=1/(2*ell*ell);
    let kstar=Array(X.length).fill(0);
    for(let i=0;i<X.length;i++){ let d2=0; for(let k=0;k<X[i].length;k++){ const dv=X[i][k]-x[k]; d2+=dv*dv; } kstar[i]=Math.exp(-d2*inv2l2); }
    let m=0; for(let i=0;i<X.length;i++) m+=kstar[i]*((y[i]||0)-(pi[i]||0));
    const v=solveChol(L,kstar); let vtv=0; for(const vi of v) vtv+=vi*vi;
    const s2=Math.max(1e-6,1-vtv); const scale=Math.sqrt(1+(Math.PI*s2/8)); const p=sigmoid(m/scale);
    return { p:clamp(p,0.01,0.99), s2 };
  }
  const gpClfHash=(m)=>{
    if(!m) return null;
    const diag=(m.L||[]).map((r,i)=>r[i]).slice(0,16).map(x=>+x||0);
    const meta={ ell:+(m.ell||0), nX:m.X?.length||0, L_diag:diag };
    return "sha256:"+sha256Hex(stableStringify(meta));
  };

  // ------------- Calibration (Platt / Isotonic) -------------
  const sigmoidF=(a,b,z)=>1/(1+Math.exp(-(a*z+b)));
  const logitF=(p)=>Math.log((p+1e-12)/(1-(p-1e-12)));
  function fitPlatt(p,y){ const eps=1e-6, z=p.map(pp=> clamp(pp,eps,1-eps)).map(logitF); let a=1,b=0; const lr=0.05,it=400,l2=0.01;
    for(let t=0;t<it;t++){ let ga=0,gb=0; for(let i=0;i<y.length;i++){ const s=sigmoidF(a,b,z[i]), e=s-y[i]; ga+=e*z[i]; gb+=e; } ga+=l2*a; gb+=l2*b; a-=lr*ga/y.length; b-=lr*gb/y.length; }
    return {a,b,n:y.length}; }
  function applyPlatt(p,ab){ const {a,b}=ab||{a:1,b:0}; return p.map(pi=> sigmoidF(a,b, logitF(clamp(pi,1e-6,1-1e-6)) )); }
  function fitIsotonic(p,y){ const idx=[...p.keys()].sort((i,j)=>p[i]-p[j]); const xs=[],ys=[]; for(const i of idx){ xs.push(p[i]); ys.push(y[i]); }
    const n=xs.length,g=ys.slice(),w=Array(n).fill(1); for(let i=0;i<n-1;i++){ if(g[i]>g[i+1]){ let j=i; while(j>=0 && g[j]>g[j+1]){ const ww=w[j]+w[j+1], gg=(w[j]*g[j]+w[j+1]*g[j+1])/ww; w[j]=ww; g[j]=gg; xs.splice(j,2,(xs[j])); ys.splice(j,2,(gg)); g.splice(j+1,1); w.splice(j+1,1); if(j>0) j--; } } } return { xs, ys:g, n }; }
  function applyIsotonic(p,iso){ if(!iso?.xs?.length||!iso?.ys?.length) return p; const xs=iso.xs, ys=iso.ys; return p.map(val=>{ if(val<=xs[0]) return ys[0]; if(val>=xs[xs.length-1]) return ys[ys.length-1]; let lo=0,hi=xs.length-1; while(hi-lo>1){ const mid=((lo+hi)>>1); if(xs[mid]<=val) lo=mid; else hi=mid; } const t=(val-xs[lo])/Math.max(1e-9,(xs[hi]-xs[lo])); return ys[lo]+t*(ys[hi]-ys[lo]); }); }

  // ------------- Heavy-tail Monte Carlo (t + bootstrap) -------------
  function pathEVHeavy({entry,tp_bps,sl_bps,side,retSeries,mu,sigma,steps,N=192,cost_bps=10,t_df=5,boot_block=3}){
    const up=(side==="long"), tpF=tp_bps/10000, slF=sl_bps/10000; let ev=0, wins=0; const rets=retSeries||[];
    const boot1=()=>{ if(rets.length<8) return Array(steps).fill(0).map(()=> sigma*Math.sqrt(1/steps)*randn()); const out=[]; while(out.length<steps){ const start=Math.floor(Math.random()*(rets.length-boot_block)); for(let k=0;k<boot_block && out.length<steps;k++) out.push(rets[start+k]||0); } return out.slice(0,steps); };
    for(let n=0;n<N;n++){
      const mode=(n%2===0)?"t":"boot";
      let S=entry, tp=up? entry*(1+tpF):entry*(1-tpF), sl=up? entry*(1-slF):entry*(1+slF);
      let pnl_bps=0,win=0;
      const rs=(mode==="t")? Array(steps).fill(0).map(()=> mu + sigma*randt(t_df)/Math.sqrt(steps)) : boot1();
      for(let t=0;t<steps;t++){
        const r=rs[t];
        S=S*(1+r);
        if(up){ if(S>=tp){ pnl_bps=tp_bps-cost_bps; win=1; break;} if(S<=sl){ pnl_bps=-sl_bps-cost_bps; win=0; break;} }
        else { if(S<=tp){ pnl_bps=tp_bps-cost_bps; win=1; break;} if(S>=sl){ pnl_bps=-sl_bps-cost_bps; win=0; break;} }
        if(t===steps-1){ const ret=up? (S/entry-1):(entry/S-1); pnl_bps=Math.round(ret*10000)-cost_bps; win=pnl_bps>0?1:0; }
      }
      ev+=pnl_bps; wins+=win;
    }
    const p=wins/N, ev_mean=ev/N;
    return { p, ev_bps:Math.round(ev_mean) };
  }

  // ------------- t-copula VaR/ES -------------
  function choleskySafe(S){
    const L=cholesky(S);
    if(L) return L;
    const n=S.length;
    const Sc=S.map((r,i)=> r.map((v,j)=> v + (i===j?1e-6:0)));
    return cholesky(Sc);
  }
  function sampleMultiT(muVec,Sigma,df=6,M=1000){
    const n=muVec.length;
    const L=choleskySafe(Sigma); if(!L) return [];
    const out=[];
    for(let m=0;m<M;m++){
      const z=Array(n).fill(0).map(()=>randn());
      const y=Array(n).fill(0);
      for(let i=0;i<n;i++){ let s=0; for(let k=0;k<=i;k++) s+=L[i][k]*z[k]; y[i]=s; }
      let chi=0; for(let i=0;i<df;i++){ const zc=randn(); chi+=zc*zc; }
      const scale=Math.sqrt(df/Math.max(1e-9,chi));
      out.push(y.map((yi,i)=> (muVec[i]||0) + yi*scale));
    }
    return out;
  }
  function portfolioVaR_ES_tCopula(picks, df=6){
    if(!picks.length) return { VaR95_bps:0, ES95_bps:0 };
    const n=picks.length, mu=Array(n).fill(0), sd=Array(n).fill(0);
    for(let i=0;i<n;i++){
      const r5=picks[i].ret5||[]; const rMean=mean(r5), rStd=std(r5)||1e-4;
      const steps=Math.max(1, Math.round((picks[i].ttl_sec||600)/300));
      mu[i]=rMean*steps*10000;
      sd[i]=rStd*Math.sqrt(steps)*10000;
    }
    // Corr by Pearson (fallback); EWMA can override later
    const R=Array.from({length:n},()=>Array(n).fill(0));
    for(let i=0;i<n;i++){
      for(let j=0;j<n;j++) R[i][j]=corr(picks[i].ret5||[], picks[j].ret5||[]);
      R[i][i]=1;
    }
    const Sigma=Array.from({length:n},()=>Array(n).fill(0));
    for(let i=0;i<n;i++) for(let j=0;j<n;j++) Sigma[i][j]=R[i][j]*sd[i]*sd[j];

    const draws=sampleMultiT(mu,Sigma,df,1200);
    if(!draws.length) return { VaR95_bps:0, ES95_bps:0 };

    const w0=picks.map(p=> p.size_bps||0); const ws=sum(w0)||1; const w=w0.map(x=> x/ws);
    const port=draws.map(d=> d.reduce((acc,di,ii)=> acc + w[ii]*di, 0));
    port.sort((a,b)=>a-b);
    const idx=Math.floor(0.05*port.length);
    const VaR95=port[idx]||0;
    const ES=mean(port.slice(0,idx+1));
    return { VaR95_bps:Math.round(VaR95), ES95_bps:Math.round(ES) };
  }

  // ------------- Metrics / Calibration / Drift -------------
  function brier(y,p){ let s=0; for(let i=0;i<y.length;i++) s+=(y[i]-p[i])**2; return s/y.length; }
  function logloss(y,p){ const e=1e-12; let s=0; for(let i=0;i<y.length;i++){ const pp=clamp(p[i],e,1-e); s+=-(y[i]*Math.log(pp)+(1-y[i])*Math.log(1-pp)); } return s/y.length; }
  function auc(y,p){ const pos=[],neg=[]; for(let i=0;i<y.length;i++) (y[i]?pos:neg).push(p[i]); if(!pos.length||!neg.length) return NaN; let wins=0,ties=0; for(const a of pos) for(const b of neg){ if(a>b) wins++; else if(a===b) ties++; } const total=pos.length*neg.length; return (wins+0.5*ties)/total; }
  function pageHinkleyInit(){ return { mean:0, ph:0, minPH:0, alarms:0 }; }
  function pageHinkleyUpdate(st, x, delta=0.01, lambda=0.05){
    st.mean=st.mean+(x-st.mean)*0.01;
    const d=(x-st.mean)-delta;
    st.ph+=d;
    st.minPH=Math.min(st.minPH, st.ph);
    const stat=st.ph-st.minPH;
    const drift=stat>lambda;
    if(drift){ st.ph=0; st.minPH=0; st.alarms++; }
    return drift;
  }

  // ---------- Microstructure helpers ----------
  function computeOBI(depth, topN=12){
    if(!depth?.asks?.length || !depth?.bids?.length) return 0;
    const w=(i)=>Math.exp(-i*0.18);
    let bidNot=0, askNot=0;
    for(let i=0;i<Math.min(topN, depth.bids.length); i++){ const p=+depth.bids[i][0], q=+depth.bids[i][1]; if(p>0&&q>0) bidNot += p*q*w(i); }
    for(let i=0;i<Math.min(topN, depth.asks.length); i++){ const p=+depth.asks[i][0], q=+depth.asks[i][1]; if(p>0&&q>0) askNot += p*q*w(i); }
    return (bidNot+askNot>0) ? (bidNot-askNot)/(bidNot+askNot) : 0;
  }
  function depthWithinPctUSD(depth, mid, pct=0.01){
    if(!depth?.asks?.length || !depth?.bids?.length || !(mid>0)) return { bidsUSD:0, asksUSD:0 };
    const askLim=mid*(1+pct), bidLim=mid*(1-pct);
    let asksUSD=0, bidsUSD=0;
    for(const [ps,qs] of depth.asks){ const p=+ps, q=+qs; if(!(p>0&&q>0)) continue; if(p<=askLim) asksUSD += p*q; else break; }
    for(const [ps,qs] of depth.bids){ const p=+ps, q=+qs; if(!(p>0&&q>0)) continue; if(p>=bidLim) bidsUSD += p*q; else break; }
    return { bidsUSD, asksUSD };
  }
  function vwapFillLevels(levels,targetUSD){
    let remain=targetUSD,val=0,qty=0;
    for(const [ps,qs] of levels){
      const p=+ps, q=+qs; if(!(p>0&&q>0)) continue;
      const can=p*q, take=Math.min(remain,can), tq=take/p;
      val+=p*tq; qty+=tq; remain-=take; if(remain<=1e-6) break;
    }
    return { px: qty>0? val/qty : null, filledUSD: (targetUSD-remain) };
  }
  function slipFromDepth(depth, mid, side, notionalUSD){
    if(!depth?.asks?.length || !depth?.bids?.length || !(mid>0)) return { slip_bps:null, fill_prob:null };
    if(side==="long"){
      const buy=vwapFillLevels(depth.asks, Math.max(50,notionalUSD));
      const slip = buy.px? Math.max(0, Math.round((buy.px - mid)/mid*10000)) : null;
      const fill = Math.min(1, (buy.filledUSD||0)/Math.max(1,notionalUSD));
      return { slip_bps: slip, fill_prob: +fill.toFixed(4) };
    }else{
      const sell=vwapFillLevels(depth.bids, Math.max(50,notionalUSD));
      const slip = sell.px? Math.max(0, Math.round((mid - sell.px)/mid*10000)) : null;
      const fill = Math.min(1, (sell.filledUSD||0)/Math.max(1,notionalUSD));
      return { slip_bps: slip, fill_prob: +fill.toFixed(4) };
    }
  }

  // ---------- HTTP ----------
  const UA="gh-actions-ideas-mexc-ultimate/6.3-confidence (+https://github.com/)";
  async function fetchWithTimeout(url,opts={},ms=12000){ const ac=new AbortController(); const t=setTimeout(()=>ac.abort(),ms); try{ return await fetch(url,{...opts,signal:ac.signal,headers:{"User-Agent":UA,...(opts?.headers||{})}});} finally{ clearTimeout(t);} }
  async function getJSON(url,ms=12000,tries=2){ for(let a=0;a<tries;a++){ try{ const r=await fetchWithTimeout(url,{},ms); if(r?.ok){ return await r.json(); } }catch{} await sleep(jitter(220)); } return null; }

  // ---------- Concurrency + caches (NEW) ----------
  const cache = { k:new Map(), depth:new Map(), bt:new Map() };
  const TTL = { k: 60_000, depth: 8_000, bt: 5_000 };

  async function pool(n, items, fn){
    let i=0, active=0; const out=Array(items.length);
    return await new Promise(res=>{
      const step=()=>{
        if(i>=items.length && active===0) return res(out);
        while(active<n && i<items.length){
          const idx=i++, it=items[idx]; active++;
          fn(it).then(v=>out[idx]=v).catch(()=>out[idx]=null).finally(()=>{ active--; step(); });
        }
      };
      step();
    });
  }

  function getCached(map,key,ttl){ const e=map.get(key); return e && (Date.now()-e.ts<ttl)? e.v : null; }
  function setCached(map,key,v){ map.set(key,{ v, ts: Date.now() }); }

  async function getKCached(symbol, interval, limit, startTime, endTime){
    const key=[symbol,interval,limit,startTime||"",endTime||""].join("|");
    const c=getCached(cache.k,key,TTL.k); if(c) return c;
    const v=await fetchK(symbol,interval,limit,startTime,endTime);
    if(v) setCached(cache.k,key,v);
    return v;
  }
  async function getDepthCached(symbol){
    const c=getCached(cache.depth,symbol,TTL.depth); if(c) return c;
    const v=await fetchDepth(symbol); if(v) setCached(cache.depth,symbol,v); return v;
  }
  async function getBookTickerCached(symbol){
    const c=getCached(cache.bt,symbol,TTL.bt); if(c) return c;
    const v=await fetchBookTicker(symbol); if(v) setCached(cache.bt,symbol,v); return v;
  }
  async function getKMultiTF(symbol){
    const tfs=[["1m",240],["5m",300],["15m",300],["1h",300],["4h",300]];
    const ks=await pool(8, tfs, ([tf,lim])=>getKCached(symbol,tf,lim));
    const o={}; for(let i=0;i<tfs.length;i++) o[tfs[i][0]]=ks[i];
    return o;
  }

  // ---------- Heavy features + scoring (NEW) ----------
  function logistic(z){ return 1/(1+Math.exp(-z)); }
  function bucketize(p){
    const b=Math.floor(clamp(p,0,0.999)*20); const lo=(b/20).toFixed(2), hi=((b+1)/20).toFixed(2);
    return `${lo}-${hi}`;
  }
  // AR(2) via Yule–Walker (fast proxy)
  function ar2YW(x){
    const n=x?.length||0; if(n<20) return { phi:[0,0], sigma2:0, ok:false };
    const m=mean(x), y=x.map(v=>v-m);
    const r=(lag)=>{ let s=0, c=0; for(let i=lag;i<n;i++){ s+=y[i]*y[i-lag]; c++; } return c? s/c : 0; };
    const r0=r(0), r1=r(1), r2=r(2);
    const det=(r0*r0 - r1*r1)||1e-9;
    const phi1=(r1*r0 - r2*r1)/det, phi2=(r2*r0 - r1*r1)/det;
    const sigma2=Math.max(1e-9, r0 - phi1*r1 - phi2*r2);
    return { phi:[phi1,phi2], sigma2, ok:true };
  }
  // GARCH(1,1) lightweight moment-fit
  function garch11Fit(r, iters=25){
    if(!r?.length) return { omega:0, alpha:0.05, beta:0.9, ok:false };
    const e=r.map(v=>v-mean(r)); let omega=1e-6, alpha=0.06, beta=0.90;
    for(let k=0;k<iters;k++){
      let h=Array(e.length).fill(0), s2=Math.max(1e-9, mean(e.map(v=>v*v))||1e-6); h[0]=s2;
      for(let i=1;i<e.length;i++) h[i]=Math.max(1e-9, omega + alpha*e[i-1]*e[i-1] + beta*h[i-1]);
      const err=e.reduce((acc,ei,i)=>acc + Math.log(h[i]) + (ei*ei)/h[i], 0)/e.length;
      alpha=Math.min(0.25, Math.max(0.01, alpha*(err>0?0.985:1.015)));
      beta =Math.min(0.985, Math.max(0.70, beta *(err>0?0.985:1.015)));
      omega=Math.max(1e-9, (1-beta-alpha)*s2);
    }
    return { omega, alpha, beta, ok:true };
  }
  // Seasonality: hour-of-day mean return (UTC)
  function seasonalityTOD(returns, timestamps){
    const b=Array(24).fill(0).map(()=>({s:0,n:0}));
    for(let i=0;i<Math.min(returns.length, timestamps.length); i++){
      const h=new Date(timestamps[i]).getUTCHours(); b[h].s+=returns[i]; b[h].n++;
    }
    const mu=b.map(v=> v.n? v.s/v.n : 0);
    return { mu };
  }
  // Microprice + OFI proxy + book slope
  function microprice(bid, ask, qb, qa){ const d=(qb||1)+(qa||1); return (ask*qb + bid*qa)/d; }
  function ofiProxy(depthA, depthB){
    const lev=(side,d)=>d?.[side]?.slice(0,3).map(x=>+x[1]||0)||[];
    const sumA=(a)=>a.reduce((x,y)=>x+y,0);
    if(!depthA||!depthB) return 0;
    return (sumA(lev("bids",depthB))-sumA(lev("bids",depthA))) - (sumA(lev("asks",depthB))-sumA(lev("asks",depthA)));
  }
  function bookSlope(depth, mid){
    const toPts=(levels)=>{ let cum=0; const pts=[]; for(const [ps,qs] of (levels||[])){
      const p=+ps,q=+qs; if(!(p>0&&q>0)) continue; cum+=p*q;
      const x=Math.log(Math.abs(p-mid)/mid + 1e-6), y=Math.log(cum+1);
      pts.push([x,y]); if(pts.length>=10) break;
    } return pts; };
    if(!depth?.asks?.length||!depth?.bids?.length||!(mid>0)) return { slope:0, r2:0 };
    const pts=toPts(depth.asks).concat(toPts(depth.bids)); if(pts.length<6) return { slope:0, r2:0 };
    const xs=pts.map(p=>p[0]), ys=pts.map(p=>p[1]), mx=mean(xs), my=mean(ys);
    let num=0, den=0, vy=0; for(let i=0;i<xs.length;i++){ const dx=xs[i]-mx, dy=ys[i]-my; num+=dx*dy; den+=dx*dx; vy+=dy*dy; }
    return { slope: den>1e-9? num/den : 0, r2: den>1e-9 && vy>1e-9? +(num*num/(den*vy)).toFixed(3): 0 };
  }
  // EWMA correlation (optional)
  function ewmaVar(a, lambda=0.94){
    const T=a.length; if(T<2) return 0; const m=mean(a);
    let v=0, wsum=0; for(let t=T-1;t>=0;t--){ const wt=Math.pow(lambda, T-1-t); const d=a[t]-m; v+=wt*d*d; wsum+=wt; }
    return v/wsum;
  }
  function ewmaCorr(seriesArr, lambda=0.94){
    const n=seriesArr.length, T=Math.min(...seriesArr.map(a=>a.length)); if(n===0||T<5) return null;
    const S=Array.from({length:n},()=>Array(n).fill(0));
    const mu=seriesArr.map(a=> mean(a.slice(-T)));
    const w=[]; let wsum=0; for(let t=T-1;t>=0;t--){ const wt=Math.pow(lambda, T-1-t); w.push(wt); wsum+=wt; }
    const norm=1/wsum;
    for(let i=0;i<n;i++){
      for(let j=i;j<n;j++){
        let cov=0; for(let k=0;k<T;k++){ const xi=seriesArr[i][seriesArr[i].length-T+k]-mu[i]; const xj=seriesArr[j][seriesArr[j].length-T+k]-mu[j]; cov+=w[k]*xi*xj; }
        cov*=norm;
        const si=Math.sqrt(Math.max(1e-9, ewmaVar(seriesArr[i].slice(-T), lambda)));
        const sj=Math.sqrt(Math.max(1e-9, ewmaVar(seriesArr[j].slice(-T), lambda)));
        const rij = (si>0 && sj>0)? (cov/(si*sj)) : 0;
        S[i][j]=S[j][i]=clamp(rij,-1,1);
      }
    }
    return S;
  }
  // Confidence + reasons
  function confidenceScore({ p_cal, ev_bps, atr_bps, micro, regime, reliability, riskAdj }){
    const ev_norm = atr_bps>0? ev_bps/atr_bps : 0;
    const ev_sig  = logistic(ev_norm);
    const base    = 0.6*p_cal + 0.4*ev_sig;
    const mult    = clamp((micro||1)*(regime||1)*(reliability||1)*(riskAdj||1), 0.5, 1.2);
    return Math.round(100 * base * mult);
  }
  function reasonBuilder(ctx){
    const out=[];
    if((ctx.adx1h||0)>22) out.push({ factor:"ADX_1h", value:+(ctx.adx1h||0).toFixed(1), contribution:+Math.min(12,(ctx.adx1h-22)*0.6).toFixed(1) });
    if((ctx.ofi30s||0)>0) out.push({ factor:"OFI_30s", value:+(ctx.ofi30s||0).toFixed(3), contribution:+Math.min(10, (ctx.ofi30s*10)).toFixed(1) });
    if(ctx.mrDivOk)        out.push({ factor:"MR_divergence", value:1, contribution:+5.0 });
    if((ctx.tfAlign||0)>=0.7) out.push({ factor:"TF_alignment", value:+(ctx.tfAlign||0).toFixed(2), contribution:+6.0 });
    if((ctx.obi||0)>0.2)   out.push({ factor:"OBI", value:+(ctx.obi||0).toFixed(2), contribution:+3.0 });
    if((ctx.spread_bps||0)>8) out.push({ factor:"Spread_bps", value:ctx.spread_bps, contribution:-Math.min(8,(ctx.spread_bps-8)) });
    if((ctx.slip_bps_est||0)>4) out.push({ factor:"Slip_est_bps", value:ctx.slip_bps_est, contribution:-Math.min(6,(ctx.slip_bps_est-4)) });
    return out.sort((a,b)=>Math.abs(b.contribution)-Math.abs(a.contribution)).slice(0,5);
  }

  // ---------- Config / ENV ----------
  const EXCHANGE=(process.env.EXCHANGE||"mexc").toLowerCase().replace("mexci","mexc");
  if(EXCHANGE!=="mexc"){ console.error("[gha] This build targets MEXC. Set EXCHANGE=mexc"); return; }
  const MEXC_BASES=[process.env.MEXC_BASE,"https://api.mexc.com","https://www.mexc.com"].filter(Boolean);

  // Universe sizing
  const MIN_QV_ENV = Number(process.env.MIN_QV_USD||"0") || 0;
  const UNIV_TARGET_MIN=100, UNIV_TARGET_MAX=120;
  const DYN_QV_MIN=Number(process.env.DYN_QV_MIN||"10000000");
  const DYN_QV_STEP=5_000_000;

  // Core knobs
  const TOP_N = Number(process.env.TOP_N||"3");
  const MAX_SPREAD_BPS = Number(process.env.MAX_SPREAD_BPS||"12");
  const EXP_LCB_MIN_BPS_BASE = Number(process.env.EXP_LCB_MIN_BPS||"12");

  const EMA_FAST=21, EMA_SLOW=50, ADX_P=14, ATR_P=14;
  const K1M=240, K5M=300, K15M=120, K1H=96, K4H=300;
  const VWAP_5M_WIN=36;

  const COST_BPS = Number(process.env.FEES_BPS||"10");
  const NOTIONAL = Number(process.env.NOTIONAL_USD||"300");
  const DEPTH_LIMIT = Number(process.env.MEXC_DEPTH_LIMIT||"50");
  const OBI_TOPN = Number(process.env.OBI_TOPN||"12");

  const COOLDOWN_MS=3*60*60*1000, FLIP_GUARD_MS=30*60*1000;
  const DD_24H_LIMIT_BPS=-150, DD_PEAK_LIMIT_BPS=-300;
  const WILSON_Z=1.34, TARGET_PORT_RISK_BPS=52;
  const TTL_MIN=540, TTL_MAX=1200;

  // ToD active window
  const S_H = process.env.ACTIVE_UTC_START? Number(process.env.ACTIVE_UTC_START): null;
  const E_H = process.env.ACTIVE_UTC_END?   Number(process.env.ACTIVE_UTC_END):   null;
  const nowH = new Date().getUTCHours();
  const todOK = (S_H==null || E_H==null) ? true : (S_H<=E_H ? (nowH>=S_H && nowH<=E_H) : (nowH>=S_H || nowH<=E_H));

  const STABLES=new Set(["USDT","USDC","USD","USDE","USDD","BUSD","FDUSD","TUSD","DAI","USDP","PAX","USTC"]);

  // Fallback + MP (kept for compatibility)
  const NO_VIABLE_RANK_FILL = (process.env.NO_VIABLE_RANK_FILL || "false").toLowerCase()==="true";
  const ALWAYS3_ENABLE = (process.env.ALWAYS3_ENABLE || "true").toLowerCase()==="true";
  const ALWAYS3_SIZE_FACTOR = Number(process.env.ALWAYS3_SIZE_FACTOR || "0.4");
  const MP_TOP_POOL = Number(process.env.MP_TOP_POOL || "20");

  // Direction env
  const DIRECTION=(process.env.DIRECTION||"both").trim().toLowerCase();
  const ALLOWED=new Set(DIRECTION==="both"? ["long","short"] : [DIRECTION]);

  // MR & cost
  const MR_ADX_MAX_DEFAULT=20;
  const MR_SLOPE_MAX_ATR50=Number(process.env.MR_SLOPE_MAX_ATR50||"0.5");
  const MR_BREAKOUT_DC_N=Number(process.env.MR_BREAKOUT_DC_N||"120");
  const MR_BREAKOUT_RET15_ATR=Number(process.env.MR_BREAKOUT_RET15_ATR||"1.5");
  const MR_LOCKOUT_SEC=Number(process.env.MR_LOCKOUT_SEC||"1800");
  const MR_SPREAD_MAX_BPS=Number(process.env.MR_SPREAD_MAX_BPS||"8");
  const MAX_COST_BPS_HARD=Number(process.env.MAX_COST_BPS_HARD||"15");
  const MIN_VOL_1H_USD=Number(process.env.MIN_VOL_1H_USD||"5000000");
  const DEPTH_1P_MIN_USD=Number(process.env.DEPTH_1P_MIN_USD||"200000");
  const MOMENTUM_SIZE_FACTOR=Number(process.env.MOMENTUM_SIZE_FACTOR||"0.5");

  // Symmetric long‑side guards
  const NO_LONG_DOWN_ENABLE=(process.env.NO_LONG_DOWN_ENABLE||"true").toLowerCase()==="true";
  const LONG_DOWN_RSI_CUTOFF=Number(process.env.LONG_DOWN_RSI_CUTOFF||"40");
  const LONG_MR_DIVERGENCE_REQ=(process.env.LONG_MR_DIVERGENCE_REQ||"true").toLowerCase()==="true";

  // Long policy
  const LONG_MAX_COST_BPS=Number(process.env.LONG_MAX_COST_BPS||"12");
  const LONG_EDGE_MULT_MIN=Number(process.env.LONG_EDGE_MULT_MIN||"4");
  const LONG_BOUNCE_SL_ATR=Number(process.env.LONG_BOUNCE_SL_ATR||"0.50");
  const LONG_BOUNCE_TP_ATR=Number(process.env.LONG_BOUNCE_TP_ATR||"0.90");
  const LONG_BOUNCE_HOLD_MIN_SEC=Number(process.env.LONG_BOUNCE_HOLD_MIN_SEC||"900");
  const LONG_BOUNCE_HOLD_MAX_SEC=Number(process.env.LONG_BOUNCE_HOLD_MAX_SEC||"2400");
  const LONG_ENTRY_BOUNCE_OFFSET=Number(process.env.LONG_ENTRY_BOUNCE_OFFSET||"0.0015");
  const LONG_SIMILARITY_RHO=Number(process.env.LONG_SIMILARITY_RHO||"0.84");
  const LONG_KILL_MIN_TRADES=Number(process.env.LONG_KILL_MIN_TRADES||"20");
  const LONG_KILL_WINRATE=Number(process.env.LONG_KILL_WINRATE||"0.20");
  const LONG_KILL_SIZE_MULT=Number(process.env.LONG_KILL_SIZE_MULT||"0.5");
  const LONG_NAUGHTY_BASES=new Set(String(process.env.LONG_NAUGHTY_BASES||"EDU,THE,HEMI,COOKIE,MNT,ASTER").split(",").map(s=>s.trim().toUpperCase()).filter(Boolean));

  // ALWAYS-3 policy (compat, not primary in confidence mode)
  const A3 = {
    ENABLED: true,
    CONTRARIAN: true,
    MIN_SCORE: 50,
    MAX_COST_BPS: 20,
    MAX_SPREAD_BPS: 8,
    MIN_VOL_1H_USD: 2_000_000,
    MIN_DEPTH_1P_USD: 300_000,
    ENTRY_MAX_SLIP_BPS: 3,
    HOLD_SEC: 1800,
    SL_ATR: 0.50,
    TP_ATR: 1.00,
    NOTIONAL_BASE: 8500,
    NOTIONAL_CAP_FRACTION: 0.15,
    DEPTH_WINDOW_PCT: 0.01,
    TP1_OVER_COST_EXTRA_BPS: 2
  };

  const MGMT_ALWAYS3 = {
    be_at_r: 0.25,
    partial_take_at_r: 0.35,
    partial_take_pct: 0.50,
    trail_atr_mult: 0.45,
    extend_ttl_if_unrealized_bps_ge: "COST",
    extend_ttl_sec: 360,
    early_cut_if_unrealized_bps_le: "-COST/2",
    exit_maker: true,
    exit_max_slip_bps: A3.ENTRY_MAX_SLIP_BPS
  };

  // ---------- Worker endpoints ----------
  const PUSH_URL=process.env.WORKER_PUSH_URL||"";
  const PUSH_TOKEN=process.env.PUSH_TOKEN||"";
  const HEALTH_URL=(()=>{ try{ const u=new URL(PUSH_URL); return `${u.origin}${u.pathname.replace(/\/signals\/push(\?.*)?$/,"/health")}`;}catch{return PUSH_URL.replace(/\/signals\/push(\?.*)?$/,"/health");}})();

  // Health ping
  console.log("[gha] health GET", HEALTH_URL);
  try{ const r=await fetchWithTimeout(HEALTH_URL,{ headers:{ "Authorization":`Bearer ${PUSH_TOKEN}`, "User-Agent":UA }},5000); let t=""; try{ t=await r.text(); }catch{} console.log("[gha] health status", r?.status||"ERR", (t||"").slice(0,160)); }catch(e){ console.log("[gha] health error", e?.message||e); }

  // ---------- MEXC Adapter ----------
  async function pickMexcBase(){ for(const b of MEXC_BASES){ try{ const r=await fetchWithTimeout(`${b}/api/v3/time`,{},4000); if(r?.ok) return b; }catch{} } throw new Error("No healthy MEXC base"); }
  const BASE=await pickMexcBase();
  const api=(path,params={})=>{ const u=new URL(path,BASE); for(const [k,v] of Object.entries(params)){ if(v!==undefined&&v!==null) u.searchParams.set(k,String(v)); } return u.toString(); };
  async function fetchK(sym,interval,limit,startTime,endTime){ const u=api("/api/v3/klines",{symbol:sym,interval,limit,startTime,endTime}); const r=await getJSON(u,10000,2); return Array.isArray(r)?r:null; }
  async function fetchDepth(symbol){ return await getJSON(api("/api/v3/depth",{symbol,limit:DEPTH_LIMIT}), 10000, 2); }
  async function fetchAll24hr(){
    let all = await getJSON(api("/api/v3/ticker/24hr"), 10000, 2);
    if(Array.isArray(all) && all.length) return all;
    const exi=await getJSON(api("/api/v3/exchangeInfo"), 10000, 2);
    const syms=(exi?.symbols||[]).filter(s=>s.status==="TRADING").map(s=>s.symbol).slice(0,300);
    const out=[]; for(let i=0;i<syms.length;i+=24){ const chunk=syms.slice(i,i+24); const got=await Promise.all(chunk.map(s=>getJSON(api("/api/v3/ticker/24hr",{symbol:s}),6000,1))); for(const x of got) if(x) out.push(x); await sleep(180); }
    return out;
  }
  async function fetchBookTicker(symbol){
    return await getJSON(api("/api/v3/ticker/bookTicker",{symbol}), 8000, 1);
  }

  // ---------- Run/config provenance ----------
  async function getMexcTime(){ const j=await getJSON(api("/api/v3/time"), 8000, 2); const st=+j?.serverTime||Date.now(); return { mexc_server_time_ms: st, mexc_time_offset_ms: st - Date.now() }; }
  function buildConfigHash(){
    const cfg = {
      EXCHANGE, MIN_QV_ENV, TOP_N, MAX_SPREAD_BPS, EXP_LCB_MIN_BPS_BASE,
      FEES_BPS:COST_BPS, NOTIONAL, DEPTH_LIMIT, OBI_TOPN, ACTIVE_UTC_START:S_H, ACTIVE_UTC_END:E_H, MEXC_BASE:BASE,
      FORCE_SIZE_BPS: Number(process.env.FORCE_SIZE_BPS||"0"), NO_VIABLE_RANK_FILL, ALWAYS3_ENABLE, ALWAYS3_SIZE_FACTOR, MP_TOP_POOL,
      DIRECTION,
      MR_SLOPE_MAX_ATR50, MR_BREAKOUT_DC_N, MR_BREAKOUT_RET15_ATR, MR_LOCKOUT_SEC, MR_SPREAD_MAX_BPS, MAX_COST_BPS_HARD,
      MIN_VOL_1H_USD, DEPTH_1P_MIN_USD, MOMENTUM_SIZE_FACTOR,
      NO_LONG_DOWN_ENABLE, LONG_DOWN_RSI_CUTOFF, LONG_MR_DIVERGENCE_REQ,
      LONG_MAX_COST_BPS, LONG_EDGE_MULT_MIN, LONG_BOUNCE_SL_ATR, LONG_BOUNCE_TP_ATR, LONG_BOUNCE_HOLD_MIN_SEC, LONG_BOUNCE_HOLD_MAX_SEC, LONG_ENTRY_BOUNCE_OFFSET,
      LONG_SIMILARITY_RHO, LONG_KILL_MIN_TRADES, LONG_KILL_WINRATE, LONG_KILL_SIZE_MULT,
      T_VA_DF: Number(process.env.T_VA_DF||"6"), T_SIM_DF: Number(process.env.T_SIM_DF||"5"), BOOT_BLOCK: Number(process.env.BOOT_BLOCK||"3"),
      CALIB_MIN_PLATT: Number(process.env.CALIB_MIN_PLATT||"30"), CALIB_MIN_ISO: Number(process.env.CALIB_MIN_ISO||"120"),
      EMA_FAST, EMA_SLOW, ADX_P, ATR_P, VWAP_5M_WIN, WILSON_Z, TTL_MIN, TTL_MAX, TARGET_PORT_RISK_BPS,
      A3, MGMT_ALWAYS3
    };
    return "sha256:"+sha256Hex(stableStringify(cfg));
  }
  const pusher_version="mexc-ultimate-6.3-confidence";
  const code_commit_sha=process.env.GITHUB_SHA||"";
  const run_id=new Date().toISOString()+"#6.3";
  const mexcTime=await getMexcTime();
  const config_hash=buildConfigHash();
  let run_prov={ run_id, code_commit_sha, pusher_version, config_hash, exchange_base:BASE, ...mexcTime, p_model:{ gp_hash:null, calib_type:"mixed", calib_n:0 } };

  // ---------- State (Gist) ----------
  async function loadState(){
    const token=process.env.GIST_TOKEN, id=process.env.GIST_ID;
    const init={ v:"mexc-ultimate-6.3-confidence",
      schema_version:"1.3.0", append_only:true, run: run_prov,
      cooldown:{}, cooldown_side:{},
      pending:[], equity:[], closed:[],
      gp_data_clf:[],
      calibration:{ platt:{}, isotonic:{}, last_fit_ts:0 },
      metrics:{ global:{ ttl_n:0, closed_n:0, ttl_pct:0 }, by_key:{}, reliability:{} },
      drift:{}, sym_stats:{}, mr_lockout:{},
      push_log:[],
      bandit:{ arms:[ {exp_lcb_min:10, mr_adx_max:18, tries:0, wins:0}, {exp_lcb_min:12, mr_adx_max:20, tries:0, wins:0}, {exp_lcb_min:15, mr_adx_max:22, tries:0, wins:0} ], last_choice:1 }
    };
    if(!token||!id) return { state:init, persist:null };
    try{
      const r=await fetchWithTimeout(`https://api.github.com/gists/${id}`,{ headers:{Authorization:`Bearer ${token}`,"Accept":"application/vnd.github+json","User-Agent":UA}}); if(!r.ok) return { state:init, persist:null };
      const g=await r.json(); const c=g.files?.["state.json"]?.content; const s=c?JSON.parse(c):init;
      if(!s.mr_lockout) s.mr_lockout={};
      if(!Array.isArray(s.closed)) s.closed=[];
      if(!Array.isArray(s.push_log)) s.push_log=[];
      if(!s.calibration) s.calibration={ platt:{}, isotonic:{}, last_fit_ts:0 };
      if(!s.metrics) s.metrics={ global:{ ttl_n:0, closed_n:0, ttl_pct:0 }, by_key:{}, reliability:{} };
      if(!s.drift) s.drift={};
      if(!s.sym_stats) s.sym_stats={};
      if(!s.gp_data_clf) s.gp_data_clf=[];
      if(!s.bandit) s.bandit={ arms:[{exp_lcb_min:12,mr_adx_max:20,tries:0,wins:0}], last_choice:0 };
      s.run = { ...(s.run||{}), ...run_prov };
      s.schema_version="1.3.0";
      s.append_only=true;
      return { state:s, persist:{id,token} };
    }catch{ return { state:init, persist:null }; }
  }
  async function saveState(persist,state){
    if(!persist) return;
    try{
      await fetchWithTimeout(`https://api.github.com/gists/${persist.id}`,{
        method:"PATCH",
        headers:{Authorization:`Bearer ${persist.token}`,"Accept":"application/vnd.github+json","Content-Type":"application/json","User-Agent":UA},
        body: JSON.stringify({ files:{ "state.json":{ content: JSON.stringify(state) } } })
      });
    }catch{}
  }

  // ---------- Trade evaluation / pending → closed with predicted snapshot and error ----------
  async function evalPending(state){
    const now=Date.now(); const keep=[];
    for(const p of state.pending||[]){
      const entry_ts_ms = p.entry_ts_ms || p.ts_ms;
      const ttl_ts_ms   = p.ttl_ts_ms   || (p.ts_ms + (p.hold_sec||0)*1000);
      if(now < ttl_ts_ms + 5000){ keep.push(p); continue; }

      const k = await fetchK(p.symbolFull,"1m",K1M, entry_ts_ms-60*1000, ttl_ts_ms+60*1000);
      if(!k){ keep.push(p); continue; }
      const ts=k.map(x=>+x[0]), highs=k.map(x=>+x[2]), lows=k.map(x=>+x[3]), closes=k.map(x=>+x[4]);
      const long=p.side==="long";
      const entry = Number.isFinite(p.entry_limit) ? p.entry_limit : (Number.isFinite(p.entry_price)?p.entry_price:closes[0]);

      const tpB=(p.tp_bps||0)/10000, slB=(p.sl_bps||0)/10000;
      const tp_abs = Number.isFinite(p.tp_abs) ? p.tp_abs : (long ? entry*(1+tpB) : entry*(1-tpB));
      const sl_abs = Number.isFinite(p.sl_abs) ? p.sl_abs : (long ? entry*(1-slB) : entry*(1+slB));

      let filled=false, iFill=-1, exit_reason=null, exit_source=null, price_source="sim", bar_ref=null, exit_px=null, exit_ts_ms=null, hit_ambiguous=false;

      // Fill detection
      {
        const t0=entry_ts_ms, tEnd=ttl_ts_ms;
        for(let i=0;i<k.length;i++){
          const t=ts[i]; if(t < t0-1000) continue; if(t > tEnd) break;
          if(long ? (lows[i] <= entry) : (highs[i] >= entry)){ iFill=i; filled=true; break; }
        }
        if(!filled){ keep.push(p); continue; }
      }

      // TTL bar index
      const ttlBarOpen = Math.floor(ttl_ts_ms/60000)*60000;
      let iTTL = ts.findIndex(t=>t===ttlBarOpen);
      if(iTTL<0) iTTL = ts.length-1;

      // Scan for TP/SL
      let iExit=null;
      for(let i=iFill;i<k.length;i++){
        if(i>iTTL) break;
        const hi=highs[i], lo=lows[i];
        const tp_hit = long ? (hi>=tp_abs) : (lo<=tp_abs);
        const sl_hit = long ? (lo<=sl_abs) : (hi>=sl_abs);
        if(tp_hit || sl_hit){
          hit_ambiguous = tp_hit && sl_hit;
          if(hit_ambiguous){
            exit_reason="tp"; exit_source="tp_scan"; price_source="mexc_1m_high/low"; exit_px=tp_abs;
          }else if(tp_hit){
            exit_reason="tp"; exit_source="tp_scan"; price_source="mexc_1m_high/low"; exit_px=tp_abs;
          }else{
            exit_reason="sl"; exit_source="sl_scan"; price_source="mexc_1m_high/low"; exit_px=sl_abs;
          }
          iExit=i;
          const open_ms=ts[i], close_ms=open_ms+60000-1;
          bar_ref={ interval:"1m", open_ms, close_ms };
          exit_ts_ms=close_ms;
          (p.events ||= []).push({ ts_ms: close_ms, type: (exit_reason==="tp"?"tp_scan":"sl_scan"), bar_ref });
          break;
        }
      }

      // TTL exit fallback
      let exit_delay_ms=0;
      if(iExit==null){
        exit_reason="ttl"; exit_source="ttl_scan"; price_source="mexc_1m_close";
        const open_ms=ts[iTTL], close_ms=open_ms+60000-1;
        bar_ref={ interval:"1m", open_ms, close_ms };
        exit_px=closes[iTTL];
        exit_ts_ms=Math.min(close_ms, ttl_ts_ms);
        exit_delay_ms=Math.max(0, exit_ts_ms - ttl_ts_ms);
        (p.events ||= []).push({ ts_ms: close_ms, type:"ttl", bar_ref });
      }

      // Entered event (if missing)
      if(!p.events?.some(e=>e.type==="entered")){
        const open_ms=ts[iFill], close_ms=open_ms+60000-1;
        (p.events ||= []).push({ ts_ms: close_ms, type:"entered", price: entry, book: p.entry_book||undefined });
      }

      // Exit microstructure
      let book_exit=null, spread_bps_exit=null, slip_bps_exit=null, depth1p_exit_usd=null, obi_exit=null;
      try{
        const bt=await fetchBookTicker(p.symbolFull);
        if(bt?.bidPrice && bt?.askPrice){
          book_exit={ bid:+bt.bidPrice, ask:+bt.askPrice };
          const mid=(book_exit.bid+book_exit.ask)/2;
          spread_bps_exit=Math.round(((book_exit.ask - book_exit.bid)/mid)*10000);
          const depth=await fetchDepth(p.symbolFull);
          const { slip_bps }=slipFromDepth(depth, mid, (p.side==="long"?"short":"long"), p.notional_usd||NOTIONAL);
          slip_bps_exit = slip_bps;
          const d1=depthWithinPctUSD(depth, mid, 0.01);
          depth1p_exit_usd = (p.side==="long") ? d1.bidsUSD : d1.asksUSD;
          obi_exit = computeOBI(depth, OBI_TOPN);

          // TTL mark to mid if available
          if (exit_reason==="ttl" && mid>0) {
            exit_px = mid;
          }
        }
      }catch{}

      // PnL
      const ret = long? (exit_px/entry - 1) : (entry/exit_px - 1);
      const pnl_bps_gross = Math.round(ret*10000);
      const cost_bps = p.cost_bps||0;
      const pnl_bps = pnl_bps_gross - cost_bps;

      // Learning artifacts
      state.equity.push({ ts_ms: entry_ts_ms, pnl_bps, tier:p.tier, mp_fill:!!p.mp_fill, always3:!!p.always3 });
      if(state.equity.length>6000) state.equity=state.equity.slice(-6000);
      if(Array.isArray(p.gp_feat) && p.gp_feat.length){
        state.gp_data_clf.push({ x:p.gp_feat, y: pnl_bps>0?1:0, side:p.side, regime:p.regime, ts_ms:entry_ts_ms });
        if(state.gp_data_clf.length>1200) state.gp_data_clf=state.gp_data_clf.slice(-1200);
      }
      const sb=state.sym_stats?.[p.base]||{ n:0,wins:0,pnl_sum:0 }; sb.n++; if(pnl_bps>0) sb.wins++; sb.pnl_sum+=pnl_bps; state.sym_stats[p.base]=sb;
      if(state.bandit?.arms){ const idx=state.bandit.last_choice??-1; if(idx>=0){ const arm=state.bandit.arms[idx]; arm.tries=(arm.tries||0)+1; if(pnl_bps>0) arm.wins=(arm.wins||0)+1; } }

      // Realized path: MFE/MAE
      let mfe=0, mae=0;
      if(iFill>=0){
        const base=entry;
        for(let i=iFill;i<=(iExit!=null?iExit:iTTL);i++){
          const hi=highs[i], lo=lows[i];
          const rHi= long? (hi/base - 1): (base/hi - 1);
          const rLo= long? (lo/base - 1): (base/lo - 1);
          mfe=Math.max(mfe, rHi*10000);
          mae=Math.min(mae, rLo*10000);
        }
      }

      // Closed record (append-only)
      const closedRec={
        schema_version:"1.3.0",
        trade_id: p.trade_id || `${p.symbolFull}:${entry_ts_ms}`,
        symbolFull:p.symbolFull, base:p.base, quote:p.quote,
        side:p.side, tier:p.tier,
        entry_ts_ms, ttl_ts_ms, exit_ts_ms,
        exit_reason, exit_source, price_source, bar_ref,
        entry_price: entry, exit_price: exit_px,
        pnl_bps_gross, cost_bps, pnl_bps,
        spread_bps_entry: p.spread_bps_entry, spread_bps_exit,
        slip_bps_entry: p.slip_bps_entry, slip_bps_exit,
        size_bps: p.size_bps, notional_usd: p.notional_usd,
        exit_delay_ms, hit_ambiguous,
        p_raw: p.p_raw, p_pred: p.p_lcb, calib_key: p.calib_key, calib_type: p.calib_type||"raw", calib_n: p.calib_n||0,
        gp_feat: p.gp_feat||[],
        regime: p.regime, style: p.style_final||p.style,
        book_entry: p.entry_book||null, book_exit: book_exit||null,
        depth1p_entry_usd: p.depth1p_entry_usd||null, depth1p_exit_usd: depth1p_exit_usd||null,
        run_id: (state.run?.run_id)||run_id, code_commit_sha: (state.run?.code_commit_sha)||code_commit_sha,
        config_hash: (state.run?.config_hash)||config_hash,
        exchange_base: (state.run?.exchange_base)||BASE,
        mexc_server_time_ms: state.run?.mexc_server_time_ms||null,
        mexc_time_offset_ms: state.run?.mexc_time_offset_ms||null,
        events: p.events||[]
      };

      // Predicted snapshot + realized/error
      try{
        const pred = p.predicted ? p.predicted : undefined;
        closedRec.realized = {
          time_to_event_sec: Math.round(((exit_ts_ms||ttl_ts_ms) - (entry_ts_ms||p.ts_ms))/1000),
          tp_hit: (exit_reason==="tp"), sl_hit:(exit_reason==="sl"), ttl_exit:(exit_reason==="ttl"),
          max_favorable_excursion_bps: Math.round(mfe||0), max_adverse_excursion_bps: Math.round(mae||0),
          micro_exit: { spread_bps: spread_bps_exit, slip_bps: slip_bps_exit, obi: obi_exit, depth1p_usd: depth1p_exit_usd },
          path_stats: { vol_bps: Math.round((std(closes.slice(iFill, (iExit??(closes.length-1))+1)) / (entry||1)) * 10000), skew: null, kurt: null }
        };
        if(pred) closedRec.predicted_snapshot = pred;
        const wasCorrect = (pnl_bps||0) > 0;
        const p_cal = pred?.p_cal ?? (typeof p.p_lcb==="number"? p.p_lcb : null);
        closedRec.error_analysis = {
          was_correct: wasCorrect,
          p_bucket: p_cal!=null? (function(){ const b=Math.floor(clamp(p_cal,0,0.999)*20); const lo=(b/20).toFixed(2), hi=((b+1)/20).toFixed(2); return `${lo}-${hi}`; })() : "na",
          calibration_error: p_cal!=null? +((wasCorrect?1:0) - p_cal).toFixed(4) : null,
          attribution: (pred?.reasons||[]).map(r => ({ factor:r.factor, expected: Math.sign(r.contribution)||0, realized: null, delta: null }))
        };
      }catch(e){ console.log("[gha] realized/error annotate warn", e?.message||e); }

      (state.closed ||= []).push(closedRec);
      if(state.closed.length>5000) state.closed=state.closed.slice(-5000);
    }
    state.pending = keep;
  }

  function updateMetricsAndDrift(state){
    const cl=state.closed||[]; const lastN=cl.slice(-400);
    const y=lastN.map(x=> (x.pnl_bps||0)>0?1:0), p=lastN.map(x=> typeof x.p_pred==="number"?x.p_pred : 0.5);
    if(y.length){ const bs=brier(y,p), ll=logloss(y,p), AUC=auc(y,p); state.metrics.global={ ...(state.metrics.global||{}), brier:+bs.toFixed(4), logloss:+ll.toFixed(4), auc:+(isNaN(AUC)?0:AUC).toFixed(3), n:lastN.length }; }
    const byKey={}; for(const r of lastN){ const k=r.calib_key || `${r.side}_${String(r.regime).includes("mean")?"mr":"trend"}`; (byKey[k]??=( {y:[],p:[] } )).y.push((r.pnl_bps||0)>0?1:0); byKey[k].p.push(typeof r.p_pred==="number"?r.p_pred:0.5); }
    const out={}; for(const [k,v] of Object.entries(byKey)){ const b=brier(v.y,v.p), l=logloss(v.y,v.p), A=auc(v.y,v.p); out[k]={ ...(state.metrics.by_key?.[k]||{}), brier:+b.toFixed(4), logloss:+l.toFixed(4), auc:+(isNaN(A)?0:A).toFixed(3), n:v.y.length };
      const ph = state.drift?.[k] || pageHinkleyInit(); const drift=pageHinkleyUpdate(ph, l, 0.0015, 0.02); (state.drift ||= {}); state.drift[k]=ph; if(drift){ delete state.calibration.platt[k]; delete state.calibration.isotonic[k]; } }
    state.metrics.by_key=out;
  }
  function fitCalibrators(state){
    const cl=state.closed||[]; const byKey={};
    for(const r of cl.slice(-800)){ const k=r.calib_key || `${r.side}_${String(r.regime).includes("mean")?"mr":"trend"}`; if(typeof r.p_raw!=="number") continue; (byKey[k]??=( {p:[],y:[]} )).p.push(clamp(r.p_raw,1e-6,1-1e-6)); byKey[k].y.push((r.pnl_bps||0)>0?1:0); }
    for(const [k,ds] of Object.entries(byKey)){ if(ds.p.length>=Number(process.env.CALIB_MIN_ISO||"120")){ state.calibration.isotonic[k]=fitIsotonic(ds.p,ds.y); } else if(ds.p.length>=Number(process.env.CALIB_MIN_PLATT||"30")){ state.calibration.platt[k]=fitPlatt(ds.p,ds.y); } }
    state.calibration.last_fit_ts=Date.now();
  }
  function calibrateP(state,side,regime,pRaw){
    const k=`${side}_${String(regime).includes("mean")?"mr":"trend"}`;
    const iso=state.calibration.isotonic[k]; if(iso?.n>=Number(process.env.CALIB_MIN_ISO||"120")) return (applyIsotonic([pRaw],iso))[0];
    const pl=state.calibration.platt[k]; if(pl?.n>=Number(process.env.CALIB_MIN_PLATT||"30")) return (applyPlatt([pRaw],pl))[0];
    return pRaw;
  }
  function calibratorInfo(state, side, regime){
    const k=`${side}_${String(regime).includes("mean")?"mr":"trend"}`;
    const iso=state.calibration.isotonic[k]; if(iso?.n>=Number(process.env.CALIB_MIN_ISO||"120")) return { type:"iso", n: iso.n };
    const pl=state.calibration.platt[k]; if(pl?.n>=Number(process.env.CALIB_MIN_PLATT||"30")) return { type:"platt", n: pl.n };
    return { type:"raw", n: 0 };
  }

  // ---------- Reliability / ECE ----------
  function updateReliability(state){
    try{
      const cl=(state.closed||[]).slice(-800);
      const binsByKey={}; // calib_key -> [ {n, s}, ...20 bins ]
      for(const r of cl){
        const key=r.calib_key||"na";
        const p=typeof r.p_pred==="number"? r.p_pred : (typeof r.p_raw==="number"? r.p_raw : null);
        if(p==null) continue;
        const b = Math.min(19, Math.max(0, Math.floor(clamp(p,0,0.999)*20)));
        binsByKey[key] ||= Array.from({length:20},()=>({n:0,s:0}));
        const win=((r.pnl_bps||0)>0)?1:0;
        binsByKey[key][b].n += 1; binsByKey[key][b].s += win;
      }
      const out={};
      for(const [k,bins] of Object.entries(binsByKey)){
        let ece=0, N=0; const curve=[];
        for(let i=0;i<20;i++){
          const n=bins[i].n, s=bins[i].s; if(n===0) continue;
          const conf=(i+0.5)/20, acc=s/n, diff=Math.abs(acc-conf);
          ece += (n*diff); N += n;
          curve.push({ bin:i, conf, acc, n });
        }
        out[k]={ ece: N? +(ece/N).toFixed(4):0, curve, n:N };
      }
      state.metrics ||= {}; state.metrics.reliability=out;
    }catch{}
  }

  // ---------- Main ----------
  let reason="ok", selectionTier="confidence";
  try{
    const ALL24 = await fetchAll24hr();
    const booksRaw=await getJSON(api("/api/v3/ticker/bookTicker"),10000,2) || [];
    const bookMap=new Map(booksRaw.map(b=>[b.symbol,{ bid:+b.bidPrice, ask:+b.askPrice }]));

    if(!todOK) reason="tod_gate";

    // Universe
    const QUOTES=["USDT","USDC","USD"];
    const split=(sym)=>{ for(const q of QUOTES) if(sym.endsWith(q)) return { base:sym.slice(0,-q.length), quote:q }; return null; };
    const all=[]; for(const t of ALL24||[]){ const sym=t.symbol||t.s; if(!sym) continue; const sq=split(sym); if(!sq) continue; if(STABLES.has(sq.base)) continue; const qv=+(t.quoteVolume||t.q||0); if(!isFinite(qv)||qv<=0) continue; all.push({ symbol:sym, base:sq.base, quote:sq.quote, qv }); }
    all.sort((a,b)=>b.qv-a.qv);
    let dynMinQV=Math.max(MIN_QV_ENV||0, DYN_QV_MIN), filt=all.filter(x=>x.qv>=dynMinQV);
    while(filt.length<UNIV_TARGET_MIN && dynMinQV>1_000_000){ dynMinQV=Math.max(1_000_000, dynMinQV-DYN_QV_STEP); filt=all.filter(x=>x.qv>=dynMinQV); }
    const universe=filt.slice(0,UNIV_TARGET_MAX);
    console.log("[gha] universe", universe.length, "dyn_min_qv", dynMinQV);
    snapCounts({ universe: universe.length });

    // Benchmarks/regime (BTC/ETH/SOL)
    const BTC="BTCUSDT", ETH="ETHUSDT", SOL="SOLUSDT";
    const kBTC15=await getKCached(BTC,"15m",K15M), kETH15=await getKCached(ETH,"15m",K15M), kSOL15=await getKCached(SOL,"15m",K15M);
    const kBTC1H=await getKCached(BTC,"1h",K1H);
    const uptrendTF=(k,fast=EMA_FAST,slow=EMA_SLOW)=>{ if(!k?.length) return {up:false,last:null}; const c=k.map(x=>+x[4]); const emF=ema(c,fast), emS=ema(c,slow); const last=c.at(-1); return { up:(last>=emF && last>=emS), last }; };
    const btc15=uptrendTF(kBTC15), btc1h=uptrendTF(kBTC1H);
    let btcRoc15=0; try{ const c=kBTC15?.map(x=>+x[4])||[]; const prev3=c.at(-4)||c.at(-2)||c.at(-1)||0; const last=c.at(-1)||0; btcRoc15=prev3? (last/prev3 - 1) : 0; }catch{}
    const btcGreen=(btc15.up && btc1h.up && btcRoc15>0.001);

    // Regime weights (lightweight)
    function regimeFeatures(k15){ if(!k15||k15.length<ADX_P+5) return []; const h=k15.map(x=>+x[2]), l=k15.map(x=>+x[3]), c=k15.map(x=>+x[4]); const {adx}=computeADX_ATR(h,l,c,ADX_P)||{adx:0}; const roc=(c.at(-1)/c.at(-5)-1); const winS=20, retW=[]; for(let i=c.length-winS;i<c.length;i++) retW.push((c[i]/c[i-1])-1); const bbWidth=std(retW)*Math.sqrt(winS); const atr=(computeADX_ATR(h,l,c,ADX_P)||{atr:1}).atr||1; const kelWidth=atr/c.at(-1); const squeeze=kelWidth>0? (bbWidth/kelWidth):1; return [roc, clamp((adx-10)/30,0,1), clamp((1.15-squeeze)/0.45,0,1)]; }
    const seqFeat=[]; const rollSeq=(k)=>{ if(!k) return; for(let i=5;i<Math.min(k.length,80);i++){ const seg=k.slice(i-5,i+1); const f=regimeFeatures(seg); if(f.length) seqFeat.push(f); } };
    rollSeq(kBTC15); rollSeq(kETH15);
    const weightsReg=(()=>{ if(seqFeat.length<10) return { wTrend:0.45,wMR:0.45,wBO:0.10 }; const last=seqFeat.slice(-12), roc=mean(last.map(x=>x[0]||0)), adxN=mean(last.map(x=>x[1]||0)), sq=mean(last.map(x=>x[2]||0)); const wTrend=clamp(0.4+0.3*adxN+0.2*roc,0.2,0.7), wMR=clamp(0.6-0.3*adxN+0.1*(1-sq),0.2,0.6); const wBO=clamp(1-(wTrend+wMR),0.05,0.25); return {wTrend,wMR,wBO}; })();

    // Load state / eval / calibration
    const { state, persist } = await loadState();
    state.run = { ...state.run, ...run_prov };

    try{ await evalPending(state); }catch(e){ console.log("[gha] evalPending warn", e?.message||e); }
    updateMetricsAndDrift(state);
    updateReliability(state);
    if(Date.now() - (state.calibration.last_fit_ts||0) > 30*60*1000){ fitCalibrators(state); }

    const equityStats=(eq)=>{ const day=Date.now()-24*3600*1000; let pnl24=0,cum=0,peak=0,dd=0; for(const e of eq||[]){ if(e.ts_ms>=day) pnl24+=e.pnl_bps; cum+=e.pnl_bps; if(cum>peak) peak=cum; dd=Math.min(dd,cum-peak); } return { pnl24_bps:Math.round(pnl24), peak_dd_bps:Math.round(dd) }; };
    const { pnl24_bps, peak_dd_bps } = equityStats(state.equity);
    const throttle=(pnl24_bps<=DD_24H_LIMIT_BPS) || (peak_dd_bps<=DD_PEAK_LIMIT_BPS);

    // Bandit choice
    function banditChoose(state){ const arms=state.bandit?.arms||[]; if(!arms.length) return { exp_lcb_min:EXP_LCB_MIN_BPS_BASE, mr_adx_max:MR_ADX_MAX_DEFAULT, idx:-1 }; let best=-1, draw=-1; for(let i=0;i<arms.length;i++){ const a=1+(arms[i].wins||0), b=1+Math.max(0,(arms[i].tries||0)-(arms[i].wins||0)); const x1=Math.random()**(1/a), x2=Math.random()**(1/b); const d=x1/(x1+x2); if(d>draw){ draw=d; best=i; } } state.bandit.last_choice=best; return { exp_lcb_min:arms[best].exp_lcb_min, mr_adx_max:arms[best].mr_adx_max, idx:best }; }
    const banditChoice=banditChoose(state);
    const EXP_LCB_MIN_THIS=Math.max(EXP_LCB_MIN_BPS_BASE, banditChoice.exp_lcb_min);
    const MR_ADX_MAX = banditChoice.mr_adx_max ?? MR_ADX_MAX_DEFAULT;

    // Liquidity ranks
    const liqPct=new Map(); for(let i=0;i<universe.length;i++) liqPct.set(universe[i].symbol, (universe.length===1)?1: 1 - i/(universe.length-1));

    const toRet5=(k)=>{ if(!k) return []; const c=k.map(x=>+x[4]); const r=[]; for(let i=1;i<c.length;i++) r.push(Math.log(c[i]/c[i-1])); return r.slice(-60); };
    const fBTC=toRet5(kBTC15), fETH=toRet5(kETH15), fSOL=toRet5(kSOL15);

    // Prefilter
    const picksRaw=[]; const pfStats={ total:0, dropped:{ cooldown:0, book:0, spread:0, k5:0, adxatr:0, atrRange:0 }, kept:0 };
    const B=10;
    for(let i=0;i<(universe||[]).length;i+=B){
      const batch=await Promise.all(universe.slice(i,i+B).map(async c=>{
        try{
          pfStats.total++;
          const lastTs=state.cooldown?.[c.base]||0; if(lastTs && (Date.now()-lastTs)<COOLDOWN_MS){ pfStats.dropped.cooldown++; return null; }
          const book=bookMap.get(c.symbol) || await getBookTickerCached(c.symbol); if(!book?.bid||!book?.ask){ pfStats.dropped.book++; return null; }
          const mid=(book.bid+book.ask)/2; if(!(mid>0)){ pfStats.dropped.book++; return null; }
          const spreadBps=Math.round(((book.ask-book.bid)/mid)*10000); if(spreadBps>MAX_SPREAD_BPS){ pfStats.dropped.spread++; return null; }

          const k5=await getKCached(c.symbol,"5m",K5M); if(!k5||k5.length<Math.max(EMA_SLOW+200,ATR_P+50)){ pfStats.dropped.k5++; return null; }
          const k15=await getKCached(c.symbol,"15m",K15M); const k1h=await getKCached(c.symbol,"1h",K1H);

          const c5_raw=k5.map(x=>+x[4]); const c5=kalman1D(c5_raw,{q:1e-4,r:5e-4,x0:c5_raw[0],p0:1e-2});
          const h5=k5.map(x=>+x[2]), l5=k5.map(x=>+x[3]), v5=k5.map(x=>+x[5]);
          const em21=emaSeries(c5,EMA_FAST), em50s=emaSeries(c5,EMA_SLOW), em200s=emaSeries(c5,200);
          const em50=em50s?.at(-1), em200=em200s?.at(-1), em50Prev=em50s?.at(-51);
          const { adx:adx5, atr:atr5 } = computeADX_ATR(h5,l5,c5,ADX_P)||{};
          if(!(adx5&&atr5)){ pfStats.dropped.adxatr++; return null; }
          const last=c5.at(-1), atr_bps=Math.round((atr5/last)*10000); if(atr_bps<4||atr_bps>260){ pfStats.dropped.atrRange++; return null; }

          const k15c=k15?.map(x=>+x[4])||[], k1hc=k1h?.map(x=>+x[4])||[];
          const em15f=k15c.length?ema(k15c,EMA_FAST):null, em15s=k15c.length?ema(k15c,EMA_SLOW):null;
          const em1hf=k1hc.length?ema(k1hc,EMA_FAST):null, em1hs=k1hc.length?ema(k1hc,EMA_SLOW):null;

          const vwap5=vwapAnchored(h5,l5,c5,v5,VWAP_5M_WIN);
          const prev=c5.at(-2), prev3=c5.at(-4), roc5=(last/prev)-1, roc15=(last/prev3)-1;

          const upF=last>=em21?.at(-1), upS=last>=em50, up15=(em15f&&em15s)? (last>=em15f && last>=em15s):true, up1h=(em1hf&&em1hs)? (last>=em1hf && last>=em1hs):true;
          const z_vwap=(last-vwap5)/(atr5||1); const rsi14=rsi(c5,14);

          const trendBias=(em50!=null && em200!=null)? (em50>em200?"long_only": em50<em200?"short_only":"both") : "both";
          const slope_atr50=(em50!=null && em50Prev!=null)? Math.abs(em50-em50Prev)/(50*(atr5||1)) : 0;

          // Donchian / breakout lockout
          const highs=h5, lows=l5; const win=MR_BREAKOUT_DC_N;
          const dcHi=Math.max(...highs.slice(-win)), dcLo=Math.min(...lows.slice(-win));
          const atrPct=(atr5/last), ret15abs=Math.abs((last/(c5.at(-4)||last))-1);
          const breakout=(last>dcHi) || (last<dcLo) || (ret15abs>=MR_BREAKOUT_RET15_ATR*atrPct);
          if(breakout) state.mr_lockout[c.symbol]=Date.now()+MR_LOCKOUT_SEC*1000;
          const mrLocked=(Date.now() < (state.mr_lockout?.[c.symbol]||0));

          // Symmetric guards
          const em20s=emaSeries(c5,20), em20=em20s?.at(-1);
          const noShortUp=((em20!=null&&em50!=null)? (em20>em50 && last>em20):false) || ((rsi14||0)>60);
          const noLongDown= NO_LONG_DOWN_ENABLE && (((em20!=null&&em50!=null)? (em20<em50 && last<em20):false) || ((rsi14||100)<LONG_DOWN_RSI_CUTOFF));

          // Divergence checks
          const bb=(function boll(cl,win=20,k=2){ const seg=cl.slice(-win); const ma=mean(seg), s=std(seg)||1e-6; return { up:ma+k*s, dn:ma-k*s, z:(cl.at(-1)-ma)/s }; })(c5,20,2);
          const rsiPrev3=rsi(c5.slice(0,-2),14), rsiPrev5=rsi(c5.slice(0,-4),14);
          const rsiLowerHigh=(rsiPrev5!=null && rsiPrev3!=null && rsi14!=null)? (rsiPrev3>rsiPrev5 && rsi14<rsiPrev3):false;
          const rsiHigherLow=(rsiPrev5!=null && rsiPrev3!=null && rsi14!=null)? (rsiPrev3<rsiPrev5 && rsi14>rsiPrev3):false;
          const obvNeg=(function obv(close,vol){ let obv=0; for(let i=1;i<close.length;i++){ const d=close[i]-close[i-1]; if(d>0) obv+=vol[i]; else if(d<0) obv-=vol[i]; } const prev=(()=>{ let o=0; for(let i=1;i<Math.max(2,close.length-10);i++){ const d=close[i]-close[i-1]; if(d>0) o+=vol[i]; else if(d<0) o-=vol[i]; } return o; })(); return (obv-prev)<0; })(c5,v5);
          const obvPos=!obvNeg;

          const fadeShortDivergenceOK=((bb.up!=null && last>bb.up) && rsiLowerHigh) || ((bb.z||0)>2 && obvNeg);
          const fadeLongDivergenceOK_raw=((bb.dn!=null && last<bb.dn) && rsiHigherLow) || ((bb.z||0)<-2 && obvPos);
          const fadeLongDivergenceOK = LONG_MR_DIVERGENCE_REQ ? fadeLongDivergenceOK_raw : true;

          // Experts
          const adxF=clamp((adx5-16)/14,0,1), s1=tanh(roc5/0.0030), s2=tanh(roc15/0.0065);
          const sideTrend=(0.6*roc5+0.4*roc15)>=0?"long":"short";
          const trendAlign=(sideTrend==="long" && upF&&upS&&up15&&up1h) || (sideTrend==="short" && !upF&&!upS&&(!up15||!up1h));
          let pTrend = clamp(0.5 + 0.27*(0.6*s1+0.4*s2)*(trendAlign?1.0:0.7)*adxF, 0.32, 0.93);

          const sideMR=z_vwap>0?"short":"long";
          const sMR=tanh(Math.abs(z_vwap))*Math.sign(-z_vwap);
          const rsiEdge=(rsi14!=null)? (rsi14-50)/50 : 0;
          let pMR = clamp(0.5 + 0.23*(0.7*sMR + 0.3*(-rsiEdge))*(1-adxF), 0.35, 0.90);

          const boUp=(last>dcHi), boDn=(last<dcLo);
          let boBase=(boUp||boDn?1.0:0.35)*(0.6+0.4*adxF);
          { const winS=20, retW=[]; for(let i=c5.length-winS;i<c5.length;i++) retW.push((c5[i]/c5[i-1])-1); const bbWidth=std(retW)*Math.sqrt(winS); const kelWidth=(atr5/last); const sqRatio=kelWidth>0? (bbWidth/kelWidth):1; const sqScore=clamp((1.15-sqRatio)/0.45,0,1); boBase*=(1+0.4*sqScore); }
          const sideBO= boUp?"long": boDn?"short": ((0.6*roc5+0.4*roc15)>=0?"long":"short");
          let pBO = clamp(0.5 + 0.29*(boBase*(sideBO==="long"?1:-1)), 0.35, 0.96);

          // Aggregate initial probs
          const wT=weightsReg.wTrend, wM=weightsReg.wMR, wB=weightsReg.wBO;
          const pLong0=clamp(wT*(sideTrend==="long"?pTrend:1-pTrend)+ wM*(sideMR==="long"?pMR:1-pMR)+ wB*(sideBO==="long"?pBO:1-pBO),0.30,0.97);
          const pShort0=clamp(wT*(sideTrend==="short"?pTrend:1-pTrend)+ wM*(sideMR==="short"?pMR:1-pMR)+ wB*(sideBO==="short"?pBO:1-pBO),0.30,0.97);

          const vol1h_est_usd=c.qv/24;

          return { c, k5, k15, c5, h5, l5, v5, adx5, atr_bps:atr_bps, spreadBps, pLong0, pShort0,
            upF, upS, up15, up1h, z_vwap, rsi14, trendAlign, em20:em20, em50, em200, slope_atr50, dcHi, dcLo, breakout, mrLocked,
            noShortUp, noLongDown, fadeShortDivergenceOK, fadeLongDivergenceOK, vol1h_est_usd, trendBias };
        }catch{ return null; }
      }));
      for(const x of batch) if(x){ picksRaw.push(x); pfStats.kept++; }
    }
    snapCounts({ pre: picksRaw.length });
    console.log("[gha] pre done", { pre:picksRaw.length, pfStats });

    // Train GP-Cls
    function buildTrainSet(side){ const D=(state.gp_data_clf||[]).filter(r=>r.side===side).slice(-500); return { X:D.map(d=>d.x), y:D.map(d=>d.y) }; }
    const trL=buildTrainSet("long"), trS=buildTrainSet("short");
    const gpClfLong=(trL.X.length>=25)? trainGPClass(trL.X, trL.y, 0.12, 12) : null;
    const gpClfShort=(trS.X.length>=25)? trainGPClass(trS.X, trS.y, 0.12, 12): null;
    run_prov.p_model = { gp_hash: "long="+(gpClfHash(gpClfLong)||"none")+"|short="+(gpClfHash(gpClfShort)||"none"), calib_type:"mixed", calib_n:(state.gp_data_clf?.length||0) };
    state.run.p_model = run_prov.p_model;

    // ---------- Shortlist → Heavy analyze → Confidence rank ----------
    const MAX_DEEP = 30;

    // Pre-rank for shortlist (cheap signals): prefer higher pWin0, ADX, lower spread
    const prelim = picksRaw.map(p => {
      const pWin0 = Math.max(p.pLong0||0, p.pShort0||0);
      const adxN  = clamp((p.adx5-16)/14,0,1);
      const spreadPenalty = Math.max(0,(p.spreadBps||0)-6)/12;
      const score = 0.6*pWin0 + 0.3*adxN - 0.1*spreadPenalty + 0.05*(p.vol1h_est_usd? Math.log(p.vol1h_est_usd+1)/15 : 0);
      return { p, score };
    }).sort((a,b)=> b.score - a.score).slice(0, Math.min(MAX_DEEP, picksRaw.length)).map(x=>x.p);

    snapCounts({ shortlist: prelim.length });
    console.log("[gha] shortlist for heavy analysis:", prelim.length);

    // Heavy analyze and refine
    const refined=[];
    for(let idx=0; idx<prelim.length; idx++){
      try{
        const p=prelim[idx], c=p.c;
        const book=bookMap.get(c.symbol) || await getBookTickerCached(c.symbol);
        if(!book?.bid || !book?.ask) continue;
        const mid=(+book.bid + +book.ask)/2;

        // Depth snapshots for OFI and slope
        const depthA = await getDepthCached(c.symbol);
        await sleep(180+Math.floor(Math.random()*120)); // small gap
        const depthB = await fetchDepth(c.symbol); // fresh
        const depth = depthB||depthA;

        // Multi-TF klines
        const km = await getKMultiTF(c.symbol);
        const tfOK = km["1m"] && km["5m"] && km["15m"] && km["1h"] && km["4h"];
        if(!tfOK){ continue; }

        // TF indicators
        function tfInd(k){
          if(!k?.length) return null;
          const h=k.map(x=>+x[2]), l=k.map(x=>+x[3]), c0=k.map(x=>+x[4]);
          const emF=ema(c0,EMA_FAST), emS=ema(c0,EMA_SLOW);
          const { adx, atr } = computeADX_ATR(h,l,c0,ADX_P)||{ adx:0, atr:0 };
          const vwp=vwapAnchored(h,l,c0,k.map(x=>+x[5]||0), VWAP_5M_WIN);
          const bbz=(function(){ const ret=[]; for(let i=1;i<c0.length;i++) ret.push((c0[i]/c0[i-1])-1); const s=std(ret)||1e-6; const z=(c0.at(-1)-mean(c0.slice(-20)))/(s*Math.sqrt(20)||1e-6); return z; })();
          const up = c0.at(-1)>=emF && c0.at(-1)>=emS;
          return { adx, atr, up, emF, emS, vwap:vwp, bbz };
        }
        const ind1m=tfInd(km["1m"]), ind5=tfInd(km["5m"]), ind15=tfInd(km["15m"]), ind1h=tfInd(km["1h"]), ind4h=tfInd(km["4h"]);
        const tfAlign = [ind5,ind15,ind1h,ind4h].filter(Boolean).reduce((a,b)=> a + (b.up?1:0),0) / Math.max(1,[ind5,ind15,ind1h,ind4h].filter(Boolean).length);

        // Microstructure metrics
        const obiNow = computeOBI(depth, OBI_TOPN);
        const d1=depthWithinPctUSD(depth, mid, 0.01);
        const sideSlipL = slipFromDepth(depth, mid, "long", NOTIONAL);
        const sideSlipS = slipFromDepth(depth, mid, "short", NOTIONAL);
        const slipEstL = sideSlipL?.slip_bps ?? Math.round((p.spreadBps||0)/2);
        const slipEstS = sideSlipS?.slip_bps ?? Math.round((p.spreadBps||0)/2);
        const ofi30s = ofiProxy(depthA, depthB);
        const slopeObj=bookSlope(depth, mid);

        // Allowed sides, cost calc
        const slipL=slipEstL, slipS=slipEstS;
        const costLong=COST_BPS + Math.max(Math.round(p.spreadBps/2), slipL);
        const costShort=COST_BPS + Math.max(Math.round(p.spreadBps/2), slipS);
        if(Math.max(costLong,costShort)>MAX_COST_BPS_HARD) continue;
        if((p.vol1h_est_usd||0) < MIN_VOL_1H_USD) continue;
        const depth1pUSD=(d1.asksUSD||0)+(d1.bidsUSD||0); if(depth1pUSD < DEPTH_1P_MIN_USD) continue;

        // GP features and calibrated p
        const featL=[ clamp((p.adx5-16)/14,0,1), clamp(p.z_vwap,-3,3), (p.rsi14||50)/100, Math.max(0,-obiNow), clamp(p.slope_atr50,0,1) ];
        const featS=[ clamp((p.adx5-16)/14,0,1), clamp(-p.z_vwap,-3,3), (100-(p.rsi14||50))/100, Math.max(0,+obiNow), clamp(p.slope_atr50,0,1) ];
        let pLong=p.pLong0, pShort=p.pShort0, pLong_raw=pLong, pShort_raw=pShort;
        if(gpClfLong) pLong_raw=predictGPClass(gpClfLong, featL).p;
        if(gpClfShort) pShort_raw=predictGPClass(gpClfShort, featS).p;

        const strongTrend=(p.adx5>Math.max(22,MR_ADX_MAX)) || (p.slope_atr50>MR_SLOPE_MAX_ATR50);
        const regime = p.mrLocked ? "trend" : (strongTrend? "trend":"meanrevert");
        pLong = calibrateP(state,"long",regime,pLong_raw);
        pShort= calibrateP(state,"short",regime,pShort_raw);

        const pLong_lcb=wilsonLCB(pLong,80,WILSON_Z), pShort_lcb=wilsonLCB(pShort,80,WILSON_Z);
        const yR=[]; for(let i=1;i<p.c5.length;i++) yR.push(Math.log(p.c5[i]/p.c5[i-1]));
        const mu5=mean(yR)||0, sig5=Math.max(1e-4,std(yR));

        // Styles and TP/SL
        const styleL = (!p.mrLocked && (p.fadeLongDivergenceOK || !LONG_MR_DIVERGENCE_REQ)) ? "mr" : (strongTrend ? "momentum":"trend");
        const styleS = (!p.mrLocked && p.fadeShortDivergenceOK) ? "mr" : (strongTrend ? "momentum":"trend");

        function tpSl(side){
          if(side==="long"){
            if(styleL==="mr"){ return { tp:Math.round(LONG_BOUNCE_TP_ATR*p.atr_bps), sl:Math.round(LONG_BOUNCE_SL_ATR*p.atr_bps) }; }
            return { tp:Math.round(clamp(p.atr_bps*0.95, Math.round(0.60*p.atr_bps), Math.round(1.20*p.atr_bps))),
                     sl:Math.round(clamp(p.atr_bps*0.50, Math.round(0.35*p.atr_bps), Math.round(0.65*p.atr_bps))) };
          }else{
            if(styleS==="mr"){ return { tp:Math.round(clamp(1.0,0.8,1.2)*p.atr_bps), sl:Math.round(clamp(0.5,0.4,0.6)*p.atr_bps) }; }
            return { tp:Math.round(clamp(p.atr_bps*1.00, Math.round(0.70*p.atr_bps), Math.round(1.40*p.atr_bps))),
                     sl:Math.round(clamp(p.atr_bps*0.55, Math.round(0.35*p.atr_bps), Math.round(0.75*p.atr_bps))) };
          }
        }

        // Long candidate
        let candLong=null;
        {
          const { tp, sl }=tpSl("long");
          const sim=pathEVHeavy({entry:mid,tp_bps:tp,sl_bps:sl,side:"long",retSeries:yR,mu:mu5,sigma:sig5,steps:Math.max(1,Math.round(720/300)),N:192,cost_bps:costLong,t_df:Number(process.env.T_SIM_DF||"5"),boot_block:Number(process.env.BOOT_BLOCK||"3")});
          const evLCB=Math.round(pLong_lcb*tp - (1-pLong_lcb)*sl - costLong);
          if(tp>=LONG_EDGE_MULT_MIN*costLong) candLong={ side:"long", p_lcb:pLong_lcb, p_raw:pLong_raw, ev_bps:sim.ev_bps, exp_lcb_bps:evLCB, tp_bps:tp, sl_bps:sl, cost_bps:costLong, style:styleL, regime };
        }
        if (candLong && !btcGreen) candLong = null; // BTC market filter gate for longs

        // Short candidate
        let candShort=null;
        {
          const { tp, sl }=tpSl("short");
          const sim=pathEVHeavy({entry:mid,tp_bps:tp,sl_bps:sl,side:"short",retSeries:yR,mu:mu5,sigma:sig5,steps:Math.max(1,Math.round(720/300)),N:192,cost_bps:costShort,t_df:Number(process.env.T_SIM_DF||"5"),boot_block:Number(process.env.BOOT_BLOCK||"3")});
          const evLCB=Math.round(pShort_lcb*tp - (1-pShort_lcb)*sl - costShort);
          if(tp>=Math.max(3,Number(process.env.EDGE_COST_MULT_MIN||"3"))*costShort) candShort={ side:"short", p_lcb:pShort_lcb, p_raw:pShort_raw, ev_bps:sim.ev_bps, exp_lcb_bps:evLCB, tp_bps:tp, sl_bps:sl, cost_bps:costShort, style:styleS, regime };
        }

        let chosen=candLong&&candShort? (candLong.exp_lcb_bps>=candShort.exp_lcb_bps? candLong: candShort) : (candLong||candShort||null);
        if(!chosen) continue;

        const gp_feat = (chosen.side==="long" ? featL : featS);

        const bestBid = depth?.bids?.[0]?.[0] ? +depth.bids[0][0] : null;
        const bestAsk = depth?.asks?.[0]?.[0] ? +depth.asks[0][0] : null;
        const bidQtyTop = depth?.bids?.[0]?.[1] ? +depth.bids[0][1] : null;
        const askQtyTop = depth?.asks?.[0]?.[1] ? +depth.asks[0][1] : null;
        let microprice_bias_bps = null;
        if (bestBid && bestAsk && bidQtyTop && askQtyTop && mid > 0) {
            const mp = microprice(bestBid, bestAsk, bidQtyTop, askQtyTop);
            microprice_bias_bps = Math.round((mp - mid) / mid * 10000);
        }

        // Micro/regime multipliers for confidence
        const microQ = clamp((Math.max(0, 1 - (p.spreadBps||0)/20)) * (1 - Math.min(0.6, (chosen.cost_bps - COST_BPS)/20)) * (1 + clamp(obiNow, -0.2, 0.2)), 0.5, 1.2);
        const regimeQ = clamp(0.7 + 0.4*tfAlign + 0.2*clamp((ind1h?.adx||0 - 16)/20, 0, 1), 0.6, 1.2);

        // Reliability factor (ECE per key)
        const calib_key=`${chosen.side}_${String(chosen.regime).includes("mean")?"mr":"trend"}`;
        const ece = state?.metrics?.reliability?.[calib_key]?.ece ?? 0.0;
        const reliability = clamp(1 - clamp(+ece||0, 0, 0.5), 0.5, 1.0);
        const riskAdj = 1.0;

        // Confidence
        const conf = confidenceScore({
          p_cal: chosen.p_lcb, ev_bps: chosen.ev_bps, atr_bps: p.atr_bps,
          micro: microQ, regime: regimeQ, reliability, riskAdj
        });

        const reasons = reasonBuilder({
          adx1h: ind1h?.adx||0, ofi30s, mrDivOk: (chosen.side==="long"? p.fadeLongDivergenceOK : p.fadeShortDivergenceOK),
          tfAlign, obi: obiNow, spread_bps:p.spreadBps, slip_bps_est: (chosen.side==="long"? slipEstL: slipEstS)
        });

        refined.push({
          symbol:c.symbol, base:c.base, quote:c.quote, qv:c.qv,
          side:chosen.side, p_lcb:+chosen.p_lcb.toFixed(3), p_raw:+chosen.p_raw.toFixed(3),
          exp_bps:chosen.ev_bps, exp_lcb_bps:chosen.exp_lcb_bps,
          tp_bps:chosen.tp_bps, sl_bps:chosen.sl_bps, rrr:+(chosen.tp_bps/Math.max(1,chosen.sl_bps)).toFixed(2),
          spread_bps:p.spreadBps, cost_bps:chosen.cost_bps,
          adx:+(p.adx5||0).toFixed(1), atr_bps:p.atr_bps, regime:chosen.regime, style:chosen.style,
          hold_sec: clamp(Math.round( (chosen.style==="mr"? 1800: (weightsReg.wTrend>weightsReg.wMR? 720:560)) ), 900, 3600),
          liq_pct:+(liqPct.get(c.symbol)||0.5).toFixed(3),
          ret5:(()=>{ const r=[]; for(let i=1;i<p.c5.length;i++) r.push(Math.log(p.c5[i]/p.c5[i-1])); return r.slice(-36); })(),
          vol1h_est_usd:p.vol1h_est_usd, depth1p_usd:depth1pUSD, obi:+obiNow.toFixed(3),
          entry_book: { bid:+book.bid, ask:+book.ask },
          slip_bps_long: slipEstL, slip_bps_short: slipEstS, spread_bps_entry: p.spreadBps,
          // Heavy features summary for reasons
          tf_align:+tfAlign.toFixed(2), adx1h: ind1h?.adx||0, ofi30s:+ofi30s.toFixed(3), book_slope:slopeObj?.slope||0,
          gp_feat,
          microprice_bias_bps,
          confidence: conf, reasons,
          gp_p:(chosen.side==="long"? pLong_raw : pShort_raw), ens_p:(chosen.side==="long"? pLong : pShort)
        });
      }catch(e){ console.log("[gha] heavy refine warn", e?.message||e); }
    }
    snapCounts({ refined: refined.length });
    console.log("[gha] heavy refine done", { refined: refined.length });

    // Rank by confidence
    refined.sort((a,b)=> b.confidence!==a.confidence ? b.confidence-a.confidence
                        : b.exp_lcb_bps!==a.exp_lcb_bps ? b.exp_lcb_bps-a.exp_lcb_bps
                        : b.exp_bps!==a.exp_bps ? b.exp_bps-a.exp_bps
                        : b.qv-a.qv);

    // Correlation pruning
    const TARGET_K = 3;
    const selected=[];
    for(const cand of refined){
      if(selected.length>=TARGET_K) break;
      let ok=true;
      for(const s of selected){
        const r=corr(cand.ret5||[], s.ret5||[]);
        if((cand.side==="long" && s.side==="long" && r>LONG_SIMILARITY_RHO) || r>0.90){ ok=false; break; }
      }
      if(ok) selected.push(cand);
    }
    console.log("[gha] selected top by confidence:", selected.map(x=>`${x.symbol}:${x.side}:${x.confidence}`).join(", "));

    // Build picks with predicted + reasons + confidence
    const wEv=softmax(selected.map(x=>x.exp_lcb_bps),20);
    let picks = selected.map((x,i)=>{
      const bk=bookMap.get(x.symbol) || { bid:x.entry_book?.bid, ask:x.entry_book?.ask };
      const mid=(bk?.bid && bk?.ask)? ((+bk.bid + +bk.ask)/2) : null;

      // Entry policy
      let entry_policy = "limit";
      let entry_limit=null, tp_abs=null, sl_abs=null;

      if (mid!=null){
        if(x.side==="long"){
          const slF=x.sl_bps/10000, tpF=x.tp_bps/10000;
          entry_limit = mid*(1 - Math.max(0.001, slF*0.5));
          tp_abs = entry_limit*(1 + tpF);
          sl_abs = entry_limit*(1 - slF);
          entry_policy="smart_swing_limit";
        }else{
          const slF=x.sl_bps/10000, tpF=x.tp_bps/10000;
          entry_limit = mid*(1 + slF);
          tp_abs = entry_limit*(1 - tpF);
          sl_abs = entry_limit*(1 + slF);
        }
      }

      const ttl = clamp(Math.round((x.hold_sec||720)+i*12), TTL_MIN, TTL_MAX);

      // Sizing by risk and style
      let size_bps=0;
      if(Number(process.env.FORCE_SIZE_BPS||"0")>0) size_bps=Math.round(Number(process.env.FORCE_SIZE_BPS));
      else{
        const base = x.sl_bps>0? Math.min(220, Math.round((wEv[i]*TARGET_PORT_RISK_BPS/x.sl_bps)*100)) : 0;
        size_bps = Math.round(base * ((x.style==="momentum")? clamp(MOMENTUM_SIZE_FACTOR,0.25,0.6):1.0));
      }

      // Management
      const exec_policy = { exec:"maker_or_strict_limit", max_slip_bps:3, prefer_post_only: (x.spread_bps||99)<=6 && (x.depth1p_usd||0)>=DEPTH_1P_MIN_USD };

      const entry_ts_ms = Date.now();
      const ttl_ts_ms = entry_ts_ms + ttl*1000;
      const trade_id = `${x.symbol}:${entry_ts_ms}`;

      const notional_usd = NOTIONAL;

      // Reasons compact text
      const reasons_text = (x.reasons||[]).slice(0,3).map(r=> `${r.factor}:${r.value} (${r.contribution>=0?"+":""}${r.contribution})`);

      // Predicted block for Gist
      const calInfo = calibratorInfo(state, x.side, x.regime);
      const predicted = {
        ts_ms: entry_ts_ms,
        p_cal: x.p_lcb, p_lcb: x.p_lcb, ev_bps: x.exp_bps, confidence_score: x.confidence,
        model: { gp_p:+(x.gp_p||0).toFixed(3), metalabel_p:null, ensemble_p:+(x.ens_p||x.p_lcb||0).toFixed(3), calib_type:(calInfo.type||"raw"), calib_n:(calInfo.n||0), p_model: run_prov.p_model, gp_feat: x.gp_feat },
        style: x.style, tp_bps: x.tp_bps, sl_bps: x.sl_bps, cost_bps: x.cost_bps,
        micro: { spread_bps: x.spread_bps, slip_bps_est: x.side==="long"? x.slip_bps_long: x.slip_bps_short, obi: x.obi, ofi_30s: x.ofi30s||0, microprice_bias_bps: x.microprice_bias_bps, book_slope: x.book_slope||0 },
        regime: { tf_align: { "1m":null, "5m":null, "15m":null, "1h":null, "4h": x.tf_align }, adx: { "5m": +(x.adx||0), "1h": +(x.adx1h||0) }, squeeze:{ "5m":null, "15m":null }, donchian_breakout: null },
        seasonality: { tod_bucket: new Date().getUTCHours(), tod_mu: (x.tod_mu||[])[new Date().getUTCHours()]||0 },
        risk: { var95_bps: null, es95_bps: null, cluster_id: null },
        reasons: x.reasons
      };

      return { symbol:x.base, symbol_full:x.symbol, quote:x.quote,
        side:x.side, rank:i+1, ttl_sec:ttl, p_win:Math.max(0.5, x.p_lcb), p_lcb:x.p_lcb, p_raw:x.p_raw, calib_key:`${x.side}_${String(x.regime).includes("mean")?"mr":"trend"}`,
        tp_bps:x.tp_bps, sl_bps:x.sl_bps, rrr:+(x.tp_bps/Math.max(1,x.sl_bps)).toFixed(2),
        exp_lcb_bps:x.exp_lcb_bps, ev_bps:x.exp_bps,
        spread_bps:x.spread_bps, cost_bps:x.cost_bps, adx:x.adx, atr_bps:x.atr_bps, n_conf:90, obi:x.obi||0,
        regime:x.regime, style:x.style, liq_pct:x.liq_pct, fill_prob:0.7,
        entry_policy, entry_type:"limit", activation:"on_fill", entry_mid:mid, entry_limit, tp_abs, sl_abs,
        size_bps, tier:"confidence", mp_fill:false, always3:false,
        gp_feat: x.gp_feat, ret5:x.ret5, direction_env:DIRECTION, side_bias:"both",
        vol1h_est_usd:x.vol1h_est_usd, depth1p_usd:x.depth1p_usd||0, exec:exec_policy,
        mgmt:{ be_at_r:0.6, partial_take_at_r:0.7, partial_take_pct:0.4, trail_atr_mult:0.5 },
        // predicted + reasons + confidence
        predicted, confidence:x.confidence, reasons:x.reasons, reasons_text, 
        // enrichment
        trade_id, entry_ts_ms, ttl_ts_ms,
        entry_book: { bid: bk?.bid||null, ask: bk?.ask||null }, spread_bps_entry: x.spread_bps, slip_bps_entry: x.side==="long"? x.slip_bps_long: x.slip_bps_short,
        depth1p_entry_usd: x.depth1p_usd, obi_entry: x.obi,
        notional_usd, run_id: run_prov.run_id, code_commit_sha: run_prov.code_commit_sha, pusher_version,
        config_hash, exchange_base: BASE, mexc_server_time_ms: mexcTime.mexc_server_time_ms, mexc_time_offset_ms: mexcTime.mexc_time_offset_ms,
        p_model: run_prov.p_model, calib_type: predicted.model.calib_type, calib_n: predicted.model.calib_n,
        events: [{ ts_ms: entry_ts_ms, type:"selected", meta:{ tier: "confidence", score: x.confidence, reasons: reasons_text } }]
      };
    });

    // t‑copula VaR/ES throttle
    try{
      const varStats=portfolioVaR_ES_tCopula(picks, Number(process.env.T_VA_DF||"6"));
      const ES_LIMIT=-220;
      if(varStats.ES95_bps < ES_LIMIT){
        const scale=clamp(ES_LIMIT/Math.min(-1e-6, varStats.ES95_bps), 0.35,1);
        picks=picks.map(p=>({
          ...p,
          size_bps: Math.max(4, Math.round(p.size_bps*scale)),
          notional_usd: Math.max(500, Math.round((p.notional_usd || NOTIONAL)*scale))
        }));
        console.log("[gha] VaR/ES throttle (t-copula)", varStats, "scale", scale);
      } else console.log("[gha] VaR/ES ok", varStats);
    }catch(e){ console.log("[gha] VaR/ES warn", e?.message||e); }

    // Save cooldown + pending + push log
    try{
      const nowMs=Date.now(); const ideasTs=new Date(nowMs).toISOString();
      for(const p of picks){
        const bk=bookMap.get(p.symbol_full); const mid=bk? (bk.bid+bk.ask)/2 : 0;
        const entry_mid=p.entry_mid ?? mid;
        const entry_new=p.entry_limit ?? (p.side==="long" ? entry_mid*(1 - p.sl_bps/10000) : entry_mid*(1 + p.sl_bps/10000));
        const tp_abs=p.tp_abs ?? (p.side==="long" ? entry_new*(1 + p.tp_bps/10000) : entry_new*(1 - p.tp_bps/10000));
        const sl_abs=p.sl_abs ?? (p.side==="long" ? entry_new*(1 - p.sl_bps/10000) : entry_new*(1 + p.sl_bps/10000));
        state.cooldown[p.symbol]=nowMs; state.cooldown_side[p.symbol]={ side:p.side, ts_ms:nowMs };
        state.pending.push({
          ts:ideasTs, ts_ms:nowMs, symbolFull:p.symbol_full, base:p.symbol, quote:p.quote, side:p.side,
          entry_policy:p.entry_policy, entry_mid, entry_price:entry_new, entry_limit:entry_new, tp_abs, sl_abs, hold_sec:p.ttl_sec,
          tp_bps:p.tp_bps, sl_bps:p.sl_bps, regime:p.regime, cost_bps:p.cost_bps, gp_feat:p.gp_feat, tier:p.tier, mp_fill:!!p.mp_fill, always3:!!p.always3,
          p_lcb:p.p_lcb, p_raw:p.p_raw, p_win0:p.p_win, exp_lcb_bps:p.exp_lcb_bps, style_final:p.style, direction_env:p.direction_env, calib_key:p.calib_key,
          // enriched
          trade_id: p.trade_id, entry_ts_ms: p.entry_ts_ms, ttl_ts_ms: p.ttl_ts_ms,
          entry_book: p.entry_book, spread_bps_entry: p.spread_bps_entry, slip_bps_entry: p.slip_bps_entry,
          depth1p_entry_usd: p.depth1p_entry_usd, obi_entry: p.obi_entry,
          notional_usd: p.notional_usd, size_bps: p.size_bps,
          run_id: p.run_id, code_commit_sha: p.code_commit_sha, pusher_version: p.pusher_version,
          config_hash: p.config_hash, exchange_base: p.exchange_base,
          mexc_server_time_ms: p.mexc_server_time_ms, mexc_time_offset_ms: p.mexc_time_offset_ms,
          p_model: p.p_model, calib_type: p.calib_type, calib_n: p.calib_n,
          events: p.events,
          // predicted + decision context
          predicted: p.predicted,
          decision_context: {
            tfs: ["1m","5m","15m","1h","4h"],
            features_hash: sha256Hex(JSON.stringify({ sym:p.symbol_full, ts:p.entry_ts_ms, feats:(p.gp_feat||[]).slice(0,8) }).slice(0,256)),
            config_hash, run_id: p.run_id
          }
        });
      }
      if(state.pending.length>550) state.pending=state.pending.slice(-550);
      try{
        state.push_log=Array.isArray(state.push_log)? state.push_log : [];
        state.push_log.push({ ts:new Date().toISOString(), tier:selectionTier, direction_env:DIRECTION, top_n:picks.length,
          counts:{ confidence:picks.length },
          regime_post:weightsReg, bandit_choice:banditChoice, force_top_n: true,
          symbols:picks.map(p=>({ symbol:p.symbol_full, side:p.side, style:p.style, tier:p.tier, confidence:p.confidence })) });
        if(state.push_log.length>300) state.push_log=state.push_log.slice(-300);
      }catch(e){ console.log("[gha] push_log warn", e?.message||e); }
      fitCalibrators(state); updateMetricsAndDrift(state); updateReliability(state);
      state.last_ts=new Date().toISOString();
      await saveState(persist,state);
    }catch(e){ console.log("[gha] state save warn", e?.message||e); }

    // POST
    const meta={
      exchange:"mexc", exchange_base:BASE,
      counts:{ universe:universe.length, refined:refined.length, selected:picks.length },
      filters:{
        dyn_min_qv:dynMinQV, univ_target_min:UNIV_TARGET_MIN, univ_target_max:UNIV_TARGET_MAX,
        max_spread_bps:MAX_SPREAD_BPS, ema_fast:EMA_FAST, ema_slow:EMA_SLOW, adx_p:ADX_P, atr_p:ATR_P, vwap_5m_win:VWAP_5M_WIN,
        depth_limit:DEPTH_LIMIT, obi_topn:OBI_TOPN,
        cooldown_min:COOLDOWN_MS/60000, flip_guard_min:FLIP_GUARD_MS/60000,
        fees_bps:COST_BPS, notional_usd:NOTIONAL,
        exp_lcb_min_bps:EXP_LCB_MIN_THIS, wilson_z:WILSON_Z,
        calibrated:true, gp_cls:true, isotonic:true, platt:true,
        heavy_tail_sim:true, t_copula_var_es:true,
        mp_top_pool:MP_TOP_POOL, always3:false, rank_fill:false
      },
      dd_gate:(()=>{ const s=state.equity||[]; const day=Date.now()-24*3600*1000; let pnl24=0,cum=0,peak=0,dd=0; for(const e of s){ if(e.ts_ms>=day) pnl24+=e.pnl_bps; cum+=e.pnl_bps; if(cum>peak) peak=cum; dd=Math.min(dd,cum-peak); } return { pnl24_bps:Math.round(pnl24), peak_dd_bps:Math.round(dd), throttle }; })(),
      tod:{ active:S_H!=null&&E_H!=null, start:S_H, end:E_H },
      tier:selectionTier, regime_post:weightsReg, direction_env:DIRECTION, bandit_choice:banditChoice, metrics:state.metrics||{},
      schema_version:"1.3.0", run: run_prov
    };

    // Add idea logs (confidence + reasons)
    const ideaLogs = (picks||[]).map(p => ({
      symbol: p.symbol_full, side: p.side, confidence: p.confidence, reasons: p.reasons_text,
      p_cal:+(p.p_lcb||0).toFixed(3), ev_bps: p.ev_bps, tp_bps: p.tp_bps, sl_bps: p.sl_bps,
      spread_bps: p.spread_bps, slip_est_bps: p.slip_bps_entry, obi: p.obi_entry, es95_bps: null
    }));
    for(const il of ideaLogs){
      console.log(`[gha] idea ${il.symbol} ${il.side} conf=${il.confidence} reasons=${(il.reasons||[]).join("; ")}`);
    }

    const payload={ ts:new Date().toISOString(), mode:"normal", source:"external_pusher", meta:{ origin:"github_actions", reason, ...meta, idea_logs: ideaLogs }, top_n:picks.length||0, ideas:picks||[] };
    console.log(`[gha] pushing ${picks.length} ideas (${selectionTier}) to ${PUSH_URL}`);
    try{
      const r=await fetchWithTimeout(PUSH_URL,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":`Bearer ${PUSH_TOKEN}` }, body: JSON.stringify(payload) },15000);
      let txt=""; try{ txt=await r.text(); }catch{} console.log("[gha] push status", r?.status||"ERR", (txt||"").slice(0,400));
    }catch(e){ console.log("[gha] push failed", e?.message||e); }

  }catch(e){
    reason=reason!=="ok"?reason:"data_error";
    const countsSnap=(()=>{ try{ return JSON.parse(require('fs').readFileSync('/tmp/pusher_counts.json','utf8')||'{}'); }catch{return {}} })();
    const payload={ ts:new Date().toISOString(), mode:"normal", source:"external_pusher", meta:{ origin:"github_actions", reason, error:(e?.message||String(e)).slice(0,220), counts:countsSnap }, top_n:0, ideas:[] };
    console.log("[gha] pushing 0 ideas to", process.env.WORKER_PUSH_URL||"");
    try{
      const r=await fetchWithTimeout(process.env.WORKER_PUSH_URL,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":`Bearer ${process.env.PUSH_TOKEN||""}` }, body: JSON.stringify(payload) },15000);
      let txt=""; try{ txt=await r.text(); }catch{} console.log("[gha] push status", r?.status||"ERR", (txt||"").slice(0,200));
    }catch(e2){ console.log("[gha] push failed", e2?.message||e2); }
  }
  // ------------- End main try/catch handled above -------------

})(); // end IIFE
