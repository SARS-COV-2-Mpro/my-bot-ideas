name: Ideas Pusher (MEXC Ultimate 7.7.7)

on:
  repository_dispatch:
    types: [run_B]
  workflow_dispatch: {}

permissions:
  contents: read

concurrency:
  group: ideas-mexc-ultimate
  cancel-in-progress: true

jobs:
  push:
    runs-on: ubuntu-latest
    timeout-minutes: 12

    env:
      # Required secrets
      WORKER_PUSH_URL: ${{ secrets.WORKER_PUSH_URL }}
      PUSH_TOKEN: ${{ secrets.PUSH_TOKEN }}
      WORKER_PUSH_URL_V2: ${{ secrets.WORKER_PUSH_URL_V2 }}

      # Required for trade reconciliation
      MEXC_API_KEY: ${{ secrets.MEXC_API_KEY }}
      MEXC_SECRET_KEY: ${{ secrets.MEXC_SECRET_KEY }}

      # Optional (safe defaults inside the script)
      GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
      GIST_ID: ${{ secrets.GIST_ID }}

      # Exchange + tuning knobs (via Repo/Org Variables)
      EXCHANGE: mexc
      MIN_QV_USD: ${{ vars.MIN_QV_USD }}
      TOP_N: ${{ vars.TOP_N }}
      MAX_SPREAD_BPS: ${{ vars.MAX_SPREAD_BPS }}
      EXP_LCB_MIN_BPS: ${{ vars.EXP_LCB_MIN_BPS }}
      FEES_BPS: ${{ vars.FEES_BPS }}
      NOTIONAL_USD: ${{ vars.NOTIONAL_USD }}
      MEXC_DEPTH_LIMIT: ${{ vars.MEXC_DEPTH_LIMIT }}
      OBI_TOPN: ${{ vars.OBI_TOPN }}
      ACTIVE_UTC_START: ${{ vars.ACTIVE_UTC_START }}
      ACTIVE_UTC_END: ${{ vars.ACTIVE_UTC_END }}
      MEXC_BASE: ${{ vars.MEXC_BASE }}
      FORCE_SIZE_BPS: ${{ vars.FORCE_SIZE_BPS }}

      # New Confidence Model Knobs
      DIRECTION: ${{ vars.DIRECTION }}
      MR_SLOPE_MAX_ATR50: ${{ vars.MR_SLOPE_MAX_ATR50 }}
      MR_BREAKOUT_DC_N: ${{ vars.MR_BREAKOUT_DC_N }}
      MR_BREAKOUT_RET15_ATR: ${{ vars.MR_BREAKOUT_RET15_ATR }}
      MR_LOCKOUT_SEC: ${{ vars.MR_LOCKOUT_SEC }}
      MAX_COST_BPS_HARD: ${{ vars.MAX_COST_BPS_HARD }}
      MIN_VOL_1H_USD: ${{ vars.MIN_VOL_1H_USD }}
      DEPTH_1P_MIN_USD: ${{ vars.DEPTH_1P_MIN_USD }}
      NO_LONG_DOWN_ENABLE: ${{ vars.NO_LONG_DOWN_ENABLE }}
      LONG_DOWN_RSI_CUTOFF: ${{ vars.LONG_DOWN_RSI_CUTOFF }}
      LONG_MR_DIVERGENCE_REQ: ${{ vars.LONG_MR_DIVERGENCE_REQ }}
      LONG_EDGE_MULT_MIN: ${{ vars.LONG_EDGE_MULT_MIN }}
      LONG_BOUNCE_SL_ATR: ${{ vars.LONG_BOUNCE_SL_ATR }}
      LONG_BOUNCE_TP_ATR: ${{ vars.LONG_BOUNCE_TP_ATR }}
      LONG_SIMILARITY_RHO: ${{ vars.LONG_SIMILARITY_RHO }}

      # New (MTF + Provenance + Align)
      MIN_TF_ALIGN: ${{ vars.MIN_TF_ALIGN }} # default handled in script
      TF_WEIGHTS: ${{ vars.TF_WEIGHTS }}     # e.g. {"1m":0.1,"5m":0.3,"15m":0.25,"1h":0.2,"4h":0.15}
      STRATEGY_NAME: ${{ vars.STRATEGY_NAME }}
      MODEL_VERSION: ${{ vars.MODEL_VERSION }}
      SCHEMA_VERSION: ${{ vars.SCHEMA_VERSION }}
      GIT_SHA: ${{ github.sha }}

    steps:
      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Run pusher (always-push + clear logs)
        shell: bash
        run: |
          set -euo pipefail

          # Hard fail only on true misconfig (so setup problems aren't hidden)
          if [[ -z "${WORKER_PUSH_URL:-}" || -z "${PUSH_TOKEN:-}" ]]; then
            echo "[gha] Missing WORKER_PUSH_URL or PUSH_TOKEN"
            exit 1
          fi

          set +e
          node - <<'NODE'
          (async ()=>{
          'use strict';
          const crypto = require('crypto');
          const MODEL_VERSION=(process.env.MODEL_VERSION||"6.4");
          const UA = `gh-actions-ideas-mexc-ultimate/${MODEL_VERSION} (+https://github.com/)`;

          // ========== DISTRIBUTED LOCK MANAGER & CIRCUIT BREAKER ==========
          const acquireLock = async (persist, lockName, ttlMs = 30000) => {
            const lockId = crypto.randomUUID();
            const lockKey = `lock:${lockName}`;
            const maxRetries = 10;
            
            for (let i = 0; i < maxRetries; i++) {
              try {
                const { state, etag } = await fetchCurrentState(persist);
                const now = Date.now();
                const currentLock = state.locks?.[lockKey];
                
                if (!currentLock || currentLock.expires < now) {
                  state.locks = state.locks || {};
                  state.locks[lockKey] = { id: lockId, expires: now + ttlMs, acquired: now };
                  
                  const saved = await saveStateAtomic(persist, state, { requireEtag: true, etag: etag });
                  if (saved) return { 
                    lockId, 
                    release: () => releaseLock(persist, lockKey, lockId) 
                  };
                }
                
                await sleep(500 + Math.random() * 500);
              } catch (e) {
                log(`Lock acquire attempt ${i+1} failed:`, e.message);
              }
            }
            throw new Error(`Failed to acquire lock: ${lockName}`);
          };

          const releaseLock = async (persist, lockKey, lockId) => {
            try {
              const { state, etag } = await fetchCurrentState(persist);
              if(state.locks?.[lockKey]?.id === lockId) {
                delete state.locks[lockKey];
                await saveStateAtomic(persist, state, { requireEtag: true, etag: etag });
              }
            } catch (e) {
              log(`Failed to release lock ${lockKey}: ${e.message}`);
            }
          };

          const CircuitBreaker = {
            states: {},
            async execute(name, fn, { maxFailures = 5, resetMs = 60000, timeout = 10000 } = {}) {
              const state = this.states[name] || { failures: 0, lastFailure: 0, isOpen: false };
              if (state.isOpen && Date.now() - state.lastFailure < resetMs) {
                throw new Error(`Circuit breaker OPEN for ${name}`);
              }
              try {
                const result = await Promise.race([
                  fn(),
                  new Promise((_, rej) => setTimeout(() => rej(new Error('Timeout')), timeout))
                ]);
                state.failures = 0;
                state.isOpen = false;
                this.states[name] = state;
                return result;
              } catch (error) {
                state.failures++;
                state.lastFailure = Date.now();
                if (state.failures >= maxFailures) {
                  state.isOpen = true;
                  log(`⚠️ Circuit breaker OPENED for ${name} after ${state.failures} failures`);
                }
                this.states[name] = state;
                throw error;
              }
            }
          };

          // ---------------- Utils ----------------
          const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
          const tanh=(x)=>Math.tanh(x);
          const sum=(a)=>a.reduce((x,y)=>x+y,0);
          const mean=(a)=>a.length?sum(a)/a.length:0;
          const std=(a)=>{ const m=mean(a); let v=0; for(const x of a) v+=(x-m)*(x-m); return a.length>1?Math.sqrt(v/(a.length-1)):0; };
          const ema=(arr,p)=>{ if(!arr||arr.length<p) return null; const k=2/(p+1); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; for(let i=p;i<arr.length;i++) e=arr[i]*k+e*(1-k); return e; };
          const rsi=(cl,p=14)=>{ if(!cl||cl.length<=p) return null; let g=0,l=0; for(let i=1;i<=p;i++){ const d=cl[i]-cl[i-1]; g+=Math.max(0,d); l+=Math.max(0,-d); } let ag=g/p, al=l/p; for(let i=p+1;i<cl.length;i++){ const d=cl[i]-cl[i-1]; ag=(ag*(p-1)+Math.max(0,d))/p; al=(al*(p-1)+Math.max(0,-d))/p; } const rs=al===0?100:ag/al; return 100-100/(1+rs); };
          const computeADX_ATR=(h,l,c,p=14)=>{ const n=c.length; if(n<p+2) return null; const TR=[],plusDM=[],minusDM=[]; for(let i=1;i<n;i++){ const up=h[i]-h[i-1], down=l[i-1]-l[i]; plusDM.push((up>down&&up>0)?up:0); minusDM.push((down>up&&down>0)?down:0); TR.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1]))); } let trN=0,pdmN=0,ndmN=0; for(let i=0;i<p;i++){ trN+=TR[i]; pdmN+=plusDM[i]; ndmN+=minusDM[i]; } let pDI=100*(pdmN/(trN||1)), nDI=100*(ndmN/(trN||1)); let dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1), adx=dx; for(let i=p;i<TR.length;i++){ trN=trN-(trN/p)+TR[i]; pdmN=pdmN-(pdmN/p)+plusDM[i]; ndmN=ndmN-(ndmN/p)+minusDM[i]; pDI=100*(pdmN/(trN||1)); nDI=100*(ndmN/(trN||1)); dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1); adx=((adx*(p-1))+dx)/p; } const atr=trN/p; return { adx, atr, trLast: TR.at(-1) }; };
          const vwapAnchored=(h,l,c,v,win)=>{ if(!c?.length) return null; const n=c.length,s=Math.max(0,n-win); let pv=0,vv=0; for(let i=s;i<n;i++){ const tp=(h[i]+l[i]+c[i])/3; const vol=+v[i]||0; pv+=tp*vol; vv+=vol; } return vv>0?pv/vv:c.at(-1); };
          const corr=(a,b)=>{ const n=Math.min(a?.length||0,b?.length||0); if(n<5) return 0; const as=a.slice(-n), bs=b.slice(-n); const ma=mean(as), mb=mean(bs); let num=0,da=0,db=0; for(let i=0;i<n;i++){ const xa=as[i]-ma, xb=bs[i]-mb; num+=xa*xb; da+=xa*xa; db+=xb*xb; } const den=Math.sqrt(da*db)||1; return num/den; };
          const wilsonLCB=(p,n,z=1.34)=>{ if(n<=0) return p; const z2=z*z; const a=p + z2/(2*n); const b=z*Math.sqrt((p*(1-p)+z2/(4*n))/n); const c=1+z2/n; return clamp((a-b)/c, 0, 1); };
          const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
          const jitter=(ms)=>ms + Math.floor(Math.random()*ms*0.25);
          const log=(...a)=>console.log("[gha]",...a);
          const softmax=(arr,t=20)=>{ const m=Math.max(...arr,0); const ex=arr.map(x=>Math.exp((x-m)/t)); const s=ex.reduce((a,b)=>a+b,0)||1; return ex.map(x=>x/s); };
          const sigmoid=(z)=>1/(1+Math.exp(-z));
          const logit=(p)=>{ const eps=1e-6; const pp=Math.min(1-eps,Math.max(eps,p)); return Math.log(pp/(1-pp)); };
          let bmSpare=null;
          const randn=()=>{ if(bmSpare!=null){ const v=bmSpare; bmSpare=null; return v; } let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random(); const r=Math.sqrt(-2*Math.log(u)); const th=2*Math.PI*v; bmSpare=r*Math.sin(th); return r*Math.cos(th); };
          const randt=(df)=>{ if(df<=2) df=2.01; const z=randn(); let x2=0; for(let i=0;i<Math.floor(df);i++){ const z2=randn(); x2+=z2*z2; } const frac=df-Math.floor(df); if(frac>0){ const zf=randn(); x2+=frac*zf*zf; } const chi=x2||1e-6; return z / Math.sqrt(chi/df); };
          const kalman1D=(obs,{q=1e-5,r=1e-3,x0=null,p0=1e-2}={})=>{ if(!obs?.length) return []; let x=(x0==null?obs[0]:x0), p=p0; const out=[]; for(const z of obs){ p+=q; const K=p/(p+r); x=x+K*(z-x); p=(1-K)*p; out.push(x); } return out; };
          const pathEVHeavy=({entry,tp_bps,sl_bps,side,retSeries,mu,sigma,steps,N=192,cost_bps=10,t_df=5,boot_block=3})=>{ const up=(side==="long"), tpF=tp_bps/10000, slF=sl_bps/10000; let ev=0, wins=0; const rets=retSeries||[]; const boot1=()=>{ if(rets.length<8) return Array(steps).fill(0).map(()=> sigma*Math.sqrt(1/steps)*randn()); const out=[]; while(out.length<steps){ const start=Math.floor(Math.random()*(rets.length-boot_block)); for(let k=0;k<boot_block && out.length<steps;k++) out.push(rets[start+k]||0); } return out.slice(0,steps); }; for(let n=0;n<N;n++){ const mode=(n%2===0)?"t":"boot"; let S=entry, tp=up? entry*(1+tpF):entry*(1-tpF), sl=up? entry*(1-slF):entry*(1+slF); let pnl_bps=0,win=0; const rs=(mode==="t")? Array(steps).fill(0).map(()=> mu + sigma*randt(t_df)/Math.sqrt(steps)) : boot1(); for(let t=0;t<steps;t++){ S*=(1+rs[t]); if(up){ if(S>=tp){ pnl_bps=tp_bps-cost_bps; win=1; break;} if(S<=sl){ pnl_bps=-sl_bps-cost_bps; win=0; break;} } else { if(S<=tp){ pnl_bps=tp_bps-cost_bps; win=1; break;} if(S>=sl){ pnl_bps=-sl_bps-cost_bps; win=0; break;} } if(t===steps-1){ const ret=up? (S/entry-1):(entry/S-1); pnl_bps=Math.round(ret*10000)-cost_bps; win=pnl_bps>0?1:0; } } ev+=pnl_bps; wins+=win; } const p=wins/N, ev_mean=ev/N; return { p, ev_bps:Math.round(ev_mean) }; };

          // ========== ORDER LIFECYCLE MANAGER ==========
          class OrderManager {
            constructor(state) {
              this.state = state;
              this.reconciliationCache = new Map();
            }
            async validateOrderBeforeCleanup(order) {
              const cid = order.client_order_id || order.clientOrderId;
              for (let i = 0; i < 3; i++) {
                const openOrders = await fetchOpenOrders();
                if (!openOrders) {
                  await sleep(1000);
                  continue;
                }
                const isLive = openOrders.some(o => (o.clientOrderId || o.clientOrderID) === cid);
                if (isLive) return false;
                const trades = await fetchMyTrades(order.symbolFull, Date.now() - 300000);
                if (trades?.some(t => t.orderId == cid)) return false; // Note: MEXC uses orderId in trade history
              }
              return true;
            }
            async transitionOrder(orderId, fromStatus, toStatus, metadata = {}) {
              const order = this.state.pending.find(p => (p.client_order_id || p.clientOrderId) === orderId);
              if (!order) throw new Error(`Order ${orderId} not found`);
              if (order.status !== fromStatus) {
                throw new Error(`Invalid transition: ${order.status} -> ${toStatus}`);
              }
              order.status = toStatus;
              order.status_history = order.status_history || [];
              order.status_history.push({
                from: fromStatus, to: toStatus, ts: Date.now(), metadata
              });
              log(`📋 Order ${orderId}: ${fromStatus} -> ${toStatus}`);
              return order;
            }
          }

          // ---------- New Helpers ----------
          const uuidv4=()=>{ try{ return crypto.randomUUID(); }catch{ const b=crypto.randomBytes(16); b[6]=(b[6]&0x0f)|0x40; b[8]=(b[8]&0x3f)|0x80; const h=b.toString("hex"); return [h.slice(0,8),h.slice(8,12),h.slice(12,16),h.slice(16,20),h.slice(20)].join("-"); } };
          const mkClientOrderId = (prefix="mxu") => {
            const raw = (crypto.randomUUID ? crypto.randomUUID() : uuidv4()).replace(/-/g, "");
            const base = (prefix + "_" + raw).replace(/[^A-Za-z0-9_-]/g, "").slice(0, 30);
            return base.padEnd(Math.max(24, base.length), "0");
          };
          const hashObj=(o)=>{ const norm=(x)=>{ if(x&&typeof x==="object"&&!Array.isArray(x)){ const ks=Object.keys(x).sort(); const y={}; for(const k of ks) y[k]=norm(x[k]); return y; } if(Array.isArray(x)) return x.map(norm); return x; }; const s=JSON.stringify(norm(o)); return crypto.createHash("sha256").update(s).digest("hex"); };
          const toCSVLine=(row,keys)=> keys.map(k=>{ let v=row?.[k]; if(v==null) return ""; if(typeof v==="object") v=JSON.stringify(v); const s=String(v); return s.includes(",")||s.includes("\n")||s.includes('"')? `"${s.replace(/"/g,'""')}"`: s; }).join(",");

          const slopeBps=(arr,len=21)=>{ if(!arr?.length||arr.length<Math.max(5,len)) return 0; const s=arr.slice(-len); const n=s.length; const last=s[n-1]||1; const mx=(n-1)/2; let num=0,den=0; for(let i=0;i<n;i++){ const x=i, y=((s[i]||last)-last)/last*10000; num+=(x-mx)*y; den+=(x-mx)*(x-mx); } return den>0? num/den : 0; };

          const computeMTFIndicators=(km,weights)=>{ const TFs=["1m","3m","5m","15m","30m","1h","2h","4h","12h","1d"]; const wNorm=(()=>{ let out={}; let sw=0; for(const tf of TFs){ const w=+((weights&&weights[tf])||0); if(w>0){ out[tf]=w; sw+=w; } } if(sw<=0){ out={"1m":0.08,"3m":0.08,"5m":0.12,"15m":0.15,"30m":0.12,"1h":0.12,"2h":0.10,"4h":0.08,"12h":0.07,"1d":0.08}; sw=1; } for(const k of Object.keys(out)) out[k]=out[k]/sw; return out; })();
            const perTF={}; const agg={ rsi:0, adx:0, atr_bps:0, roc1:0, roc3:0 }; let ww=0; const retSeries={};
            for(const tf of Object.keys(wNorm)){
              const k=km?.[tf]; if(!k?.length) continue;
              const c=k.map(x=>+x[4]), h=k.map(x=>+x[2]), l=k.map(x=>+x[3]);
              const rsi14=rsi(c,14)||50;
              const adx14=(computeADX_ATR(h,l,c,14)?.adx)||0;
              const atr=(computeADX_ATR(h,l,c,14)?.atr)||0;
              const atr_bps=Math.round((atr/(c.at(-1)||1))*10000);
              const roc1=(c.at(-1)/(c.at(-2)||c.at(-1)) - 1);
              const roc3=(c.at(-1)/(c.at(-4)||c.at(-1)) - 1);
              perTF[tf]={ rsi:rsi14, adx:adx14, atr_bps, roc1, roc3, close:c.at(-1) };
              const w=wNorm[tf]; agg.rsi+=w*rsi14; agg.adx+=w*adx14; agg.atr_bps+=w*atr_bps; agg.roc1+=w*roc1; agg.roc3+=w*roc3; ww+=w;
              const rets=[]; for(let i=1;i<c.length;i++) rets.push(Math.log(c[i]/c[i-1])); retSeries[tf]=rets.slice(-120);
            }
            if(ww<=0) return { agg:{ rsi:50, adx:0, atr_bps:0, roc1:0, roc3:0 }, tfAlign:0, perTF:{} };
            const tfs=Object.keys(perTF); let pairs=0, acc=0;
            for(let i=0;i<tfs.length;i++) for(let j=i+1;j<tfs.length;j++){ const a=retSeries[tfs[i]]||[], b=retSeries[tfs[j]]||[]; const r=corr(a,b); acc+=r; pairs++; }
            const tfAlign=pairs>0? acc/pairs : 0;
            return { agg, tfAlign, perTF, weights:wNorm };
          };

          const getTradeFingerprint=(t)=>{ try{
            const sym=(t.symbol||"").toUpperCase();
            const side=(t.isBuyer===true||t.side==="BUY")?"B":"S";
            const oid=t.orderId!=null?t.orderId:(t.orderID!=null?t.orderID:"");
            const tid=t.id!=null?t.id:(t.tradeId!=null?t.tradeId:"");
            const q=Math.round((+t.qty||+t.executedQty||0)*1e8);
            const p=Math.round((+t.price||0)*1e8);
            const cmA=(t.commissionAsset||t.cma||"").toUpperCase();
            const mk=(t.isMaker===true)?"M":(t.isMaker===false)?"T":"?";
            return [sym,side,oid,tid,q,p,cmA,mk].join(":");
          }catch{ return String(t?.id||t?.orderId||Math.random()); } };

          const DROPPABLE_STATUSES = new Set(["planned","placed","pending","queued","ready"]);

          async function cleanupPendingBeforePlanning(state, heartbeat) {
            const orderManager = new OrderManager(state);
            let droppedCount = 0;
            const now = Date.now();
            const keep = [];

            for (const p of (state.pending || [])) {
              const status = (p.status || "planned").toLowerCase();
              const noEntryYet = !p.entry_ts_ms;
              const isOld = (now - (p.ts_ms || 0)) > 2 * 24 * 3600 * 1000; // 2 days

              if (DROPPABLE_STATUSES.has(status) && noEntryYet && isOld) {
                const isSafeToClean = await orderManager.validateOrderBeforeCleanup(p);
                if (isSafeToClean) {
                  log(`🗑️ Cleaning up old, un-entered order: ${p.client_order_id}`);
                  droppedCount++;
                  continue;
                }
              }
              keep.push(p);
            }

            if (droppedCount > 0) {
              state.pending = keep;
              log(`cleanup: dropped ${droppedCount} old orders.`);
            }
            return { dropped: droppedCount };
          }
          
          // ---------- Microstructure / Heavy Features helpers ----------
          const computeOBI=(depth, topN=12)=>{ if(!depth?.asks?.length || !depth?.bids?.length) return 0; const w=(i)=>Math.exp(-i*0.18); let bidNot=0, askNot=0; for(let i=0;i<Math.min(topN, depth.bids.length); i++){ const p=+depth.bids[i][0], q=+depth.bids[i][1]; if(p>0&&q>0) bidNot += p*q*w(i); } for(let i=0;i<Math.min(topN, depth.asks.length); i++){ const p=+depth.asks[i][0], q=+depth.asks[i][1]; if(p>0&&q>0) askNot += p*q*w(i); } return (bidNot+askNot>0) ? (bidNot-askNot)/(bidNot+askNot) : 0; };
          const vwapFillLevels=(levels,targetUSD)=>{ let remain=targetUSD,val=0,qty=0; for(const [ps,qs] of levels){ const p=+ps, q=+qs; if(!(p>0&&q>0)) continue; const can=p*q, take=Math.min(remain,can), tq=take/p; val+=p*tq; qty+=tq; remain-=take; if(remain<=1e-6) break; } return { px: qty>0? val/qty : null, filledUSD: (targetUSD-remain) }; };
          const slipFromDepth=(depth,mid,side,notionalUSD)=>{ if(!depth?.asks?.length || !depth?.bids?.length || !(mid>0)) return { slip_bps:null, fill_prob:null }; if(side==="long"){ const buy=vwapFillLevels(depth.asks, Math.max(50,notionalUSD)); const slip = buy.px? Math.max(0, Math.round((buy.px - mid)/mid*10000)) : null; const fill = Math.min(1, (buy.filledUSD||0)/Math.max(1,notionalUSD)); return { slip_bps: slip, fill_prob: +fill.toFixed(4) }; }else{ const sell=vwapFillLevels(depth.bids, Math.max(50,notionalUSD)); const slip = sell.px? Math.max(0, Math.round((mid - sell.px)/mid*10000)) : null; const fill = Math.min(1, (sell.filledUSD||0)/Math.max(1,notionalUSD)); return { slip_bps: slip, fill_prob: +fill.toFixed(4) }; } };
          const depthWithinPctUSD=(depth, mid, pct=0.01)=>{ if(!depth?.asks?.length || !depth?.bids?.length || !(mid>0)) return { bidsUSD:0, asksUSD:0 }; const askLim=mid*(1+pct), bidLim=mid*(1-pct); let asksUSD=0, bidsUSD=0; for(const [ps,qs] of depth.asks){ const p=+ps, q=+qs; if(!(p>0&&q>0)) continue; if(p<=askLim) asksUSD += p*q; else break; } for(const [ps,qs] of depth.bids){ const p=+ps, q=+qs; if(!(p>0&&q>0)) continue; if(p>=bidLim) bidsUSD += p*q; else break; } return { bidsUSD, asksUSD }; };
          const confidenceScore=({ p_cal, ev_bps, atr_bps, micro, regime, reliability, riskAdj })=>{ const ev_norm = atr_bps>0? ev_bps/atr_bps : 0; const ev_sig = 1/(1+Math.exp(-ev_norm)); const base = 0.6*p_cal + 0.4*ev_sig; const mult = (micro||1)*(regime||1)*(reliability||1)*(riskAdj||1); return Math.round(100*base*mult); };
          const microprice=(bid,ask,qb,qa)=>{ const d=(qb||1)+(qa||1); return (ask*qb + bid*qa)/d; };
          const ofiProxy=(d0,d1)=>{ const lev=(side,d)=>d?.[side]?.slice(0,3).map(x=>+x[1]||0)||[]; const sum=a=>a.reduce((x,y)=>x+y,0); if(!d0||!d1) return 0; return (sum(lev("bids",d1))-sum(lev("bids",d0))) - (sum(lev("asks",d1))-sum(lev("asks",d0))); };
          const bookSlope=(depth, mid)=>{ const toPts=(levels)=>{ let cum=0; const pts=[]; for(const [ps,qs] of (levels||[])){ const p=+ps,q=+qs; if(!(p>0&&q>0)) continue; cum+=p*q; const x=Math.log(Math.abs(p-mid)/mid + 1e-6), y=Math.log(cum+1); pts.push([x,y]); if(pts.length>=10) break; } return pts; }; if(!depth?.asks?.length||!depth?.bids?.length||!(mid>0)) return { slope:0, r2:0 }; const pts=toPts(depth.asks).concat(toPts(depth.bids)); if(pts.length<6) return { slope:0, r2:0 }; const xs=pts.map(p=>p[0]), ys=pts.map(p=>p[1]), mx=mean(xs), my=mean(ys); let num=0,den=0,vy=0; for(let i=0;i<xs.length;i++){ const dx=xs[i]-mx, dy=ys[i]-my; num+=dx*dy; den+=dx*dx; vy+=dy*dy; } return { slope: den>1e-9? num/den : 0, r2: den>1e-9 && vy>1e-9? (num*num)/(den*vy):0 }; };
          const reasonBuilder=(ctx)=>{ const out=[]; if((ctx.adx1h||0)>22) out.push({ factor:"ADX_1h", value:+(ctx.adx1h||0).toFixed(1), contribution:+Math.min(12,(ctx.adx1h-22)*0.6).toFixed(1) }); if((ctx.ofi30s||0)>0) out.push({ factor:"OFI_30s", value:+(ctx.ofi30s||0).toFixed(3), contribution:+Math.min(10, ctx.ofi30s*10).toFixed(1) }); if((ctx.spread_bps||0)>8) out.push({ factor:"Spread_bps", value:ctx.spread_bps, contribution:-Math.min(8,(ctx.spread_bps-8)) }); if((ctx.slip_bps_est||0)>4) out.push({ factor:"Slip_est_bps", value:ctx.slip_bps_est, contribution:-Math.min(6,(ctx.slip_bps_est-4)) }); if((ctx.tfAlign||0)>=0.7) out.push({ factor:"TF_alignment", value:+(ctx.tfAlign||0).toFixed(2), contribution:+6.0 }); if((ctx.mtf_rsi||0)>55) out.push({ factor:"MTF_RSI", value:+(ctx.mtf_rsi||0).toFixed(1), contribution:+3.0 }); return out.sort((a,b)=>Math.abs(b.contribution)-Math.abs(a.contribution)).slice(0,5); };
          const cholesky=(A)=>{ const n=A.length; const L=Array.from({length:n},()=>Array(n).fill(0)); for(let i=0;i<n;i++){ for(let j=0;j<=i;j++){ let s=0; for(let k=0;k<j;k++) s+=L[i][k]*L[j][k]; const v=A[i][j]-s; if(i===j){ if(v<=1e-12) return null; L[i][j]=Math.sqrt(Math.max(v,1e-12)); } else L[i][j]=v/(L[j][j]||1e-12); } } return L; };
          const choleskySafe=(S)=>{ const L=cholesky(S); if(L) return L; const n=S.length; const Sc=S.map((r,i)=> r.map((v,j)=> v + (i===j?1e-6:0))); return cholesky(Sc); };
          const sampleMultiT=(muVec,Sigma,df=6,M=1000)=>{ const n=muVec.length; const L=choleskySafe(Sigma); if(!L) return []; const out=[]; for(let m=0;m<M;m++){ const z=Array(n).fill(0).map(()=>randn()); const y=Array(n).fill(0); for(let i=0;i<n;i++){ let s=0; for(let k=0;k<=i;k++) s+=L[i][k]*z[k]; y[i]=s; } let chi=0; for(let i=0;i<df;i++){ const zc=randn(); chi+=zc*zc; } const scale=Math.sqrt(df/Math.max(1e-9,chi)); out.push(y.map((yi,i)=> (muVec[i]||0) + yi*scale)); } return out; };
          const portfolioVaR_ES_tCopula=(picks, df=6)=>{ if(!picks.length) return { VaR95_bps:0, ES95_bps:0 }; const n=picks.length, mu=Array(n).fill(0), sd=Array(n).fill(0); for(let i=0;i<n;i++){ const r5=picks[i].ret5||[]; const rMean=mean(r5), rStd=std(r5)||1e-4; const steps=Math.max(1, Math.round((picks[i].ttl_sec||600)/300)); mu[i]=rMean*steps*10000; sd[i]=rStd*Math.sqrt(steps)*10000; } const R=Array.from({length:n},()=>Array(n).fill(0)); for(let i=0;i<n;i++){ for(let j=i;j<n;j++) R[i][j]=corr(picks[i].ret5||[], picks[j].ret5||[]); R[i][i]=1; } const Sigma=Array.from({length:n},()=>Array(n).fill(0)); for(let i=0;i<n;i++) for(let j=0;j<n;j++) Sigma[i][j]=R[i][j]*sd[i]*sd[j]; const draws=sampleMultiT(mu,Sigma,df,1200); if(!draws.length) return { VaR95_bps:0, ES95_bps:0 }; const w0=picks.map(p=> p.size_bps||0); const ws=sum(w0)||1; const w=w0.map(x=> x/ws); const port=draws.map(d=> d.reduce((acc,di,ii)=> acc + w[ii]*di, 0)); port.sort((a,b)=>a-b); const idx=Math.floor(0.05*port.length); const VaR95=port[idx]||0; const ES=mean(port.slice(0,idx+1)); return { VaR95_bps:Math.round(VaR95), ES95_bps:Math.round(ES) }; };

          // ---------- HTTP + Concurrency ----------
          async function fetchWithTimeout(url,opts={},ms=12000){ const ac=new AbortController(); const t=setTimeout(()=>ac.abort(),ms); try{ return await fetch(url,{...opts,signal:ac.signal,headers:{"User-Agent":UA,...(opts?.headers||{})}});} finally{ clearTimeout(t);} }
          async function getJSON(url,ms=12000,tries=2){ for(let a=0;a<tries;a++){ try{ const r=await fetchWithTimeout(url,{},ms); if(r?.ok){ return await r.json(); } }catch{} await sleep(jitter(220)); } return null; }
          const cache={ k:new Map(), depth:new Map(), bt:new Map(), conv:new Map() };
          const TTL={ k: 60_000, depth: 8_000, bt: 5_000, conv: 60_000 };

          const getCached=(map,key,ttl)=>{ const e=map.get(key); return e && (Date.now()-e.ts<ttl)? e.v : null; };
          const setCached=(map,key,v)=>map.set(key,{ v, ts: Date.now() });

          // ---------- Config / ENV ----------
          const TARGET_EXCHANGE = "bybit_futures_testnet";
          const MARKET_TYPE     = "futures";
          const MARGIN_MODE     = "isolated";
          const LEVERAGE        = 1;
          const EXCHANGE=(process.env.EXCHANGE||"mexc").toLowerCase().replace("mexci","mexc");
          const MEXC_API_KEY = process.env.MEXC_API_KEY || "";
          const MEXC_SECRET_KEY = process.env.MEXC_SECRET_KEY || "";
          const MEXC_BASES=[process.env.MEXC_BASE,"https://api.mexc.com","https://www.mexc.com"].filter(Boolean);
          const MIN_TF_ALIGN=(Number(process.env.MIN_TF_ALIGN||"0.60"));
          let TF_WEIGHTS={}; try{ TF_WEIGHTS=JSON.parse(process.env.TF_WEIGHTS||"{}"); }catch{ TF_WEIGHTS={}; }
          const STRATEGY_NAME=(process.env.STRATEGY_NAME||"mexc-ultimate");
          const SCHEMA_VERSION=(process.env.SCHEMA_VERSION||"1");
          const GIT_SHA=(process.env.GIT_SHA||"unknown");
          
          // Calibration tuning
          const ADAPTIVE_LEARNING = true;
          const MIN_LEARNING_RATE = 0.001;
          const MAX_LEARNING_RATE = 0.08;
          const MOMENTUM_RATE = 0.9;
          const LEARNING_DECAY = 0.001;
          const CALIBRATION_RESET_THRESHOLD = 0.49;
          const COEFF_BOUND_A = 2.5;
          const COEFF_BOUND_B = 3.5;
          const CALIB_MIN_SAMPLES = 10;
          const CALIB_ERROR_WINDOW = 20;
          const CALIB_MIN_RESET_N = 30;

          const PUSHER_MODE=(process.env.PUSHER_MODE||"plan_only").toLowerCase();

          const MIN_QV_ENV = Number(process.env.MIN_QV_USD||"0") || 0;
          const UNIV_TARGET_MIN=100, UNIV_TARGET_MAX=120, DYN_QV_MIN=Number(process.env.DYN_QV_MIN||"10000000"), DYN_QV_STEP=5_000_000;
          const TOP_N=Number(process.env.TOP_N||"3"), MAX_SPREAD_BPS=Number(process.env.MAX_SPREAD_BPS||"12");
          const EXP_LCB_MIN_BPS_BASE=Number(process.env.EXP_LCB_MIN_BPS||"12");
          const EMA_FAST=21, EMA_SLOW=50, ADX_P=14, ATR_P=14, K1M=240, K5M=300, K15M=300, K1H=300, K4H=300;
          const VWAP_5M_WIN=36, COST_BPS=Number(process.env.FEES_BPS||"10"), NOTIONAL=Number(process.env.NOTIONAL_USD||"300");
          const DEPTH_LIMIT=Number(process.env.MEXC_DEPTH_LIMIT||"50"), OBI_TOPN=Number(process.env.OBI_TOPN||"12");
          const COOLDOWN_MS=3*60*60*1000, FLIP_GUARD_MS=30*60*1000;
          const DD_24H_LIMIT_BPS=-150, DD_PEAK_LIMIT_BPS=-300;
          const WILSON_Z=1.34, TARGET_PORT_RISK_BPS=52, TTL_MIN=540, TTL_MAX=1200;
          const S_H=process.env.ACTIVE_UTC_START?Number(process.env.ACTIVE_UTC_START):null;
          const E_H=process.env.ACTIVE_UTC_END?Number(process.env.ACTIVE_UTC_END):null;
          const nowH=new Date().getUTCHours();
          const todOK=(S_H==null||E_H==null)?true:(S_H<=E_H?(nowH>=S_H&&nowH<=E_H):(nowH>=S_H||nowH<=E_H));
          const STABLES=new Set(["USDT","USDC","USD","USDE","USDD","BUSD","FDUSD","TUSD","DRKUSD","DAI","USDP","PAX","USTC"]);
          const DIRECTION=(process.env.DIRECTION||"both").trim().toLowerCase();
          const MR_ADX_MAX_DEFAULT=20, MR_BREAKOUT_DC_N=Number(process.env.MR_BREAKOUT_DC_N||"120");
          const MR_BREAKOUT_RET15_ATR=Number(process.env.MR_BREAKOUT_RET15_ATR||"1.5"), MR_LOCKOUT_SEC=Number(process.env.MR_LOCKOUT_SEC||"1800");
          const MAX_COST_BPS_HARD=Number(process.env.MAX_COST_BPS_HARD||"15");
          const MIN_VOL_1H_USD=Number(process.env.MIN_VOL_1H_USD||"5000000"), DEPTH_1P_MIN_USD=Number(process.env.DEPTH_1P_MIN_USD||"200000");
          const NO_LONG_DOWN_ENABLE=(process.env.NO_LONG_DOWN_ENABLE||"true").toLowerCase()==="true";
          const LONG_DOWN_RSI_CUTOFF=Number(process.env.LONG_DOWN_RSI_CUTOFF||"40");
          const LONG_MR_DIVERGENCE_REQ=(process.env.LONG_MR_DIVERGENCE_REQ||"true").toLowerCase()==="true";
          const LONG_EDGE_MULT_MIN=Number(process.env.LONG_EDGE_MULT_MIN||"4");
          const LONG_BOUNCE_SL_ATR=Number(process.env.LONG_BOUNCE_SL_ATR||"0.50"), LONG_BOUNCE_TP_ATR=Number(process.env.LONG_BOUNCE_TP_ATR||"0.90");
          const LONG_SIMILARITY_RHO=Number(process.env.LONG_SIMILARITY_RHO||"0.84");

          const CONFIG_HASH=(()=>{ try{
            const knobs={
              DIRECTION, MR_BREAKOUT_DC_N, MR_BREAKOUT_RET15_ATR, MR_LOCKOUT_SEC,
              MAX_COST_BPS_HARD, MIN_VOL_1H_USD, DEPTH_1P_MIN_USD, NO_LONG_DOWN_ENABLE,
              LONG_DOWN_RSI_CUTOFF, LONG_MR_DIVERGENCE_REQ, LONG_EDGE_MULT_MIN,
              LONG_BOUNCE_SL_ATR, LONG_BOUNCE_TP_ATR, LONG_SIMILARITY_RHO, TOP_N, MAX_SPREAD_BPS,
              EXP_LCB_MIN_BPS_BASE, COST_BPS, NOTIONAL, DEPTH_LIMIT, OBI_TOPN, MIN_TF_ALIGN, TF_WEIGHTS
            };
            return hashObj(knobs);
          }catch{ return "cfg-unknown"; } })();

          // ---------- Worker endpoints ----------
          const PUSH_URL=process.env.WORKER_PUSH_URL||"", PUSH_TOKEN=process.env.PUSH_TOKEN||"";
          const PUSH_URL_V2 = process.env.WORKER_PUSH_URL_V2 || "";
          const HEALTH_URL=(()=>{ try{ const u=new URL(PUSH_URL); return `${u.origin}${u.pathname.replace(/\/signals\/push(\?.*)?$/,"/health")}`;}catch{return PUSH_URL.replace(/\/signals\/push(\?.*)?$/,"/health");}})();

          // ---------- MEXC Adapter ----------
          let BASE = "";
          async function pickMexcBase(){ for(const b of MEXC_BASES){ try{ const r=await fetchWithTimeout(`${b}/api/v3/time`,{},4000); if(r?.ok) { BASE = b; return b; } }catch{} } throw new Error("No healthy MEXC base"); }
          const api=(path,params={})=>{ const u=new URL(path,BASE); for(const [k,v] of Object.entries(params)){ if(v!==undefined&&v!==null) u.searchParams.set(k,String(v)); } return u.toString(); };
          async function mexcSignedRequest(path, params = {}, method = 'GET') {
              if (!MEXC_API_KEY || !MEXC_SECRET_KEY) return null;
              const timestamp = Date.now();
              const queryString = new URLSearchParams({ ...params, timestamp }).toString();
              const signature = crypto.createHmac('sha256', MEXC_SECRET_KEY).update(queryString).digest('hex');
              const url = new URL(path, BASE);
              url.search = queryString + `&signature=${signature}`;
              const options = { method, headers: { 'X-MEXC-APIKEY': MEXC_API_KEY, 'Content-Type': 'application/json', 'User-Agent': UA } };
              try {
                  const start = Date.now();
                  const r = await fetchWithTimeout(url.toString(), options, 15000);
                  const latency = Date.now() - start;
                  monitor.recordApiCall(path, r.ok, latency);
                  if (r.ok) return await r.json();
                  log(`MEXC signed request failed: ${r.status}`, (await r.text()||'').slice(0,100));
                  return null;
              } catch (e) {
                  monitor.recordApiCall(path, false, 15000);
                  log(`MEXC signed request error: ${e?.message||e}`);
                  return null;
              }
          }
          async function fetchMyTrades(symbol, startTime) { return await mexcSignedRequest('/api/v3/myTrades', { symbol, startTime, limit: 1000 }); }
          async function fetchOpenOrders(symbol) {
            const r = await mexcSignedRequest('/api/v3/openOrders', symbol?{symbol}:{});
            return Array.isArray(r) ? r : null; // null => unavailable
          }
          async function fetchK(sym,interval,limit,startTime,endTime){ const u=api("/api/v3/klines",{symbol:sym,interval,limit,startTime,endTime}); const r=await getJSON(u,10000,2); return Array.isArray(r)?r:null; }
          async function fetchDepth(symbol){ return await getJSON(api("/api/v3/depth",{symbol,limit:DEPTH_LIMIT}), 10000, 2); }
          async function fetchAll24hr(){
            let all=await getJSON(api("/api/v3/ticker/24hr"),10000,2); if(Array.isArray(all)&&all.length) return all;
            const exi=await getJSON(api("/api/v3/exchangeInfo"),10000,2); const syms=(exi?.symbols||[]).filter(s=>s.status==="TRADING").map(s=>s.symbol).slice(0,300);
            const out=[]; for(let i=0;i<syms.length;i+=24){ const chunk=syms.slice(i,i+24); const got=await Promise.all(chunk.map(s=>getJSON(api("/api/v3/ticker/24hr",{symbol:s}),6000,1))); for(const x of got) if(x) out.push(x); await sleep(180); } return out;
          }
          async function fetchBookTicker(symbol){ return await getJSON(api("/api/v3/ticker/bookTicker",{symbol}), 8000, 1); }

          async function getKCached(symbol,interval,limit,startTime,endTime){ const key=[symbol,interval,limit,startTime||"",endTime||""].join("|"); const c=getCached(cache.k,key,TTL.k); if(c) return c; const v=await fetchK(symbol,interval,limit,startTime,endTime); if(v) setCached(cache.k,key,v); return v; }
          async function getDepthCached(symbol){ const c=getCached(cache.depth,symbol,TTL.depth); if(c) return c; const v=await fetchDepth(symbol); if(v) setCached(cache.depth,symbol,v); return v; }
          async function getBookTickerCached(symbol){ const c=getCached(cache.bt,symbol,TTL.bt); if(c) return c; const v=await fetchBookTicker(symbol); if(v) setCached(cache.bt,symbol,v); return v; }
          async function getKMultiTF(symbol){ const pairs=[["1m",300],["3m",300],["5m",K5M],["15m",K15M],["30m",300],["1h",K1H],["2h",200],["4h",K4H],["12h",120],["1d",90]]; const out={}; for(const [tf,lim] of pairs){ out[tf]=await getKCached(symbol, tf, lim); } return out; }
          const tfInd=(k)=>{ if(!k?.length) return null; const h=k.map(x=>+x[2]), l=k.map(x=>+x[3]), c=k.map(x=>+x[4]); const adxatr=computeADX_ATR(h,l,c,14)||{adx:0,atr:0}; const up=c.at(-1)>=ema(c,21)&&c.at(-1)>=ema(c,50); return {adx:adxatr.adx||0,atr:adxatr.atr||0,up}; };

          // ---------- Conversion rate helper for commissions ----------
          async function getConversionRate(asset, quote="USDT"){
            try{
              if(!asset||asset.toUpperCase()===quote.toUpperCase()) return 1;
              const key=asset.toUpperCase()+"_"+quote.toUpperCase();
              const c=getCached(cache.conv,key,TTL.conv); if(c) return c;
              const sym1=asset.toUpperCase()+quote.toUpperCase();
              const sym2=quote.toUpperCase()+asset.toUpperCase();
              let px=null;
              let bt=await getBookTickerCached(sym1);
              if(bt?.askPrice) px=+bt.askPrice;
              if(px==null){ bt=await getBookTickerCached(sym2); if(bt?.bidPrice) px=1/(+bt.bidPrice||1); }
              if(px==null) return 1;
              setCached(cache.conv,key,px);
              return px;
            }catch{ return 1; }
          }
          
          // ========== MONITORING & DIAGNOSTICS ==========
          class SystemMonitor {
            constructor() {
              this.metrics = {
                apiCalls: { success: 0, failed: 0, latencies: [] },
                orders: { placed: 0, filled: 0, cancelled: 0, orphaned: 0 },
                calibration: { updates: 0, resets: 0, drifts: [] },
                errors: [],
                alerts: []
              };
            }
            
            recordApiCall(endpoint, success, latencyMs) {
              if (success) this.metrics.apiCalls.success++;
              else this.metrics.apiCalls.failed++;
              
              this.metrics.apiCalls.latencies.push(latencyMs);
              if (this.metrics.apiCalls.latencies.length > 100) {
                this.metrics.apiCalls.latencies.shift();
              }
              
              const total = this.metrics.apiCalls.success + this.metrics.apiCalls.failed;
              if (total > 10 && this.metrics.apiCalls.failed / total > 0.3) {
                this.alert('HIGH_API_FAILURE_RATE', `Failure rate: ${(this.metrics.apiCalls.failed/total*100).toFixed(1)}%`);
              }
            }
            
            alert(type, message, severity = 'WARN') {
              const alert = { type, message, severity, ts: Date.now() };
              this.metrics.alerts.push(alert);
              
              if (severity === 'CRITICAL') {
                log(`🚨 CRITICAL ALERT: ${type} - ${message}`);
                if (type === 'CATASTROPHIC_LOSS') {
                  process.exit(1); // Emergency kill switch
                }
              } else {
                log(`⚠️ ALERT [${severity}]: ${type} - ${message}`);
              }
            }
            
            async healthCheck() {
              const checks = {
                api: await this.checkApiHealth(),
                state: this.checkStateHealth(),
                calibration: this.checkCalibrationHealth(),
                memory: this.checkMemoryUsage(),
              };
              
              const healthy = Object.values(checks).every(c => c.healthy);
              return { healthy, checks, metrics: this.metrics };
            }
            
            async checkApiHealth() {
              try {
                const start = Date.now();
                const r = await fetchWithTimeout(api("/api/v3/time"), {}, 2000);
                const latency = Date.now() - start;
                return { healthy: r?.ok && latency < 1000, latency };
              } catch {
                return { healthy: false, error: 'API unreachable' };
              }
            }

            async checkStateHealth() { return { healthy: true }; } // Placeholder
            checkCalibrationHealth() { return { healthy: true }; } // Placeholder
            
            checkMemoryUsage() {
              const used = process.memoryUsage();
              const heapPercent = (used.heapUsed / used.heapTotal) * 100;
              
              if (heapPercent > 90) {
                this.alert('HIGH_MEMORY_USAGE', `Heap usage: ${heapPercent.toFixed(1)}%`, 'CRITICAL');
              }
              
              return { 
                healthy: heapPercent < 90, 
                heapPercent,
                rss: Math.round(used.rss / 1048576) + 'MB'
              };
            }
          }

          const monitor = new SystemMonitor();

          // ========== SAFETY VALIDATORS ==========
          class SafetyValidator {
            static validateIdea(idea, state, market) {
              const errors = [];
              const warnings = [];
              
              if (idea.entry_limit <= 0) errors.push('Invalid entry price');
              if (idea.tp_abs <= 0) errors.push('Invalid TP price');
              if (idea.sl_abs <= 0) errors.push('Invalid SL price');
              
              const maxLoss = idea.size_bps * (idea.sl_bps / 10000);
              if (maxLoss > 100) errors.push(`Excessive risk per trade: ${maxLoss.toFixed(2)}bps`);
              
              const spread = market.bookMap.get(idea.symbol_full)?.spread_bps || 0;
              if (spread > idea.cost_bps * 2) warnings.push('Spread exceeds 2x expected cost');
              
              const existing = state.pending.find(p => 
                p.symbolFull === idea.symbol_full && 
                p.side === idea.side &&
                Math.abs(p.entry_limit - idea.entry_limit) / p.entry_limit < 0.001
              );
              if (existing) errors.push('Duplicate order detected');
              
              const symbolPositions = state.pending.filter(p => p.symbolFull === idea.symbol_full);
              if (symbolPositions.length >= 2) warnings.push('Multiple positions on same symbol');
              
              const key = `${idea.side}_${idea.regime}`;
              const coeffs = state.calibCoeffs?.[key];
              if (coeffs && coeffs.recent_errors?.length > 10) {
                const avgError = mean(coeffs.recent_errors);
                if (avgError > 0.4) warnings.push(`High calibration error: ${avgError.toFixed(2)}`);
              }
              
              return { 
                valid: errors.length === 0,
                errors,
                warnings,
                score: Math.max(0, 100 - errors.length * 50 - warnings.length * 10)
              };
            }
            
            static validateSystemState(state, health) {
              const issues = [];
              if (state.pending.length > 100) issues.push('Too many pending orders');
              
              for (const [key, coeff] of Object.entries(state.calibCoeffs || {})) {
                if (Math.abs(coeff.a) > COEFF_BOUND_A * 0.9) {
                  issues.push(`Calibration ${key} approaching bounds`);
                }
              }
              
              if (!health.healthy) issues.push('System health check failed');
              
              const staleThreshold = Date.now() - 5 * 60 * 1000;
              const stalePending = state.pending.filter(p => 
                p.status === 'planned' && p.ts_ms < staleThreshold
              );
              if (stalePending.length > 0) issues.push(`${stalePending.length} stale pending orders`);
              
              return {
                healthy: issues.length === 0,
                issues,
                recommendation: issues.length > 3 ? 'PAUSE_TRADING' : 'CONTINUE'
              };
            }
          }

          // ========== EMERGENCY RESPONSE ==========
          class EmergencyResponse {
            static async checkEmergencyConditions(state, market) {
              const triggers = [];
              
              const btc_k = market.btc_k;
              const btcDrop = btc_k && btc_k.length > 1 ? (btc_k.at(-1)[4] / btc_k.at(-2)[4] - 1) * 100 : 0;
              if (btcDrop < -10) {
                triggers.push({ type: 'FLASH_CRASH', severity: 'CRITICAL', action: 'HALT_ALL' });
              }
              
              const recentLosses = (state.equity || [])
                .filter(e => e.ts_ms > Date.now() - 3600000)
                .reduce((sum, e) => sum + Math.min(0, e.pnl_bps), 0);
              
              if (recentLosses < -500) {
                triggers.push({ type: 'EXCESSIVE_LOSSES', severity: 'CRITICAL', action: 'HALT_ALL' });
              }
              
              if (monitor.metrics.apiCalls.failed > 20) {
                triggers.push({ type: 'API_DEGRADED', severity: 'HIGH', action: 'PAUSE_NEW' });
              }
              
              const calibrationErrors = Object.values(state.calibCoeffs || {})
                .filter(c => c.recent_errors && mean(c.recent_errors) > 0.5);
              
              if (calibrationErrors.length > 2) {
                triggers.push({ type: 'CALIBRATION_FAILURE', severity: 'HIGH', action: 'REDUCE_SIZE' });
              }
              
              return triggers;
            }
            
            static async executeEmergencyActions(triggers, state, persist) {
              for (const trigger of triggers) {
                log(`🚨 EMERGENCY: ${trigger.type} - Executing ${trigger.action}`);
                
                switch (trigger.action) {
                  case 'HALT_ALL':
                    state.pending = state.pending.filter(p => p.status !== 'planned');
                    state.emergency_halt = { ts: Date.now(), reason: trigger.type };
                    await saveStateAtomic(persist, state, { changes: 'EMERGENCY_HALT'});
                    process.exit(0); // Full stop
                    break;
                    
                  case 'PAUSE_NEW':
                    state.pause_new_orders = Date.now() + 3600000; // 1 hour pause
                    break;
                    
                  case 'REDUCE_SIZE':
                    state.pending = state.pending.map(p => ({
                      ...p,
                      size_bps: Math.round(p.size_bps * 0.5)
                    }));
                    break;
                }
              }
            }
          }

          // ---------- Heartbeat & Zombie detection ----------
          async function heartbeatCheck(state){
            const res={ mismatches:0, zombies:0, details:[] };
            if(!MEXC_API_KEY||!MEXC_SECRET_KEY) return res;
            try{
              const openAll=await fetchOpenOrders();
              if (!Array.isArray(openAll)) return res; // don’t mark zombies on unavailable data

              const byClient=new Map();
              for(const o of openAll){ const cid=(o.clientOrderId||o.clientOrderID||"").trim(); if(cid) byClient.set(cid,o); }
              for(const p of state.pending||[]){
                const cid=(p.client_order_id||p.clientOrderId||"").trim();
                if(!cid) continue;
                const onEx=byClient.has(cid);
                if(!onEx){
                  res.zombies++; res.details.push({ type:"zombie", symbol:p.symbolFull, client_order_id:cid, ts_ms:p.ts_ms });
                }
              }
              res.mismatches=res.zombies;
            }catch(e){ log("heartbeat warn", e?.message||e); }
            return res;
          }
          
          // ========== ATOMIC STATE OPERATIONS ==========
          async function fetchCurrentState(persist) {
            const token=persist?.token, id=persist?.id;
            const init={ v:"mexc-ultimate-7.0-safe", locks:{}, cooldown:{}, cooldown_side: {}, pending:[], equity:[], closed:[], calibCoeffs:{}, mr_lockout: {}, sym_stats: {}, sym_stats_real: {}, version:0 };
            if(!token||!id) return { state:init, etag: null };
            const r = await fetchWithTimeout(`https://api.github.com/gists/${id}`, { headers:{Authorization:`Bearer ${token}`,"Accept":"application/vnd.github+json","User-Agent":UA} });
            if(!r.ok) throw new Error(`Failed to fetch state: ${r.status}`);
            const etag = r.headers.get("etag");
            const g = await r.json();
            const c = g.files?.["state.json"]?.content;
            return { state: c ? JSON.parse(c) : init, etag };
          }
          
          async function patchGistWithRetry(persist, state, etag) {
              const headers = {
                Authorization: `Bearer ${persist.token}`,
                "Accept": "application/vnd.github+json",
                "Content-Type": "application/json",
                "User-Agent": UA
              };
              if (etag) headers["If-Match"] = etag;
              return await fetchWithTimeout(`https://api.github.com/gists/${persist.id}`, {
                method: "PATCH",
                headers,
                body: JSON.stringify({ files: { "state.json": { content: JSON.stringify(state) } } })
              }, 15000);
          }

          function mergeStatesWithConflictResolution(remote, local) {
            const merged = { ...remote };
            const pendingMap = new Map();
            for (const p of remote.pending || []) {
              pendingMap.set(p.client_order_id, { ...p, source: 'remote' });
            }
            for (const p of local.pending || []) {
              const existing = pendingMap.get(p.client_order_id);
              if (existing && existing.source === 'remote') {
                pendingMap.set(p.client_order_id, {
                  ...existing,
                  predicted: p.predicted || existing.predicted,
                  confidence: p.confidence || existing.confidence
                });
              } else if (!existing) {
                pendingMap.set(p.client_order_id, { ...p, source: 'local' });
              }
            }
            merged.pending = Array.from(pendingMap.values());
            merged.calibCoeffs = local.calibCoeffs; // Pusher owns
            merged.cooldown = local.cooldown; // Pusher owns
            merged.version = Math.max(remote.version || 0, local.version || 0) + 1;
            log(`📋 Merged state: remote_pending=${remote.pending?.length} local_pending=${local.pending?.length} merged=${merged.pending?.length}`);
            return merged;
          }

          async function saveStateAtomic(persist, state, options = {}) {
            if (!persist || !persist.id || !persist.token) {
              log("Skipping state save: no Gist credentials.");
              return false;
            }
            const maxRetries = 5;
            let lastError = null;
            let currentEtag = options.etag;
            
            for (let attempt = 0; attempt < maxRetries; attempt++) {
              try {
                state.last_transaction = { id: crypto.randomUUID(), ts: Date.now(), attempt, changes: options.changes || 'general_update' };
                state.checksum = crypto.createHash('sha256').update(JSON.stringify(state.pending || [])).digest('hex').slice(0, 8);
                state.version = (state.version || 0) + 1;
                
                if (options.requireEtag && !currentEtag) {
                  const current = await fetchCurrentState(persist);
                  currentEtag = current.etag;
                }
                
                const response = await patchGistWithRetry(persist, state, currentEtag);
                
                if (response.ok) {
                  persist.etag = response.headers.get('etag');
                  log(`✅ State saved atomically v${state.version} checksum=${state.checksum}`);
                  return true;
                }
                
                if (response.status === 412) {
                  log(`Conflict detected, attempting merge (attempt ${attempt + 1})`);
                  const remote = await fetchCurrentState(persist);
                  state = mergeStatesWithConflictResolution(remote.state, state);
                  currentEtag = remote.etag;
                  continue;
                }
                
                lastError = `HTTP ${response.status}`;
              } catch (error) {
                lastError = error.message;
                log(`State save attempt ${attempt + 1} failed: ${lastError}`);
                if (attempt < maxRetries - 1) {
                  await sleep(Math.pow(2, attempt) * 1000); // Exponential backoff
                }
              }
            }
            monitor.alert('STATE_SAVE_FAILED', `Failed after ${maxRetries} attempts: ${lastError}`, 'CRITICAL');
            throw new Error(`Failed to save state: ${lastError}`);
          }

          // ---------- State (Gist) + Calibration + Audit ----------
          async function loadState(persist) {
             const init = { v:"mexc-ultimate-7.0-safe", locks:{}, cooldown:{}, cooldown_side: {}, pending:[], equity:[], closed:[], calibCoeffs:{}, mr_lockout: {}, sym_stats: {}, sym_stats_real: {}, version:0 };
             if (!persist || !persist.token || !persist.id) return { state: init, persist: null };
             const { state, etag } = await fetchCurrentState(persist);
             persist.etag = etag;
             return { state, persist };
          }
          
          const regFromKey = (k) => k?.includes("regime:trend") ? "trend" : k?.includes("regime:meanrevert") ? "meanrevert" : null;
          function learnFromGistRealFills(state){
            const learnable = (state.closed || []).filter(c =>
              c.reconciliation === "exchange_trade_history" &&
              !c.learned &&
              c.p_raw != null
            );
            
            if (learnable.length === 0) {
              log("📚 No new fills to learn from this cycle.");
              return;
            }

            log(`📚 Learning from ${learnable.length} real fills...`);
            
            let learnedCount = 0;
            for (const c of learnable) {
              const reg = c.regime || regFromKey(c.calib_key);
              if (!reg || !c.side) continue;

              const outcome = (c.pnl_bps || 0) > 0 ? 1 : 0;
              const result = outcome ? "WIN" : "LOSS";
              
              log(`📊 Trade: ${c.symbolFull || c.symbol} ${c.side} ${result} pnl=${c.pnl_bps}bps p_raw=${c.p_raw?.toFixed(3)}`);
              
              try { 
                updateCalibration(state, c.side, reg, c.p_raw, outcome); 
              }
              catch(e){ 
                log("⚠️  learnFromGistRealFills error:", e?.message||e); 
              }
              
              c.learned = true;
              c.learned_at_ts = Date.now();
              learnedCount++;
            }
            
            log(`✅ Learning complete: ${learnedCount} fills processed.`);
          }

          const getCoeffs = (state, side, regime) => {
            const key = `${side}_${regime}`;
            if (!state.calibCoeffs) state.calibCoeffs = {};
            const def = {
              a: 0,
              b: 1,
              n: 0,
              momentum_a: 0,
              momentum_b: 0,
              recent_errors: []
            };
            state.calibCoeffs[key] = { ...def, ...(state.calibCoeffs[key] || {}) };
            return state.calibCoeffs[key];
          };
          
          function validateCalibration(state) {
            const report = {};
            for (const [key, coeff] of Object.entries(state.calibCoeffs || {})) {
              if (coeff.n < CALIB_MIN_SAMPLES) continue;
              const avg_error = mean(coeff.recent_errors || []);
              report[key] = {
                n: coeff.n,
                avg_error: avg_error.toFixed(3),
                status: avg_error < 0.4 ? "healthy" : "degraded"
              };
            }
            return report;
          }

          function updateCalibration(state, side, regime, pRaw, outcome) {
            if (pRaw == null || !isFinite(pRaw)) return;

            const coeff = getCoeffs(state, side, regime);

            // Store before state
            const before_a = coeff.a;
            const before_b = coeff.b;
            const before_n = coeff.n;

            // 1. Adaptive learning rate
            const lr = ADAPTIVE_LEARNING
              ? Math.max(
                  MIN_LEARNING_RATE,
                  MIN_LEARNING_RATE +
                    (MAX_LEARNING_RATE - MIN_LEARNING_RATE) / Math.sqrt(1 + coeff.n / 10)
                )
              : 0.05;

            // 2. Logit transform for better numerical properties
            const x = Math.max(-5, Math.min(5, logit(pRaw)));

            // 3. Compute prediction and error
            const z = coeff.a + coeff.b * x;
            const pHat = sigmoid(z);
            const err = outcome - pHat;

            // 4. Update momentum
            coeff.momentum_a = MOMENTUM_RATE * coeff.momentum_a + lr * err;
            coeff.momentum_b = MOMENTUM_RATE * coeff.momentum_b + lr * err * x;

            // 5. Clamp momentum to prevent explosion
            const MOMENTUM_CLAMP = 0.2;
            coeff.momentum_a = clamp(coeff.momentum_a, -MOMENTUM_CLAMP, MOMENTUM_CLAMP);
            coeff.momentum_b = clamp(coeff.momentum_b, -MOMENTUM_CLAMP, MOMENTUM_CLAMP);

            // 6. Apply momentum and weight decay to coefficients
            const a_next = (1 - LEARNING_DECAY) * coeff.a + coeff.momentum_a;
            const b_next = (1 - LEARNING_DECAY) * coeff.b + coeff.momentum_b;

            // 7. Clamp coefficients to bounds
            coeff.a = clamp(a_next, -COEFF_BOUND_A, COEFF_BOUND_A);
            coeff.b = clamp(b_next, -COEFF_BOUND_B, COEFF_BOUND_B);

            // 8. Reset momentum if bounds were hit
            const hit_bound_a = (a_next !== coeff.a);
            const hit_bound_b = (b_next !== coeff.b);
            if (hit_bound_a) coeff.momentum_a = 0;
            if (hit_bound_b) coeff.momentum_b = 0;

            // 9. Track recent errors for validation
            if (!coeff.recent_errors) coeff.recent_errors = [];
            coeff.recent_errors.push(Math.abs(err));
            if (coeff.recent_errors.length > CALIB_ERROR_WINDOW) {
              coeff.recent_errors.shift();
            }

            // 10. Auto-reset if performing worse than random
            const avg_error = mean(coeff.recent_errors);
            const will_reset = (avg_error > CALIBRATION_RESET_THRESHOLD && coeff.n > CALIB_MIN_RESET_N);

            // ========== VERBOSE LOGGING ==========
            log(`📚 LEARN [${side}_${regime}] n=${before_n}→${before_n+1} lr=${lr.toFixed(4)}`);
            log(`   Input: p_raw=${pRaw.toFixed(3)} outcome=${outcome} | Predicted: p_hat=${pHat.toFixed(3)} error=${err.toFixed(3)}`);
            log(`   Coeffs: a=${before_a.toFixed(4)}→${coeff.a.toFixed(4)} b=${before_b.toFixed(4)}→${coeff.b.toFixed(4)}`);
            if (hit_bound_a || hit_bound_b) {
              log(`   ⚠️  Hit bounds! a=${hit_bound_a} b=${hit_bound_b} (momentum reset)`);
            }
            log(`   Momentum: a=${coeff.momentum_a.toFixed(4)} b=${coeff.momentum_b.toFixed(4)}`);
            log(`   Avg_error=${avg_error.toFixed(3)} (window=${coeff.recent_errors.length})`);

            if (will_reset) {
              log(`   🔄 AUTO-RESET triggered! avg_error=${avg_error.toFixed(3)} > threshold=${CALIBRATION_RESET_THRESHOLD}`);
              coeff.a = 0;
              coeff.b = 1;
              coeff.momentum_a = 0;
              coeff.momentum_b = 0;
              coeff.recent_errors = [];
              coeff.n = 0; // restart learning
            } else {
              coeff.n++;
            }

            state.calibCoeffs[`${side}_${regime}`] = coeff;
          }
          const calibrateP=(state, side, regime, pRaw)=>{
            const coeff = getCoeffs(state, side, regime);
            if(pRaw==null || !isFinite(pRaw)) return 0.5; // safe fallback
            const x = Math.max(-5, Math.min(5, logit(pRaw)));
            return sigmoid(coeff.a + coeff.b * x);
          };
          const calibratorInfo=(state,side,regime)=>{ const coeff=getCoeffs(state,side,regime); return { type:"logistic", n:coeff.n, a:coeff.a, b:coeff.b }; };
          function getSymbolAdj(state, base) {
            const real = state.sym_stats_real?.[base];
            const s = real || state.sym_stats?.[base];
            if (!s || s.n < 6) return 1.0;
            const winRate = s.wins / s.n;
            const avgPnL = s.pnl_sum / s.n;
            let m = 1.0;
            if (winRate < 0.4) m *= 0.7;
            if (avgPnL < 0) m *= 0.8;
            return clamp(m, 0.5, 1.2);
          }

          // Build audit outputs from state (kept for diagnostics)
          const TRADE_CSV_KEYS=["ts_close_iso","idea_id","client_order_id","symbol","side","pnl_bps","entry_ts_ms","exit_ts_ms","entry_price","exit_price","qty","commission_bps","commission_quote_usdt","commission_asset_entry","commission_asset_exit","maker_taker_entry","maker_taker_exit","slip_realized_bps","reconciliation","fingerprint_entry","fingerprint_exit","calib_key","p_raw","p_pred","regime","source"];
          function buildAuditOutputs(state){
            const lastNClosed=(state.closed||[]).slice(-5000);
            const closedAudit=lastNClosed.map(x=>JSON.stringify(x)).join("\n");
            const lastHoldout=(state.calibration_holdout||[]).slice(-500);
            const disagreements=lastHoldout.map(x=>JSON.stringify(x)).join("\n");
            const rows=[];
            for(const c of lastNClosed){
              const td=c.trade_details||{};
              const row={
                ts_close_iso: new Date(c.ts_exit_ms||c.predicted_snapshot?.ts_ms||Date.now()).toISOString(),
                idea_id: td.idea_id||"",
                client_order_id: td.client_order_id||"",
                symbol: c.symbolFull||"",
                side: c.side||"",
                pnl_bps: c.pnl_bps,
                entry_ts_ms: c.ts_entry_ms||"",
                exit_ts_ms: c.ts_exit_ms||"",
                entry_price: c.price_entry||"",
                exit_price: c.price_exit||"",
                qty: c.qty||"",
                commission_bps: td.commission_bps!=null?td.commission_bps:"",
                commission_quote_usdt: td.commission_quote_usdt!=null?td.commission_quote_usdt:"",
                commission_asset_entry: td.commission_asset_entry||"",
                commission_asset_exit: td.commission_asset_exit||"",
                maker_taker_entry: td.maker_taker_entry||"",
                maker_taker_exit: td.maker_taker_exit||"",
                slip_realized_bps: td.slip_realized_bps!=null?td.slip_realized_bps:"",
                reconciliation: c.reconciliation||"",
                fingerprint_entry: td.fingerprint_entry||"",
                fingerprint_exit: td.fingerprint_exit||"",
                calib_key: c.calib_key||"",
                p_raw: c.p_raw!=null?c.p_raw:"",
                p_pred: c.p_pred!=null?c.p_pred:"",
                regime: c.regime||"",
                source: c.reconciliation||""
              };
              rows.push(toCSVLine(row, TRADE_CSV_KEYS));
            }
            const header=TRADE_CSV_KEYS.join(",");
            const tradesCsv=[header,...rows].join("\n");
            return { closedAudit, disagreements, tradesCsv };
          }

          async function sendSafeEmptyPayload(reason) {
            const payload = { ts: new Date().toISOString(), mode: "normal", source: "external_pusher", meta: { origin: "github_actions_safe_exit", reason }, top_n: 0, ideas: [] };
            try {
              await fetchWithTimeout(PUSH_URL, {
                method: "POST",
                headers: { "Content-Type": "application/json", "Authorization": "Bearer " + PUSH_TOKEN },
                body: JSON.stringify(payload)
              }, 8000);
            } catch (e) {
              log("Failed to send safe empty payload:", e.message);
            }
          }
          
          // ========== MAIN EXECUTION WITH SAFETY ==========
          async function main() {
            const runId = crypto.randomUUID();
            log(`🚀 Starting run ${runId}`);
            let lock;
            const persist = { id: process.env.GIST_ID, token: process.env.GIST_TOKEN };
            const hasGist = !!(persist.id && persist.token);
            const startTime = Date.now();

            try {
              if (hasGist) {
                  log("health GET", HEALTH_URL);
                  try {
                    const r = await fetchWithTimeout(HEALTH_URL, {
                      headers: { "Authorization": `Bearer ${PUSH_TOKEN}`, "User-Agent": UA }
                    }, 5000);
                    let t = ""; try { t = await r.text(); } catch {}
                    log("health status", r?.status || "ERR", (t || "").slice(0, 160));
                  } catch (e) {
                    log("health error", e?.message || e);
                  }
              }
              
              await pickMexcBase();

              // 1. Acquire distributed lock
              if (hasGist) {
                lock = await acquireLock(persist, 'pusher_main', 120000);
                log(`🔒 Lock acquired: ${lock.lockId}`);
              } else {
                 log('No Gist creds—skipping lock/state operations.');
              }
              
              // 2. Health check
              const health = await monitor.healthCheck();
              if (!health.healthy) {
                log('⚠️ System unhealthy:', JSON.stringify(health.checks));
                if (health.checks.api?.healthy === false) {
                  throw new Error('API health check failed - aborting');
                }
              }
              
              // 3. Load and validate state
              const { state } = await CircuitBreaker.execute('load_state', 
                () => loadState(hasGist ? persist : null), 
                { maxFailures: 3 }
              );
              
              const stateValidation = SafetyValidator.validateSystemState(state, health);
              if (stateValidation.recommendation === 'PAUSE_TRADING') {
                log('⚠️ System state issues:', stateValidation.issues);
                throw new Error('System state validation failed');
              }

              // 4. Check emergency conditions
              const marketDataForEmergency = { btc_k: await getKCached("BTCUSDT", "1h", 2) };
              const emergencyTriggers = await EmergencyResponse.checkEmergencyConditions(state, marketDataForEmergency);
              if (emergencyTriggers.length > 0) {
                await EmergencyResponse.executeEmergencyActions(emergencyTriggers, state, persist);
              }
              
              // 5. Check if paused
              if (state.pause_new_orders && Date.now() < state.pause_new_orders) {
                log('⏸️ New orders paused until', new Date(state.pause_new_orders).toISOString());
                return;
              }
              
              // 6. Run main strategy logic
              learnFromGistRealFills(state);
              const calibHealth = validateCalibration(state);
              const heartbeat = await heartbeatCheck(state);
              if((heartbeat?.zombies||0)>0) log("heartbeat zombies", heartbeat.zombies);
              const cleaned = await cleanupPendingBeforePlanning(state, heartbeat);
              if (hasGist && cleaned.dropped > 0) {
                await saveStateAtomic(persist, state, { changes: `Cleaned ${cleaned.dropped} orders`});
              }

              const ALL24 = await fetchAll24hr();
              const booksRaw=await getJSON(api("/api/v3/ticker/bookTicker"),10000,2) || [];
              const bookMap=new Map(booksRaw.map(b=>[b.symbol,{ bid:+b.bidPrice, ask:+b.askPrice, spread_bps: Math.round(((+b.askPrice - +b.bidPrice) / ((+b.bidPrice + +b.askPrice)/2)) * 10000) }]));
              if(!todOK) { log("TOD gate is closed."); if(lock) await lock.release(); return; }

              const kBTC1H=await getKCached("BTCUSDT","1h",K1H);
              const kBTC5 = await getKCached("BTCUSDT", "5m", K5M);
              const btcUp1h = (() => {
                if (!kBTC1H?.length) return false;
                const c = kBTC1H.map(x => +x[4]);
                return c.at(-1) >= ema(c, 21) && c.at(-1) >= ema(c, 50);
              })();
              const btcR5=(()=>{ const c=(kBTC5||[]).map(x=>+x[4]); const r=[]; for(let i=1;i<c.length;i++) r.push(Math.log(c[i]/c[i-1])); return r.slice(-120); })();

              const QUOTES=["USDT","USDC","USD"];
              const split=(sym)=>{ for(const q of QUOTES) if(sym.endsWith(q)) return { base:sym.slice(0,-q.length), quote:q }; return null; };
              const all=[]; for(const t of ALL24||[]){ const sym=t.symbol||t.s; if(!sym) continue; const sq=split(sym); if(!sq) continue; if(STABLES.has(sq.base)) continue; const qv=+(t.quoteVolume||t.q||0); if(!isFinite(qv)||qv<=0) continue; all.push({ symbol:sym, base:sq.base, quote:sq.quote, qv }); }
              all.sort((a,b)=>b.qv-a.qv);
              let dynMinQV=Math.max(MIN_QV_ENV||0,DYN_QV_MIN), filt=all.filter(x=>x.qv>=dynMinQV);
              while(filt.length<UNIV_TARGET_MIN && dynMinQV>1_000_000){ dynMinQV=Math.max(1_000_000, dynMinQV-DYN_QV_STEP); filt=all.filter(x=>x.qv>=dynMinQV); }
              const universe=filt.slice(0,UNIV_TARGET_MAX);
              log("universe", universe.length, "dyn_min_qv", dynMinQV);
              
              const equityStats=(eq)=>{ const day=Date.now()-24*3600*1000; let pnl24=0,cum=0,peak=0,dd=0; for(const e of eq||[]){ if(e.ts_ms>=day) pnl24+=e.pnl_bps; cum+=e.pnl_bps; if(cum>peak) peak=cum; dd=Math.min(dd,cum-peak); } return { pnl24_bps:Math.round(pnl24), peak_dd_bps:Math.round(dd) }; };
              const { pnl24_bps, peak_dd_bps } = equityStats(state.equity);
              const throttle=(pnl24_bps<=DD_24H_LIMIT_BPS) || (peak_dd_bps<=DD_PEAK_LIMIT_BPS);
              if (throttle) { log("DD throttle is active."); if(lock) await lock.release(); return; }

              const liqPct=new Map(); for(let i=0;i<universe.length;i++) liqPct.set(universe[i].symbol,(universe.length===1)?1:1-i/(universe.length-1));

              const picksRaw=[]; const B=10;
              for(let i=0;i<(universe||[]).length;i+=B){
                const batch=await Promise.all(universe.slice(i,i+B).map(async c=>{ try{
                  const lastTs=state.cooldown?.[c.base]||0; if(lastTs && (Date.now()-lastTs)<COOLDOWN_MS) return null;
                  const book=bookMap.get(c.symbol) || await getBookTickerCached(c.symbol); if(!book?.bid||!book?.ask) return null;
                  const mid=(+book.bid + +book.ask)/2; if(!(mid>0)) return null;
                  const spreadBps=Math.round(((book.ask-book.bid)/mid)*10000);
                  const k5=await getKCached(c.symbol,"5m",K5M); if(!k5||k5.length<Math.max(EMA_SLOW+5,ATR_P+5)) return null;
                  const c5_raw=k5.map(x=>+x[4]);
                  const c5=kalman1D(c5_raw,{q:1e-4,r:5e-4});
                  const h5=k5.map(x=>+x[2]), l5=k5.map(x=>+x[3]), v5=k5.map(x=>+x[5]);
                  const adxatr=computeADX_ATR(h5,l5,c5,ADX_P)||{};
                  const adx5=adxatr.adx||0, atr5=adxatr.atr||0;
                  const atr_bps=Math.round((atr5/(c5.at(-1)||1))*10000);
                  if(atr_bps<4||atr_bps>260) return null;
                  const vwap5=vwapAnchored(h5,l5,c5,v5,VWAP_5M_WIN);
                  const last=c5.at(-1), roc1=(last/(c5.at(-2)||last))-1, roc3=(last/(c5.at(-4)||last))-1;
                  const z_vwap=(last-vwap5)/(atr5||1);
                  const rsi14=rsi(c5,14);
                  const highs=h5, lows=l5;
                  const win=MR_BREAKOUT_DC_N;
                  const dcHi=Math.max(...highs.slice(-win)), dcLo=Math.min(...lows.slice(-win));
                  const atrPct=(atr5/last), ret15abs=Math.abs((last/(c5.at(-4)||last))-1);
                  const breakout=(last>dcHi)||(last<dcLo)||(ret15abs>=MR_BREAKOUT_RET15_ATR*atrPct);
                  if(breakout) state.mr_lockout[c.symbol]=Date.now()+MR_LOCKOUT_SEC*1000;
                  const mrLocked=(Date.now()<(state.mr_lockout?.[c.symbol]||0));
                  const noLongDown=NO_LONG_DOWN_ENABLE&&((rsi14||100)<LONG_DOWN_RSI_CUTOFF);
                  const adxF=clamp((adx5-16)/14,0,1);
                  const pTrend=clamp(0.5+0.27*(0.6*tanh(roc1/0.003)+0.4*tanh(roc3/0.0065))*adxF,0.32,0.93);
                  const pMR=clamp(0.5+0.23*(0.7*tanh(Math.abs(z_vwap))*Math.sign(-z_vwap)+0.3*(-(rsi14-50)/50))*(1-adxF),0.35,0.90);
                  const pLong0=clamp(0.45*pTrend+0.55*pMR,0.3,0.97);
                  const pShort0=clamp(0.45*(1-pTrend)+0.55*(1-pMR),0.3,0.97);
                  const ema21=ema(c5,21), ema50=ema(c5,50);
                  const roc5m=(c5.at(-1)/(c5.at(-6)||c5.at(-1)) - 1), roc15m=(c5.at(-1)/(c5.at(-16)||c5.at(-1)) - 1);
                  const slope=slopeBps(c5,21);
                  const dir=(!ema21||!ema50)?"flat":(ema21>ema50? "up" : (ema21<ema50? "down":"flat"));
                  return {c,k5,c5,h5,l5,v5,adx5,atr_bps,spreadBps,pLong0,pShort0,mrLocked,noLongDown,vol1h_est_usd:c.qv/24, trend5m:{ ema21, ema50, rsi:rsi14, roc5:roc5m, roc15:roc15m, adx:adx5, ema_slope_bps:slope, dir } };
                }catch{ return null; } }));
                for(const x of batch) if(x) picksRaw.push(x);
              }

              const prelim=picksRaw.map(p=>{
                const pW=Math.max(p.pLong0||0,p.pShort0||0), adxN=clamp((p.adx5-16)/14,0,1), sP=Math.max(0,(p.spreadBps||0)-6)/12;
                const score=0.6*pW+0.3*adxN-0.1*sP;
                return {p,score};
              }).sort((a,b)=>b.score-a.score).slice(0,30).map(x=>x.p);

              const refined=[];
              for(const p of prelim){
                try {
                  const c=p.c;
                  const book=bookMap.get(c.symbol)||await getBookTickerCached(c.symbol); if(!book?.bid||!book?.ask) continue;
                  const mid=(+book.bid + +book.ask)/2; if(!(mid>0)) continue;
                  const depth=await getDepthCached(c.symbol); if(!depth?.bids?.length || !depth?.asks?.length) continue;
                  const obi=computeOBI(depth,OBI_TOPN);
                  const km=await getKMultiTF(c.symbol);
                  const mtf=computeMTFIndicators(km, TF_WEIGHTS);
                  const sideSlipL=slipFromDepth(depth,mid,"long",NOTIONAL), sideSlipS=slipFromDepth(depth,mid,"short",NOTIONAL);
                  const slipL=sideSlipL?.slip_bps??Math.round(p.spreadBps/2), slipS=sideSlipS?.slip_bps??Math.round(p.spreadBps/2);
                  const costLong=COST_BPS+slipL, costShort=COST_BPS+slipS;
                  const d1=depthWithinPctUSD(depth,mid,0.01);
                  const depth1pUSD=(d1.asksUSD||0)+(d1.bidsUSD||0);
                  const regime=p.mrLocked?"trend":"meanrevert";
                  const coeffL = getCoeffs(state, "long", regime), coeffS = getCoeffs(state, "short", regime);
                  const pLong=calibrateP(state,"long",regime,p.pLong0), pShort=calibrateP(state,"short",regime,p.pShort0);
                  const pLong_lcb=wilsonLCB(pLong, Math.max(1, coeffL.n), WILSON_Z), pShort_lcb=wilsonLCB(pShort, Math.max(1, coeffS.n), WILSON_Z);
                  const yR=[]; for(let i=1;i<p.c5.length;i++) yR.push(Math.log(p.c5[i]/p.c5[i-1]));
                  const mu5=mean(yR)||0, sig5=Math.max(1e-4,std(yR));
                  let candLong=null, candShort=null;
                  if(DIRECTION!=="short"){
                    let tp=Math.round(LONG_BOUNCE_TP_ATR*p.atr_bps), sl=Math.round(LONG_BOUNCE_SL_ATR*p.atr_bps);
                    sl = Math.min(sl, 80); tp = Math.max(tp, Math.round(sl * 1.5));
                    const sim=pathEVHeavy({entry:mid,tp_bps:tp,sl_bps:sl,side:"long",retSeries:yR,mu:mu5,sigma:sig5,steps:4,cost_bps:costLong});
                    const evLCB=Math.round(pLong_lcb*tp-(1-pLong_lcb)*sl-costLong);
                    candLong={ side:"long", p_lcb:pLong_lcb,p_raw:p.pLong0, ev_bps:sim.ev_bps, exp_lcb_bps:evLCB, tp_bps:tp, sl_bps:sl, cost_bps:costLong, style:"mr", regime };
                  }
                  if(DIRECTION!=="long"){
                    let tp=Math.round(p.atr_bps*1.0), sl=Math.round(p.atr_bps*0.5);
                    sl = Math.min(sl, 80); tp = Math.max(tp, Math.round(sl * 1.5));
                    const sim=pathEVHeavy({entry:mid,tp_bps:tp,sl_bps:sl,side:"short",retSeries:yR,mu:mu5,sigma:sig5,steps:4,cost_bps:costShort});
                    const evLCB=Math.round(pShort_lcb*tp-(1-pShort_lcb)*sl-costShort);
                    candShort={ side:"short", p_lcb:pShort_lcb,p_raw:p.pShort0, ev_bps:sim.ev_bps, exp_lcb_bps:evLCB, tp_bps:tp, sl_bps:sl, cost_bps:costShort, style:"mr", regime };
                  }
                  const chosen=candLong&&candShort?(candLong.exp_lcb_bps>=candShort.exp_lcb_bps?candLong:candShort):(candLong||candShort||null);
                  if(!chosen) continue;
                  const conf = confidenceScore({ p_cal: chosen.p_lcb, ev_bps: chosen.ev_bps, atr_bps: p.atr_bps });
                  refined.push({ symbol:c.symbol, base:c.base, quote:c.quote, qv:c.qv, side:chosen.side, p_lcb:chosen.p_lcb, p_raw:chosen.p_raw, exp_lcb_bps:chosen.exp_lcb_bps, tp_bps:chosen.tp_bps, sl_bps:chosen.sl_bps, rrr:+(chosen.tp_bps/Math.max(1,chosen.sl_bps)).toFixed(2), cost_bps:chosen.cost_bps, regime:chosen.regime, hold_sec:clamp(720,TTL_MIN,TTL_MAX), confidence:conf, ret5:yR.slice(-36) });
                } catch(e) { log("Refine loop error", e.message); }
              }
              refined.sort((a,b)=>b.confidence-a.confidence);
              let picks=refined.slice(0,TOP_N);

              const wEv = softmax(picks.map(x => x.exp_lcb_bps || 0), 20);
              picks = picks.map((x, i) => ({
                ...x,
                size_bps: (Number(process.env.FORCE_SIZE_BPS || "0") > 0)
                  ? Math.round(Number(process.env.FORCE_SIZE_BPS))
                  : Math.min(220, Math.round((wEv[i] * TARGET_PORT_RISK_BPS / (x.sl_bps || 1)) * 100))
              }));

              // 7. Validate each idea before adding
              const validatedPicks = [];
              const marketContext = { bookMap };
              for (const [i, pick] of picks.entries()) {
                  const book = bookMap.get(pick.symbol);
                  const mid = book ? ((+book.bid + +book.ask) / 2) : null;
                  if (!mid) continue;

                  const fullIdea = {
                    idea_id: uuidv4(), client_order_id: mkClientOrderId("mxu"),
                    symbol: pick.base, symbol_full: pick.symbol, symbolFull: pick.symbol, quote: pick.quote, side: pick.side, rank: validatedPicks.length + 1,
                    entry_mid: mid,
                    entry_limit: pick.side === "long" ? mid * (1 - Math.max(0.001, pick.sl_bps / 20000)) : mid * (1 + pick.sl_bps / 20000),
                    tp_abs: pick.side === "long" ? mid * (1 + pick.tp_bps / 10000) : mid * (1 - pick.tp_bps / 10000),
                    sl_abs: pick.side === "long" ? mid * (1 - pick.sl_bps / 10000) : mid * (1 + pick.sl_bps / 10000),
                    tp_bps: pick.tp_bps, sl_bps: pick.sl_bps, rrr: pick.rrr, exp_lcb_bps: pick.exp_lcb_bps, cost_bps: pick.cost_bps,
                    p_win: pick.p_lcb, p_lcb: pick.p_lcb, p_raw: pick.p_raw, calib_key: `side:${pick.side}|regime:${pick.regime}`, regime: pick.regime,
                    ttl_sec: clamp(Math.round((pick.hold_sec || 720) + validatedPicks.length * 12), TTL_MIN, TTL_MAX),
                    size_bps: pick.size_bps || 0,
                    confidence: pick.confidence, ret5: pick.ret5,
                    predicted: { ts_ms: Date.now(), p_cal: pick.p_lcb, ev_bps: pick.exp_lcb_bps, confidence_score: pick.confidence }
                  };
                  const validation = SafetyValidator.validateIdea(fullIdea, state, marketContext);
                  if (!validation.valid) {
                      log(`❌ Idea rejected for ${fullIdea.symbol_full}:`, validation.errors);
                      continue;
                  }
                  if (validation.warnings.length > 0) {
                      log(`⚠️ Idea warnings for ${fullIdea.symbol_full}:`, validation.warnings);
                  }
                  validatedPicks.push({ ...fullIdea, validation_score: validation.score });
              }
              
              const varStats = portfolioVaR_ES_tCopula(validatedPicks, 6);
              if (varStats.ES95_bps < -220) {
                const scale = clamp(-220 / Math.min(-1e-6, varStats.ES95_bps), 0.35, 1);
                validatedPicks.forEach(p => p.size_bps = Math.max(4, Math.round(p.size_bps * scale)));
                log("[gha] VaR/ES throttle", varStats, "scale", scale);
              }
              
              // 8. Final portfolio risk check
              const calculatePortfolioRisk = (picks) => ({ total_risk_bps: picks.reduce((acc, p) => acc + (p.size_bps * p.sl_bps / 10000), 0) });
              const portfolioRisk = calculatePortfolioRisk(validatedPicks);
              if (portfolioRisk.total_risk_bps > 200) {
                log('⚠️ Portfolio risk too high:', portfolioRisk.total_risk_bps.toFixed(2));
                const scale = 200 / portfolioRisk.total_risk_bps;
                validatedPicks.forEach(p => p.size_bps = Math.round(p.size_bps * scale));
              }

              const nowMs = Date.now();
              for (const p of validatedPicks) {
                state.cooldown[p.symbol] = nowMs;
                state.pending.push({ ...p, status: 'planned', ts_ms: nowMs, ttl_ts_ms: nowMs + p.ttl_sec * 1000 });
              }
              
              // 9. Save state atomically
              if (hasGist) {
                await saveStateAtomic(persist, state, { 
                  changes: `Added ${validatedPicks.length} ideas`,
                  requireEtag: true 
                });
              }
              
              // 10. Push to worker with circuit breaker
              const meta = { origin:"github_actions", runId, calibration_health: calibHealth };
              const pushToWorker = async (ideas, meta) => {
                  const payload = { ts: new Date().toISOString(), mode: "normal", source: "external_pusher", meta, top_n: ideas.length, ideas };
                  return fetchWithTimeout(PUSH_URL,{
                    method:"POST",
                    headers:{ "Content-Type":"application/json", "Authorization":"Bearer " + PUSH_TOKEN },
                    body: JSON.stringify(payload)
                  });
              };
              await CircuitBreaker.execute('push_to_worker', 
                () => pushToWorker(validatedPicks, meta),
                { maxFailures: 3, timeout: 15000 }
              );
              
              // 11. Post-execution monitoring
              monitor.recordApiCall('push_complete', true, Date.now() - startTime);
              log(`✅ Run ${runId} completed successfully`);
              
            } finally {
              // Always release lock
              if (hasGist && lock) {
                await lock.release();
                log(`🔓 Lock released`);
              }
            }
          }
        
        // Execute with global error handlers
        process.on('uncaughtException', (error) => {
          console.error('💀 Uncaught exception:', error);
          sendSafeEmptyPayload('uncaught_exception').then(() => process.exit(1));
        });

        process.on('unhandledRejection', (reason, promise) => {
          console.error('💀 Unhandled rejection at:', promise, 'reason:', reason);
          sendSafeEmptyPayload('unhandled_rejection').then(() => process.exit(1));
        });

        main().catch(e => {
            log("FATAL MAIN ERROR", e.stack);
            monitor.alert('RUN_FAILED', e.message, 'HIGH');
            sendSafeEmptyPayload("main_catch_all").then(() => process.exit(1));
        });
        
        })();
        NODE

          EXIT_CODE=$?

          # Shell-level fallback (in case node crashed before posting)
          set -e
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo "[gha] pusher exited with code $EXIT_CODE — sending minimal payload so tail shows a [push] line"

            # Sanitize and derive URLs
            raw_push_url="$(printf '%s' "${WORKER_PUSH_URL}" | tr -d '\r\n')"
            health_url="$(printf '%s' "${raw_push_url}" | sed -E 's#/signals/push(\?.*)?$#/health#')"

            # 1) Fallback health GET (guaranteed Worker hit)
            echo "[gha] fallback health GET ${health_url}"
            http_code_h=$(curl -g -sS -o /dev/null -w "%{http_code}" \
              -H "Authorization: Bearer ${PUSH_TOKEN}" \
              --max-time 8 \
              "${health_url}" || true)
            echo "[gha] fallback health status ${http_code_h}"

            # 2) Minimal POST with 0 ideas
            now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            payload='{"ts":"'"${now}"'","mode":"normal","source":"external_pusher","meta":{"origin":"github_actions","reason":"fallback_node_error"},"top_n":0,"ideas":[]}'
            echo "[gha] pushing 0 ideas to ${raw_push_url}"
            mkdir -p /tmp
            : > /tmp/push_resp.txt
            http_code=$(curl -g -sS -o /tmp/push_resp.txt -w "%{http_code}" -X POST \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer ${PUSH_TOKEN}" \
              --data-raw "${payload}" \
              --max-time 12 \
              "${raw_push_url}" || true)
            body="$(head -c 400 /tmp/push_resp.txt || true)"
            echo "[gha] push status ${http_code} ${body}"
            exit 0
          fi
