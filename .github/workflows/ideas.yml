// always3_push.js
// Self-contained selection engine for "always 3" ideas per cycle
// - Slots: A (live), B (conditional), C (maker-only/passive)
// - Short-only by default (disable longs until retrained)
// - WinScore (calibrated win probability), LCB, EV gating
// - Cost-aware TP/SL adjustment
// - Liquidity/spread/slippage guards
// - Factor diversification
// - Always pushes 3 ideas; weak ones self-cancel (conditional/monitor)

'use strict';

// ---------------- Utils ----------------
const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
const sum = (a) => a.reduce((x, y) => x + y, 0);

// ---------------- Data-like models (JS objects) ----------------
// Candidate example shape:
// {
//   symbol: "BTCUSDT",
//   side: "short", // or "long"
//   style: "trend",
//   tp_bps: 10, sl_bps: 10, hold_sec: 1800,
//   cost_bps: 12, spread_bps_entry: 2, slip_bps_exit_est: 3,
//   depth1p_entry_usd: 1_000_000, notional_usd: 8500,
//   p_raw: 0.5, p_lcb_hint: null, calib_type: "identity", calib_n: 50,
//   cluster: "unknown", can_maker: true,
//   recent_slip_p50_bps: null, recent_slip_p90_bps: null
// }

// Idea example shape (produced by selector):
// {
//   symbol, side, style,
//   slot: "A"|"B"|"C",
//   execute: "now"|"conditional"|"maker_only"|"monitor",
//   post_only: boolean, maker_only: boolean, time_in_force: "GTC",
//   ttl_in_queue_ms: number,
//   hold_sec, tp_bps, sl_bps,
//   triggers: { spread_cap_bps, obi_min, adx_min, vol1s_cap_bps },
//   win_score, win_score_lcb, ev_net_bps, cost_floor_bps,
//   spread_bps_entry, depth1p_entry_usd,
//   passes_cost_floor: boolean, passes_win_min: boolean,
//   diversification_tag: string, notes: string
// }

// ---------------- Config ----------------
function defaultConfig() {
  return {
    // Global behavior
    disable_longs: true,
    always_three: true,

    // Safety margins and floors
    tp_safety_margin_bps: 5.0,
    sl_to_tp_max_ratio: 0.8, // SL <= 0.8 * TP

    // Liquidity/spread caps
    spread_cap_majors_bps: 2.0,
    spread_cap_liq_alts_bps: 5.0,
    spread_cap_illiquid_bps: 10.0,

    // Depth guard (min top-of-book depth relative to notional)
    min_depth_multiplier: 30.0, // e.g., depth >= 30x notional

    // Rolling slip guard
    slip_p50_cap_bps: 6.0,

    // Slots thresholds (WinScore and EV)
    slotA_win_min: 58.0,
    slotA_win_lcb_min: 54.0,
    slotA_ev_net_min_bps: 5.0,

    slotB_win_min: 54.0,
    slotB_win_lcb_min: 51.0,
    slotB_ev_net_min_bps: 3.0,

    slotC_win_min: 52.0,
    slotC_win_lcb_min: 50.0,
    slotC_queue_ttl_ms: 20_000, // 20s maker queue TTL

    // Diversification
    max_same_cluster: 2, // no more than 2 in same factor cluster for 3 picks

    // Maker preference for C
    c_slot_min_spread_bps: 4.0,

    // Buckets for min TP by liquidity
    min_tp_major_bps: 20.0,
    min_tp_liq_alt_bps: 25.0,
    min_tp_illiquid_bps: 35.0,

    // Confidence bound (LCB) z-score (95% ~ 1.96)
    lcb_z: 1.96,

    // Denylist defaults based on recent run
    denylist: ["ALPINE", "XPL", "PENGU"],

    // Allowlist preference (optional)
    allowlist: []
  };
}

// ---------------- Calibration / metrics helpers ----------------
class Calibrator {
  constructor(kind = "identity") {
    this.kind = kind;
    // Extend with platt/isotonic params if needed
  }
  apply(p_raw) {
    const p = Number.isFinite(p_raw) ? p_raw : 0.5;
    if (this.kind === "identity") return clamp(p, 0, 1);
    if (this.kind === "platt") return clamp(p, 0, 1);     // placeholder
    if (this.kind === "isotonic") return clamp(p, 0, 1);  // placeholder
    return clamp(p, 0, 1);
  }
}

function lowerConfidenceBoundNormal(p, n_eff, z) {
  const n = Math.max(1, Math.floor(n_eff || 1));
  const pp = clamp(p, 0, 1);
  const se = Math.sqrt(Math.max(1e-12, (pp * (1 - pp)) / n));
  return Math.max(0, pp - z * se);
}

function classifyLiquidityBucket(depth1p_entry_usd, notional_usd) {
  const ratio = (depth1p_entry_usd || 0) / Math.max(1, notional_usd || 1);
  if (ratio >= 200) return "major";
  if (ratio >= 50) return "liq_alt";
  return "illiquid";
}

function minTpByBucket(cfg, bucket) {
  if (bucket === "major") return cfg.min_tp_major_bps;
  if (bucket === "liq_alt") return cfg.min_tp_liq_alt_bps;
  return cfg.min_tp_illiquid_bps;
}

function spreadCapByBucket(cfg, bucket) {
  if (bucket === "major") return cfg.spread_cap_majors_bps;
  if (bucket === "liq_alt") return cfg.spread_cap_liq_alts_bps;
  return cfg.spread_cap_illiquid_bps;
}

function computeCostFloorBps(c) {
  let slip = c.slip_bps_exit_est || 0;
  if (Number.isFinite(c.recent_slip_p50_bps)) {
    slip = Math.max(slip, c.recent_slip_p50_bps);
  }
  return (c.cost_bps || 0) + (c.spread_bps_entry || 0) + (slip || 0);
}

function adjustTpSl(c, cfg, costFloorBps) {
  const bucket = classifyLiquidityBucket(c.depth1p_entry_usd, c.notional_usd);
  const tpFloor = Math.max(costFloorBps + cfg.tp_safety_margin_bps, minTpByBucket(cfg, bucket));
  const tpAdj = Math.max(c.tp_bps || 0, tpFloor);
  const slCap = cfg.sl_to_tp_max_ratio * tpAdj;
  const slAdj = Math.min(c.sl_bps || 0, slCap);
  const note = `bucket=${bucket}, tp_floor=${tpFloor.toFixed(1)}, sl_cap=${slCap.toFixed(1)}`;
  return { tpAdj, slAdj, note, bucket };
}

function estimateWinScores(c, cfg, calibrator) {
  const p = calibrator.apply(c.p_raw || 0.5);
  const pLcb = (c.p_lcb_hint != null)
    ? clamp(c.p_lcb_hint, 0, 1)
    : lowerConfidenceBoundNormal(p, c.calib_n || 1, cfg.lcb_z);
  return { winScore: 100 * p, winLCB: 100 * pLcb };
}

function computeEvNetBps(p_win, tp_bps, sl_bps, cost_floor_bps) {
  const p = clamp(p_win, 0, 1);
  return p * tp_bps - (1 - p) * sl_bps - cost_floor_bps;
}

function passesLiquiditySpreadGuards(c, cfg) {
  const bucket = classifyLiquidityBucket(c.depth1p_entry_usd, c.notional_usd);
  const spreadCap = spreadCapByBucket(cfg, bucket);
  if ((c.spread_bps_entry || 0) > spreadCap) return false;
  if ((c.depth1p_entry_usd || 0) < cfg.min_depth_multiplier * (c.notional_usd || 1)) return false;
  if (Number.isFinite(c.recent_slip_p50_bps) && c.recent_slip_p50_bps > cfg.slip_p50_cap_bps) return false;
  return true;
}

function symbolBase(symbol) {
  if (!symbol) return symbol;
  if (symbol.endsWith("USDT")) return symbol.slice(0, -4);
  if (symbol.endsWith("USDC")) return symbol.slice(0, -4);
  if (symbol.endsWith("USD")) return symbol.slice(0, -3);
  return symbol;
}

function inDenylist(symbol, cfg) {
  const base = symbolBase(symbol);
  if ((cfg.allowlist || []).includes(base)) return false;
  return (cfg.denylist || []).includes(base);
}

// ---------------- Selector ----------------
class Always3Selector {
  constructor(cfg = null, calibrator = null) {
    this.cfg = cfg || defaultConfig();
    const calKind = (this.cfg && this.cfg.calib_type) ? this.cfg.calib_type : "identity";
    this.calibrator = calibrator || new Calibrator(calKind);
  }

  select(candidates = []) {
    // 1) Filter by basic policy
    const filtered = [];
    for (const c of candidates) {
      const side = String(c.side || "").toLowerCase();
      if (this.cfg.disable_longs && side === "long") continue;
      if (inDenylist(c.symbol, this.cfg)) continue;
      filtered.push(c);
    }

    // 2) Compute metrics for each candidate
    const scored = [];
    for (const c of filtered) {
      const liqOK = passesLiquiditySpreadGuards(c, this.cfg);
      const costFloor = computeCostFloorBps(c);
      const { tpAdj, slAdj, note, bucket } = adjustTpSl(c, this.cfg, costFloor);
      const { winScore, winLCB } = estimateWinScores(c, this.cfg, this.calibrator);
      const pWin = winScore / 100;
      const evNet = computeEvNetBps(pWin, tpAdj, slAdj, costFloor);
      const info = {
        liq_ok: liqOK,
        cost_floor_bps: costFloor,
        tp_bps: tpAdj,
        sl_bps: slAdj,
        win_score: winScore,
        win_lcb: winLCB,
        ev_net_bps: evNet,
        adj_note: note,
        bucket
      };
      scored.push([c, info]);
    }

    // 3) Rank primarily by win_score, secondarily by EV
    scored.sort((a, b) => {
      if (b[1].win_score !== a[1].win_score) return b[1].win_score - a[1].win_score;
      return b[1].ev_net_bps - a[1].ev_net_bps;
    });

    // 4) Diversification shortlist (limit clusters)
    const selectedPairs = [];
    const clusterCounts = new Map();
    for (const [c, info] of scored) {
      const cl = c.cluster || "unknown";
      const cnt = clusterCounts.get(cl) || 0;
      if (cnt >= this.cfg.max_same_cluster) continue;
      clusterCounts.set(cl, cnt + 1);
      selectedPairs.push([c, info]);
      if (selectedPairs.length >= 6) break; // shortlist size
    }

    // 5) Gating + slot assignment
    const ideas = [];
    const usedSymbols = new Set();

    const makeIdea = (c, info, slot, execute) => {
      const bucket = info.bucket;
      const spreadCap = spreadCapByBucket(this.cfg, bucket);
      const triggers = {
        spread_cap_bps: spreadCap,
        obi_min: 0.55, // for shorts, example micro bias
        adx_min: 15.0,
        vol1s_cap_bps: info.tp_bps * 0.7
      };
      const makerOnly = slot === "C" || execute === "maker_only";
      const postOnly = makerOnly || execute === "now" || execute === "conditional";
      const tif = "GTC";

      return {
        symbol: c.symbol,
        side: c.side,
        style: c.style || "trend",
        slot,
        execute,
        post_only: !!postOnly,
        maker_only: !!makerOnly,
        time_in_force: tif,
        ttl_in_queue_ms: slot === "C" ? this.cfg.slotC_queue_ttl_ms : 0,
        hold_sec: c.hold_sec || 1800,
        tp_bps: info.tp_bps,
        sl_bps: info.sl_bps,
        triggers,
        win_score: info.win_score,
        win_score_lcb: info.win_lcb,
        ev_net_bps: info.ev_net_bps,
        cost_floor_bps: info.cost_floor_bps,
        spread_bps_entry: c.spread_bps_entry || 0,
        depth1p_entry_usd: c.depth1p_entry_usd || 0,
        passes_cost_floor: info.tp_bps >= info.cost_floor_bps + this.cfg.tp_safety_margin_bps,
        passes_win_min: false, // set after gating
        diversification_tag: c.cluster || "unknown",
        notes: info.adj_note
      };
    };

    const gateA = (info, c) =>
      info.liq_ok &&
      info.win_score >= this.cfg.slotA_win_min &&
      info.win_lcb >= this.cfg.slotA_win_lcb_min &&
      info.ev_net_bps >= this.cfg.slotA_ev_net_min_bps;

    const gateB = (info, c) =>
      info.liq_ok &&
      (info.win_score >= this.cfg.slotB_win_min || info.ev_net_bps >= this.cfg.slotB_ev_net_min_bps) &&
      info.win_lcb >= this.cfg.slotB_win_lcb_min;

    const gateC = (info, c) =>
      (c.can_maker ?? true) &&
      info.liq_ok &&
      (c.spread_bps_entry || 0) >= this.cfg.c_slot_min_spread_bps &&
      info.win_score >= this.cfg.slotC_win_min &&
      info.win_lcb >= this.cfg.slotC_win_lcb_min &&
      info.tp_bps > info.cost_floor_bps;

    // Slot A
    for (const [c, info] of selectedPairs) {
      if (usedSymbols.has(c.symbol)) continue;
      if (gateA(info, c)) {
        const ideaA = makeIdea(c, info, "A", "now");
        ideaA.passes_win_min = true;
        ideas.push(ideaA);
        usedSymbols.add(c.symbol);
        break;
      }
    }

    // Slot B
    for (const [c, info] of selectedPairs) {
      if (usedSymbols.has(c.symbol)) continue;
      if (gateB(info, c)) {
        const ideaB = makeIdea(c, info, "B", "conditional");
        ideaB.passes_win_min = ideaB.win_score >= this.cfg.slotB_win_min;
        ideas.push(ideaB);
        usedSymbols.add(c.symbol);
        break;
      }
    }

    // Slot C
    for (const [c, info] of selectedPairs) {
      if (usedSymbols.has(c.symbol)) continue;
      if (gateC(info, c)) {
        const ideaC = makeIdea(c, info, "C", "maker_only");
        ideaC.passes_win_min = ideaC.win_score >= this.cfg.slotC_win_min;
        ideas.push(ideaC);
        usedSymbols.add(c.symbol);
        break;
      }
    }

    // Fill up with monitors if < 3
    for (const [c, info] of selectedPairs) {
      if (ideas.length >= 3) break;
      if (usedSymbols.has(c.symbol)) continue;
      const slot = ideas.length === 1 ? "B" : "C";
      const ideaM = makeIdea(c, info, slot, "monitor");
      const bucketCap = spreadCapByBucket(this.cfg, info.bucket);
      const reasons = [];
      if (!info.liq_ok) reasons.push("liquidity/spread guard");
      if (info.win_score < this.cfg.slotB_win_min && info.ev_net_bps < this.cfg.slotB_ev_net_min_bps) reasons.push("low WinScore/EV");
      if (ideaM.tp_bps < ideaM.cost_floor_bps + this.cfg.tp_safety_margin_bps) reasons.push("tp below cost floor");
      if ((c.spread_bps_entry || 0) > bucketCap) reasons.push("spread too wide");
      ideaM.notes = `${ideaM.notes}; monitor: ${reasons.join(", ")}`.replace(/^;\s*/, "");
      ideas.push(ideaM);
      usedSymbols.add(c.symbol);
    }

    // Ensure exactly 3 (placeholders if needed)
    while (ideas.length < 3) {
      ideas.push({
        symbol: "NONE",
        side: "short",
        style: "trend",
        slot: ideas.length === 2 ? "C" : "B",
        execute: "monitor",
        post_only: false,
        maker_only: false,
        time_in_force: "GTC",
        ttl_in_queue_ms: 0,
        hold_sec: 1800,
        tp_bps: 0,
        sl_bps: 0,
        triggers: {},
        win_score: 0,
        win_score_lcb: 0,
        ev_net_bps: 0,
        cost_floor_bps: 0,
        spread_bps_entry: 0,
        depth1p_entry_usd: 0,
        passes_cost_floor: false,
        passes_win_min: false,
        diversification_tag: "",
        notes: "placeholder"
      });
    }

    // Dedup by (symbol, slot) and cap at 3
    const out = [];
    const seen = new Set();
    for (const idea of ideas) {
      const key = `${idea.symbol}::${idea.slot}`;
      if (seen.has(key)) continue;
      seen.add(key);
      out.push(idea);
      if (out.length >= 3) break;
    }
    return out;
  }
}

// ---------------- Example usage ----------------
if (require.main === module) {
  const cfg = {
    ...defaultConfig(),
    disable_longs: true,
    denylist: ["ALPINE", "XPL", "PENGU"]
  };
  const selector = new Always3Selector(cfg, new Calibrator("identity"));

  const candidates = [
    { symbol: "BTCUSDT", side: "short", tp_bps: 6, sl_bps: 6, cost_bps: 10,
      spread_bps_entry: 1, slip_bps_exit_est: 3, depth1p_entry_usd: 11_000_000,
      notional_usd: 8_500, p_raw: 0.62, calib_n: 100, cluster: "BTC_beta" },
    { symbol: "LTCUSDT", side: "short", tp_bps: 14, sl_bps: 7, cost_bps: 11,
      spread_bps_entry: 1, slip_bps_exit_est: 3, depth1p_entry_usd: 900_000,
      notional_usd: 8_500, p_raw: 0.57, calib_n: 80, cluster: "BTC_beta" },
    { symbol: "OPUSDT", side: "short", tp_bps: 22, sl_bps: 11, cost_bps: 11,
      spread_bps_entry: 2, slip_bps_exit_est: 4, depth1p_entry_usd: 740_000,
      notional_usd: 8_500, p_raw: 0.56, calib_n: 60, cluster: "L2" },
    { symbol: "KAITOUSDT", side: "short", tp_bps: 60, sl_bps: 30, cost_bps: 16,
      spread_bps_entry: 7, slip_bps_exit_est: 8, depth1p_entry_usd: 24_000,
      notional_usd: 1_200, p_raw: 0.64, calib_n: 30, cluster: "illiquid" },
    { symbol: "XRPUSDT", side: "short", tp_bps: 15, sl_bps: 14, cost_bps: 12,
      spread_bps_entry: 2, slip_bps_exit_est: 4, depth1p_entry_usd: 1_850_000,
      notional_usd: 8_500, p_raw: 0.55, calib_n: 90, cluster: "BTC_beta" },
    { symbol: "ALPINEUSDT", side: "long", tp_bps: 31, sl_bps: 16, cost_bps: 37,
      spread_bps_entry: 11, slip_bps_exit_est: 10, depth1p_entry_usd: 24_000,
      notional_usd: 1_700, p_raw: 0.54, calib_n: 30, cluster: "illiquid" }
  ];

  const ideas = selector.select(candidates);
  ideas.forEach((idea, i) => {
    console.log(`Idea ${i + 1}:`, JSON.stringify(idea));
  });
}

// Optional export
module.exports = { Always3Selector, Calibrator, defaultConfig };
