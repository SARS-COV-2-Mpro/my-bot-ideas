name: Ideas Pusher (MEXC Ultimate 6.9)

on:
  workflow_dispatch:
  schedule:
    - cron: "*/11 * * * *" # runs every 11 minutes

permissions:
  contents: read

concurrency:
  group: ideas-mexc-ultimate
  cancel-in-progress: true

jobs:
  push:
    runs-on: ubuntu-latest
    timeout-minutes: 12
    env:
      # Required secrets
      WORKER_PUSH_URL: ${{ secrets.WORKER_PUSH_URL }}
      PUSH_TOKEN: ${{ secrets.PUSH_TOKEN }}
      MEXC_API_KEY: ${{ secrets.MEXC_API_KEY }}
      MEXC_SECRET_KEY: ${{ secrets.MEXC_SECRET_KEY }}

      # Optional (safe defaults inside the script)
      GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
      GIST_ID: ${{ secrets.GIST_ID }}

      # Exchange + tuning knobs (via Repo/Org Variables)
      EXCHANGE: mexc
      MIN_QV_USD: ${{ vars.MIN_QV_USD }}
      TOP_N: ${{ vars.TOP_N }}
      MAX_SPREAD_BPS: ${{ vars.MAX_SPREAD_BPS }}
      EXP_LCB_MIN_BPS: ${{ vars.EXP_LCB_MIN_BPS }}
      FEES_BPS: ${{ vars.FEES_BPS }}
      NOTIONAL_USD: ${{ vars.NOTIONAL_USD }}
      MEXC_DEPTH_LIMIT: ${{ vars.MEXC_DEPTH_LIMIT }}
      OBI_TOPN: ${{ vars.OBI_TOPN }}
      ACTIVE_UTC_START: ${{ vars.ACTIVE_UTC_START }}
      ACTIVE_UTC_END: ${{ vars.ACTIVE_UTC_END }}
      MEXC_BASE: ${{ vars.MEXC_BASE }}
      FORCE_SIZE_BPS: ${{ vars.FORCE_SIZE_BPS }}

      # New Confidence Model Knobs
      DIRECTION: ${{ vars.DIRECTION }}
      MR_SLOPE_MAX_ATR50: ${{ vars.MR_SLOPE_MAX_ATR50 }}
      MR_BREAKOUT_DC_N: ${{ vars.MR_BREAKOUT_DC_N }}
      MR_BREAKOUT_RET15_ATR: ${{ vars.MR_BREAKOUT_RET15_ATR }}
      MR_LOCKOUT_SEC: ${{ vars.MR_LOCKOUT_SEC }}
      MAX_COST_BPS_HARD: ${{ vars.MAX_COST_BPS_HARD }}
      MIN_VOL_1H_USD: ${{ vars.MIN_VOL_1H_USD }}
      DEPTH_1P_MIN_USD: ${{ vars.DEPTH_1P_MIN_USD }}
      NO_LONG_DOWN_ENABLE: ${{ vars.NO_LONG_DOWN_ENABLE }}
      LONG_DOWN_RSI_CUTOFF: ${{ vars.LONG_DOWN_RSI_CUTOFF }}
      LONG_MR_DIVERGENCE_REQ: ${{ vars.LONG_MR_DIVERGENCE_REQ }}
      LONG_EDGE_MULT_MIN: ${{ vars.LONG_EDGE_MULT_MIN }}
      LONG_BOUNCE_SL_ATR: ${{ vars.LONG_BOUNCE_SL_ATR }}
      LONG_BOUNCE_TP_ATR: ${{ vars.LONG_BOUNCE_TP_ATR }}
      LONG_SIMILARITY_RHO: ${{ vars.LONG_SIMILARITY_RHO }}
      
      # MTF Tuning Knobs
      MIN_TF_ALIGN: ${{ vars.MIN_TF_ALIGN || "0.60" }}
      MTF_BATCH: ${{ vars.MTF_BATCH }}
      DEBUG_MTF: ${{ vars.DEBUG_MTF }}

    steps:
      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Run pusher (always-push + clear logs)
        shell: bash
        run: |
          set -euo pipefail

          # Hard fail only on true misconfig (so setup problems aren't hidden)
          if [[ -z "${WORKER_PUSH_URL:-}" || -z "${PUSH_TOKEN:-}" ]]; then
            echo "[gha] Missing WORKER_PUSH_URL or PUSH_TOKEN"
            exit 1
          fi

          set +e
          node - <<'NODE'
          (async ()=>{
          'use strict';
          const crypto = require('crypto');
          
          // ---------------- Utils ----------------
          const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
          const tanh=(x)=>Math.tanh(x);
          const sum=(a)=>a.reduce((x,y)=>x+y,0);
          const mean=(a)=>a.length?sum(a)/a.length:0;
          const std=(a)=>{ const m=mean(a); let v=0; for(const x of a) v+=(x-m)*(x-m); return a.length>1?Math.sqrt(v/(a.length-1)):0; };
          const ema=(arr,p)=>{ if(!arr||arr.length<p) return null; const k=2/(p+1); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; for(let i=p;i<arr.length;i++) e=arr[i]*k+e*(1-k); return e; };
          const rsi=(cl,p=14)=>{ if(!cl||cl.length<=p) return null; let g=0,l=0; for(let i=1;i<=p;i++){ const d=cl[i]-cl[i-1]; g+=Math.max(0,d); l+=Math.max(0,-d); } let ag=g/p, al=l/p; for(let i=p+1;i<cl.length;i++){ const d=cl[i]-cl[i-1]; ag=(ag*(p-1)+Math.max(0,d))/p; al=(al*(p-1)+Math.max(0,-d))/p; } const rs=al===0?100:ag/al; return 100-100/(1+rs); };
          const computeADX_ATR=(h,l,c,p=14)=>{ const n=c.length; if(n<p+2) return null; const TR=[],plusDM=[],minusDM=[]; for(let i=1;i<n;i++){ const up=h[i]-h[i-1], down=l[i-1]-l[i]; plusDM.push((up>down&&up>0)?up:0); minusDM.push((down>up&&down>0)?down:0); TR.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1]))); } let trN=0,pdmN=0,ndmN=0; for(let i=0;i<p;i++){ trN+=TR[i]; pdmN+=plusDM[i]; ndmN+=minusDM[i]; } let pDI=100*(pdmN/(trN||1)), nDI=100*(ndmN/(trN||1)); let dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1), adx=dx; for(let i=p;i<TR.length;i++){ trN=trN-(trN/p)+TR[i]; pdmN=pdmN-(pdmN/p)+plusDM[i]; ndmN=ndmN-(ndmN/p)+minusDM[i]; pDI=100*(pdmN/(trN||1)); nDI=100*(ndmN/(trN||1)); dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1); adx=((adx*(p-1))+dx)/p; } const atr=trN/p; return { adx, atr, trLast: TR.at(-1) }; };
          const vwapAnchored=(h,l,c,v,win)=>{ if(!c?.length) return null; const n=c.length,s=Math.max(0,n-win); let pv=0,vv=0; for(let i=s;i<n;i++){ const tp=(h[i]+l[i]+c[i])/3; const vol=+v[i]||0; pv+=tp*vol; vv+=vol; } return vv>0?pv/vv:c.at(-1); };
          const corr=(a,b)=>{ const n=Math.min(a?.length||0,b?.length||0); if(n<5) return 0; const as=a.slice(-n), bs=b.slice(-n); const ma=mean(as), mb=mean(bs); let num=0,da=0,db=0; for(let i=0;i<n;i++){ const xa=as[i]-ma, xb=bs[i]-mb; num+=xa*xb; da+=xa*xa; db+=xb*xb; } const den=Math.sqrt(da*db)||1; return num/den; };
          const wilsonLCB=(p,n,z=1.34)=>{ if(n<=0) return p; const z2=z*z; const a=p + z2/(2*n); const b=z*Math.sqrt((p*(1-p)+z2/(4*n))/n); const c=1+z2/n; return clamp((a-b)/c, 0, 1); };
          const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
          const jitter=(ms)=>ms + Math.floor(Math.random()*ms*0.25);
          const log=(...a)=>console.log("[gha]",...a);
          const softmax=(arr,t=20)=>{ const m=Math.max(...arr,0); const ex=arr.map(x=>Math.exp((x-m)/t)); const s=ex.reduce((a,b)=>a+b,0)||1; return ex.map(x=>x/s); };
          const sigmoid=(z)=>1/(1+Math.exp(-z));
          const kalman1D=(obs,{q=1e-5,r=1e-3,x0=null,p0=1e-2}={})=>{ if(!obs?.length) return []; let x=(x0==null?obs[0]:x0), p=p0; const out=[]; for(const z of obs){ p+=q; const K=p/(p+r); x=x+K*(z-x); p=(1-K)*p; out.push(x); } return out; };
          const getTradeFingerprint=(data)=>{ const str=`${(data.client_order_id || data.idea_id)}:${data.side}:${(data.price_entry||0).toFixed(5)}:${(data.qty||0).toFixed(5)}`; return crypto.createHash('sha1').update(str).digest('hex').slice(0, 16); };
          const slopeBps=(arr, n=12)=>{ if(!arr?.length) return 0; const a=arr.slice(-n); const N=a.length; if(N<3) return 0; const xMean=(N-1)/2; let num=0, den=0; const last=a[N-1]||1; for(let i=0;i<N;i++){ const x=i,y=a[i]; num+=(x-xMean)*y; den+=(x-xMean)*(x-xMean); } const slope=den>0?num/den:0; return Math.round((slope/last)*10000);};
          
          // ---------- Microstructure / Heavy Features helpers ----------
          const computeOBI=(depth, topN=12)=>{ if(!depth?.asks?.length || !depth?.bids?.length) return 0; const w=(i)=>Math.exp(-i*0.18); let bidNot=0, askNot=0; for(let i=0;i<Math.min(topN, depth.bids.length); i++){ const p=+depth.bids[i][0], q=+depth.bids[i][1]; if(p>0&&q>0) bidNot += p*q*w(i); } for(let i=0;i<Math.min(topN, depth.asks.length); i++){ const p=+depth.asks[i][0], q=+depth.asks[i][1]; if(p>0&&q>0) askNot += p*q*w(i); } return (bidNot+askNot>0) ? (bidNot-askNot)/(bidNot+askNot) : 0; };
          const vwapFillLevels = (levels, targetUSD) => { let remain = targetUSD, val = 0, qty = 0; for (const [ps, qs] of (levels || [])) { const p = +ps, q = +qs; if (!(p > 0 && q > 0)) continue; const can = p * q, take = Math.min(remain, can), tq = take / p; val += p * tq; qty += tq; remain -= take; if (remain <= 1e-6) break; } return { px: qty > 0 ? val / qty : null, filledUSD: (targetUSD - remain) }; };
          const slipFromDepth=(depth,mid,side,notionalUSD)=>{ if(!depth?.asks?.length || !depth?.bids?.length || !(mid>0)) return { slip_bps:null, fill_prob:null }; if(side==="long"){ const buy=vwapFillLevels(depth.asks, Math.max(50,notionalUSD)); const slip = buy.px? Math.max(0, Math.round((buy.px - mid)/mid*10000)) : null; return { slip_bps: slip, fill_prob: Math.min(1, (buy.filledUSD||0)/Math.max(1,notionalUSD)) }; }else{ const sell=vwapFillLevels(depth.bids, Math.max(50,notionalUSD)); const slip = sell.px? Math.max(0, Math.round((mid - sell.px)/mid*10000)) : null; return { slip_bps: slip, fill_prob: Math.min(1, (sell.filledUSD||0)/Math.max(1,notionalUSD)) }; } };
          const confidenceScore=({ p_cal, ev_bps, atr_bps, micro, regime, reliability, riskAdj })=>{ const ev_norm = atr_bps>0? ev_bps/atr_bps : 0; const ev_sig = 1/(1+Math.exp(-ev_norm)); const base = 0.6*p_cal + 0.4*ev_sig; const mult = (micro||1)*(regime||1)*(reliability||1)*(riskAdj||1); return Math.round(100*base*mult); };
          const reasonBuilder=(ctx)=>{ const out=[]; if((ctx.adx1h||0)>22) out.push({ factor:"ADX_1h", value:+(ctx.adx1h||0).toFixed(1), contribution:+Math.min(12,(ctx.adx1h-22)*0.6).toFixed(1) }); if((ctx.ofi30s||0)>0) out.push({ factor:"OFI_30s", value:+(ctx.ofi30s||0).toFixed(3), contribution:+Math.min(10, ctx.ofi30s*10).toFixed(1) }); if((ctx.spread_bps||0)>8) out.push({ factor:"Spread_bps", value:ctx.spread_bps, contribution:-Math.min(8,(ctx.spread_bps-8)) }); if((ctx.slip_bps_est||0)>4) out.push({ factor:"Slip_est_bps", value:ctx.slip_bps_est, contribution:-Math.min(6,(ctx.slip_bps_est-4)) }); if((ctx.tfAlign||0)>=0.7) out.push({ factor:"TF_alignment", value:+(ctx.tfAlign||0).toFixed(2), contribution:+6.0 }); return out.sort((a,b)=>Math.abs(b.contribution)-Math.abs(a.contribution)).slice(0,5); };
          const computeMTFIndicators = (mtfData, TF_WEIGHTS, RSI_PERIOD, ADX_PERIOD, ROC_SHORT_BARS, ROC_MED_BARS) => { if (!mtfData) return null; let totalWeight = 0, sumRsi = 0, sumAdx = 0, sumAtrBps = 0, sumRocShort = 0, sumRocMed = 0; const tfCloses = []; for (const [tf, data] of Object.entries(mtfData)) { const { c_kalman: c, highs: h, lows: l } = data; const last = c.at(-1); if (!(last > 0)) continue; const rsi_tf = rsi(c, RSI_PERIOD); const { adx: adx_tf, atr: atr_tf } = computeADX_ATR(h, l, c, ADX_PERIOD) || {}; const rocShort_tf = (last / (c.at(-1 - ROC_SHORT_BARS) || last)) - 1; const rocMed_tf = (last / (c.at(-1 - ROC_MED_BARS) || last)) - 1; const atr_bps_tf = atr_tf ? Math.round((atr_tf / last) * 10000) : 0; const w = TF_WEIGHTS[tf]; if(w > 0) { sumRsi += (rsi_tf || 50) * w; sumAdx += (adx_tf || 0) * w; sumAtrBps += atr_bps_tf * w; sumRocShort += rocShort_tf * w; sumRocMed += rocMed_tf * w; totalWeight += w; } tfCloses.push(c.slice(-50)); } if (totalWeight < 0.9) return null; const avgRsi = sumRsi / totalWeight; const avgAdx = sumAdx / totalWeight; const avgAtrBps = Math.round(sumAtrBps / totalWeight); const avgRoc5 = sumRocShort / totalWeight; const avgRoc15 = sumRocMed / totalWeight; let tfAlign = 0, alignCount = 0; for (let i = 0; i < tfCloses.length; i++) { for (let j = i + 1; j < tfCloses.length; j++) { tfAlign += corr(tfCloses[i], tfCloses[j]); alignCount++; } } tfAlign = alignCount > 0 ? tfAlign / alignCount : 0; return { avgRsi, avgAdx, avgAtrBps, avgRoc5, avgRoc15, tfAlign: clamp(tfAlign, 0, 1) }; };

          // ---------- HTTP + Concurrency ----------
          const UA = "gh-actions-mexc-ultimate/6.9 (+https://github.com/)";
          async function fetchWithTimeout(url, opts = {}, ms = 12000) {
            const ac = new AbortController(); const t = setTimeout(() => ac.abort(), ms);
            try { return await fetch(url, { ...opts, signal: ac.signal, headers: { "User-Agent": UA, ...(opts.headers || {}) } }); }
            finally { clearTimeout(t); }
          }
          async function getJSON(url, ms = 12000, tries = 2) {
            for (let a = 0; a < tries; a++) {
              try { const r = await fetchWithTimeout(url, {}, ms); if (r?.ok) return await r.json(); } catch {}
              if(a < tries - 1) await sleep(jitter(250));
            }
            return null;
          }
          
          // ---------- Config / ENV ----------
          const EXCHANGE=(process.env.EXCHANGE||"mexc").toLowerCase().replace("mexci","mexc");
          const MEXC_API_KEY = process.env.MEXC_API_KEY || ""; const MEXC_SECRET_KEY = process.env.MEXC_SECRET_KEY || "";
          const GIST_TOKEN=process.env.GIST_TOKEN||"", GIST_ID=process.env.GIST_ID||"";
          if(EXCHANGE!=="mexc"){ log("This build targets MEXC. Set EXCHANGE=mexc"); process.exit(1); }
          const MEXC_BASES=[process.env.MEXC_BASE,"https://api.mexc.com","https://www.mexc.com"].filter(Boolean);
          const MIN_QV_ENV = Number(process.env.MIN_QV_USD||"0") || 0;
          const UNIV_TARGET_MIN=100, UNIV_TARGET_MAX=120, DYN_QV_MIN=Number(process.env.DYN_QV_MIN||"10000000"), DYN_QV_STEP=5_000_000;
          const TOP_N=Number(process.env.TOP_N||"3"), MAX_SPREAD_BPS=Number(process.env.MAX_SPREAD_BPS||"12");
          const EXP_LCB_MIN_BPS_BASE=Number(process.env.EXP_LCB_MIN_BPS||"12");
          const COST_BPS=Number(process.env.FEES_BPS||"10"), NOTIONAL=Number(process.env.NOTIONAL_USD||"300");
          const DEPTH_LIMIT=Number(process.env.MEXC_DEPTH_LIMIT||process.env.DEPTH_LIMIT||"50"), OBI_TOPN=Number(process.env.OBI_TOPN||"12");
          const COOLDOWN_MS=3*60*60*1000;
          const DD_24H_LIMIT_BPS=-150, DD_PEAK_LIMIT_BPS=-300;
          const WILSON_Z=1.34, TARGET_PORT_RISK_BPS=52, TTL_MIN=540, TTL_MAX=1200;
          const S_H=process.env.ACTIVE_UTC_START?Number(process.env.ACTIVE_UTC_START):null; const E_H=process.env.ACTIVE_UTC_END?Number(process.env.ACTIVE_UTC_END):null;
          const nowH=new Date().getUTCHours();
          const todOK=(S_H==null||E_H==null)?true:(S_H<=E_H?(nowH>=S_H&&nowH<=E_H):(nowH>=S_H||nowH<=E_H));
          const STABLES=new Set(["USDT","USDC","USD","USDE","USDD","BUSD","FDUSD","TUSD","DAI","USDP","PAX","USTC"]);
          const DIRECTION=(process.env.DIRECTION||"both").trim().toLowerCase();
          const MR_BREAKOUT_DC_N=Number(process.env.MR_BREAKOUT_DC_N||"120");
          const MR_BREAKOUT_RET15_ATR=Number(process.env.MR_BREAKOUT_RET15_ATR||"1.5"), MR_LOCKOUT_SEC=Number(process.env.MR_LOCKOUT_SEC||"1800");
          const MAX_COST_BPS_HARD=Number(process.env.MAX_COST_BPS_HARD||"15");
          const MIN_VOL_1H_USD=Number(process.env.MIN_VOL_1H_USD||"5000000"), DEPTH_1P_MIN_USD=Number(process.env.DEPTH_1P_MIN_USD||"200000");
          const NO_LONG_DOWN_ENABLE=(process.env.NO_LONG_DOWN_ENABLE||"true").toLowerCase()==="true";
          const LONG_DOWN_RSI_CUTOFF=Number(process.env.LONG_DOWN_RSI_CUTOFF||"40");
          const LONG_MR_DIVERGENCE_REQ=(process.env.LONG_MR_DIVERGENCE_REQ||"true").toLowerCase()==="true";
          const LONG_EDGE_MULT_MIN=Number(process.env.LONG_EDGE_MULT_MIN||"4");
          const LONG_BOUNCE_SL_ATR=Number(process.env.LONG_BOUNCE_SL_ATR||"0.50"), LONG_BOUNCE_TP_ATR=Number(process.env.LONG_BOUNCE_TP_ATR||"0.90");
          const LONG_SIMILARITY_RHO=Number(process.env.LONG_SIMILARITY_RHO||"0.84");
          const QUOTES = ["USDT", "USDC", "USD"]; const split = (sym) => { for (const q of QUOTES) if (sym.endsWith(q)) return { base: sym.slice(0, -q.length), quote: q }; return null; };
          const TIMEFRAMES = ["1m", "5m", "15m", "1h", "4h"];
          const TF_WEIGHTS = { "1m": 0.1, "5m": 0.4, "15m": 0.3, "1h": 0.15, "4h": 0.05 };
          const TF_CANDLE_LIMITS = { "1m": 300, "5m": 300, "15m": 300, "1h": 100, "4h": 100 };
          const MIN_TF_ALIGN = Number(process.env.MIN_TF_ALIGN || "0.60");
          const RSI_PERIOD = 14, ADX_PERIOD = 14, ROC_SHORT_BARS = 1, ROC_MED_BARS = 3, EMA_FAST=21, EMA_SLOW=50;

          // ---------- Worker endpoints ----------
          const PUSH_URL=process.env.WORKER_PUSH_URL||"", PUSH_TOKEN=process.env.PUSH_TOKEN||"";

          // ---------- MEXC Adapter ----------
          async function pickMexcBase(){ for(const b of MEXC_BASES){ try{ const r=await fetchWithTimeout(`${b}/api/v3/time`,{},4000); if(r?.ok) return b; }catch{} } throw new Error("No healthy MEXC base"); }
          const BASE=await pickMexcBase();
          const api=(path,params={})=>{ const u=new URL(path,BASE); for(const [k,v] of Object.entries(params)){ if(v!==undefined&&v!==null) u.searchParams.set(k,String(v)); } return u.toString(); };
          async function mexcSignedRequest(path, params = {}, method = 'GET') {
              if (!MEXC_API_KEY || !MEXC_SECRET_KEY) return null;
              const timestamp = Date.now();
              const queryString = new URLSearchParams({ ...params, timestamp }).toString();
              const signature = crypto.createHmac('sha256', MEXC_SECRET_KEY).update(queryString).digest('hex');
              const url = new URL(path, BASE); url.search = queryString + `&signature=${signature}`;
              const options = { method, headers: { 'X-MEXC-APIKEY': MEXC_API_KEY, 'Content-Type': 'application/json' } };
              try { const r = await fetchWithTimeout(url.toString(), options, 15000); if (r.ok) return await r.json(); log(`MEXC signed req failed: ${r.status}`, (await r.text()||'').slice(0,100)); return null; } catch (e) { log(`MEXC signed req error: ${e?.message||e}`); return null; }
          }
          async function fetchMyTrades(symbol, startTime) { return await mexcSignedRequest('/api/v3/myTrades', { symbol, startTime, limit: 1000 }); }
          async function fetchOrder(symbol, origClientOrderId) { return await mexcSignedRequest('/api/v3/order', { symbol, origClientOrderId }); }
          async function fetchOpenOrders(symbol) { return await mexcSignedRequest('/api/v3/openOrders', { symbol }); }
          async function fetchK(symbol,interval,limit,startTime,endTime){ const u=api("/api/v3/klines",{symbol,interval,limit,startTime,endTime}); return await getJSON(u,15000,4); }
          const conversionRateCache = new Map();
          async function getConversionRate(fromAsset, toAsset) {
              if (fromAsset === toAsset) return 1.0; const key = `${fromAsset}/${toAsset}`; if (conversionRateCache.has(key)) return conversionRateCache.get(key);
              let rate = null; const directPair = `${fromAsset}${toAsset}`, reversePair = `${toAsset}${fromAsset}`;
              let price = (await getJSON(api("/api/v3/ticker/price",{symbol:directPair}), 5000, 2))?.price;
              if (price) { rate = parseFloat(price); } else { price = (await getJSON(api("/api/v3/ticker/price",{symbol:reversePair}), 5000, 2))?.price; if (price) rate = 1.0 / parseFloat(price); }
              if (rate) conversionRateCache.set(key, rate); else log(`WARN: Could not get conversion rate for ${key}`); return rate;
          }
          async function fetchKlinesMTF(symbol) {
            const allData = {}; const missing = [];
            for (const tf of TIMEFRAMES) {
              await sleep(120);
              const limit = TF_CANDLE_LIMITS[tf]; let k = await fetchK(symbol, tf, limit);
              if (!k || k.length < Math.max(RSI_PERIOD + 1, ADX_PERIOD + 1)) { missing.push(tf); continue; }
              const closes = k.map(x => +x[4]);
              allData[tf] = { ts: k.map(x => +x[0]), highs: k.map(x => +x[2]), lows: k.map(x => +x[3]), closes, volumes: k.map(x => +x[5]), c_kalman: kalman1D(closes, { q: 1e-4, r: 5e-4 }) };
            }
            if (Object.keys(allData).length < 3) return null;
            if (missing.length > 0 && process.env.DEBUG_MTF === "1") log(`MTF missing for ${symbol}: ${missing.join(", ")}`);
            return allData;
          }

          // ---------- State (Gist) ----------
          const MODEL_VERSION = "6.9-mtf-bugfix";
          async function loadState(){ const init={ v:MODEL_VERSION, cooldown:{}, cooldown_side:{}, pending:[], equity:[], closed:[], mr_lockout:{}, sym_stats:{}, calibCoeffs:{}, lastReconcileTs:0, calibration_holdout:[] }; if(!GIST_TOKEN||!GIST_ID) return { state:init, persist:null }; try{ const r=await fetchWithTimeout(`https://api.github.com/gists/${GIST_ID}`,{ headers:{Authorization:`Bearer ${GIST_TOKEN}`,"Accept":"application/vnd.github+json"}}); if(!r.ok) return { state:init, persist:null }; const g=await r.json(); const c=g.files?.["state.json"]?.content; const s=c?JSON.parse(c):init; if(!s.cooldown)s.cooldown={}; if(!s.cooldown_side)s.cooldown_side={}; if(!Array.isArray(s.pending))s.pending=[]; if(!Array.isArray(s.closed))s.closed=[]; if(!s.mr_lockout)s.mr_lockout={}; if(!s.sym_stats)s.sym_stats={}; if(!s.calibCoeffs)s.calibCoeffs={}; if(!s.lastReconcileTs)s.lastReconcileTs=0; if(!s.calibration_holdout)s.calibration_holdout=[]; return { state:s, persist:{id:GIST_ID,token:GIST_TOKEN} }; }catch{ return { state:init, persist:null }; } }
          async function saveState(persist,state){ if(!persist) return; try{ await fetchWithTimeout(`https://api.github.com/gists/${persist.id}`,{ method:"PATCH", headers:{Authorization:`Bearer ${persist.token}`,"Accept":"application/vnd.github+json","Content-Type":"application/json"}, body: JSON.stringify({ files:{ "state.json":{ content: JSON.stringify(state) } } }) }); }catch{} }
          async function reconcileViaAPI(p) { if(!MEXC_API_KEY||!MEXC_SECRET_KEY)return{status:'skipped_no_keys'};let order=null;try{if(p.client_order_id){order=await fetchOrder(p.symbolFull,p.client_order_id);}}catch{}const byOrderId=async(orderId)=>{const trades=await fetchMyTrades(p.symbolFull,(p.ts_ms||Date.now())-6*3600*1000);return(trades||[]).filter(t=>String(t.orderId)===String(orderId));};let entryFills=[],exitFills=[];if(order?.orderId){const fills=await byOrderId(order.orderId);entryFills=fills.filter(t=>(p.side==='long'?t.isBuyer:!t.isBuyer));exitFills=fills.filter(t=>(p.side==='long'? !t.isBuyer:t.isBuyer));}else{const allTrades=await fetchMyTrades(p.symbolFull,p.ts_ms-30000);if(!allTrades?.length)return{status:'no_trades_found'};entryFills=allTrades.filter(t=>t.time>=p.ts_ms-15000&&t.time<p.ts_ms+10*60*1000&&(p.side==='long'?t.isBuyer:!t.isBuyer));if(!entryFills.length)return{status:'entry_not_found'};const firstEntryTime=Math.min(...entryFills.map(t=>t.time));exitFills=allTrades.filter(t=>t.time>firstEntryTime&&(p.side==='long'? !t.isBuyer:t.isBuyer));if(!exitFills.length)return{status:'exit_not_found'};}const aggregateFills=async(fills)=>{let totalQty=0,totalValue=0,totalFeesQuote=0,makerQty=0;for(const fill of fills){const qty=parseFloat(fill.qty),price=parseFloat(fill.price);totalQty+=qty;totalValue+=qty*price;if(fill.commissionAsset===p.quote){totalFeesQuote+=parseFloat(fill.commission);}else{const rate=await getConversionRate(fill.commissionAsset,p.quote||'USDT');if(rate)totalFeesQuote+=parseFloat(fill.commission)*rate;}const isMaker=(fill.isMaker??fill.maker);if(isMaker)makerQty+=qty;}return{vwap:totalQty>0?totalValue/totalQty:0,totalQty,totalFeesQuote,makerRatio:totalQty>0?makerQty/totalQty:0};};const entryAgg=await aggregateFills(entryFills);const exitAgg=await aggregateFills(exitFills);if(entryAgg.totalQty<=0||exitAgg.totalQty<=0)return{status:'zero_qty'};if(Math.abs(entryAgg.totalQty-exitAgg.totalQty)/entryAgg.totalQty>0.05)return{status:'qty_mismatch'};const ret=p.side==='long'?(exitAgg.vwap/entryAgg.vwap-1):(entryAgg.vwap/exitAgg.vwap-1);const fees_bps=(entryAgg.totalFeesQuote+exitAgg.totalFeesQuote)/(entryAgg.vwap*entryAgg.totalQty)*10000;const pnl_bps=Math.round(ret*10000-fees_bps);const ts_entry_ms=Math.min(...entryFills.map(t=>t.time));const ts_exit_ms=Math.max(...exitFills.map(t=>t.time));const closedRec={...p,reconciliation_method:'api',ts_entry_ms,ts_exit_ms,price_entry:entryAgg.vwap,price_exit:exitAgg.vwap,qty:entryAgg.totalQty,pnl_bps,fees_bps:Math.round(fees_bps),hold_time_sec:Math.round((ts_exit_ms-ts_entry_ms)/1000)};return{status:'reconciled',closedRec,fingerprint:getTradeFingerprint(closedRec)};}
          async function reconcileViaCandles(p) { const now=Date.now();const ttl_ts_ms=p.ttl_ts_ms||(p.ts_ms+(p.hold_sec||0)*1000);if(now<ttl_ts_ms+5000)return{status:'still_pending'};const k=await fetchK(p.symbolFull,"1m",1000,p.ts_ms-60*1000,ttl_ts_ms+120*1000);if(!k||k.length<2)return{status:'no_candles'};const ts=k.map(x=>+x[0]),highs=k.map(x=>+x[2]),lows=k.map(x=>+x[3]),closes=k.map(x=>+x[4]);const long=p.side==="long",entry=p.entry_limit,{tp_abs,sl_abs}=p;let iFill=-1;for(let i=0;i<k.length;i++){if(ts[i]>=p.ts_ms-1000&&ts[i]<=ttl_ts_ms&&(long?(lows[i]<=entry):(highs[i]>=entry))){iFill=i;break;}}if(iFill===-1)return{status:'no_fill'};const ts_entry_ms=ts[iFill];let exit_px=closes.at(-1),exit_reason="ttl",ts_exit_ms=ttl_ts_ms;for(let i=iFill;i<k.length;i++){if(ts[i]>ttl_ts_ms)break;if(long?(highs[i]>=tp_abs):(lows[i]<=tp_abs)){exit_px=tp_abs;exit_reason="tp";ts_exit_ms=ts[i];break;}if(long?(lows[i]<=sl_abs):(highs[i]>=sl_abs)){exit_px=sl_abs;exit_reason="sl";ts_exit_ms=ts[i];break;}}const ret=long?(exit_px/entry-1):(entry/exit_px-1),pnl_bps=Math.round(ret*10000)-(p.cost_bps||COST_BPS);const closedRec={...p,reconciliation_method:'candles',ts_entry_ms,ts_exit_ms,price_entry:entry,price_exit:exit_px,exit_reason,pnl_bps,qty:p.notional_usd/entry,hold_time_sec:Math.round((ts_exit_ms-ts_entry_ms)/1000)};return{status:'reconciled',closedRec,fingerprint:getTradeFingerprint(closedRec)};}
          async function evalPending(state) { if (!state.pending?.length) return; const newPending = []; for (const p of state.pending) { const apiResult = await reconcileViaAPI(p); const candleResult = await reconcileViaCandles(p); let isClosed = false, finalRec = null; if (apiResult.status === 'reconciled') { isClosed = true; finalRec = apiResult.closedRec; } else if (candleResult.status === 'reconciled') { isClosed = true; finalRec = candleResult.closedRec; } if (isClosed) { const outcome = finalRec.pnl_bps > 0 ? 1 : 0; updateCalibration(state, p.side, p.regime, p.p_raw, outcome); state.equity.push({ ts_ms: finalRec.ts_exit_ms, pnl_bps: finalRec.pnl_bps }); const sb = state.sym_stats?.[p.base] || { n: 0, wins: 0, pnl_sum: 0 }; sb.n++; if(finalRec.pnl_bps > 0) sb.wins++; sb.pnl_sum += finalRec.pnl_bps; state.sym_stats[p.base] = sb; (state.closed ||= []).push({ ...finalRec, predicted_snapshot: p.predicted }); } else { newPending.push(p); } } state.pending = newPending; if(state.equity.length>6000) state.equity=state.equity.slice(-6000); if(state.closed?.length>5000) state.closed=state.closed.slice(-5000); }
          function getCoeffs(state, side, regime){ const key=`${side}_${regime}`; if(!state.calibCoeffs) state.calibCoeffs={}; if(!state.calibCoeffs[key]) state.calibCoeffs[key]={a:0,b:1,n:0}; return state.calibCoeffs[key]; }
          function updateCalibration(state, side, regime, pRaw, outcome){ if(pRaw==null) return; const coeff=getCoeffs(state,side,regime); const lr=0.05; const z=coeff.a+coeff.b*pRaw; const pHat=sigmoid(z); const err=outcome-pHat; coeff.a += lr*err; coeff.b += lr*err*pRaw; coeff.n++; state.calibCoeffs[`${side}_${regime}`]=coeff; }
          const calibrateP=(state, side, regime, pRaw)=>{ const coeff=getCoeffs(state,side,regime); return sigmoid(coeff.a+coeff.b*pRaw); };
          
          // ---------- Main ----------
          try{
            const { state, persist } = await loadState();
            try{ await evalPending(state); }catch(e){ log("evalPending warn", e?.message||e); }
            
            const equityStats=(eq)=>{ const day=Date.now()-24*3600*1000; let pnl24=0,cum=0,peak=0,dd=0; for(const e of eq||[]){ if(e.ts_ms>=day) pnl24+=e.pnl_bps; cum+=e.pnl_bps; if(cum>peak) peak=cum; dd=Math.min(dd,cum-peak); } return { pnl24_bps:Math.round(pnl24), peak_dd_bps:Math.round(dd) }; };
            const { pnl24_bps, peak_dd_bps } = equityStats(state.equity);
            if ((pnl24_bps<=DD_24H_LIMIT_BPS) || (peak_dd_bps<=DD_PEAK_LIMIT_BPS)) {
              log("DD GATE: pnl24h/peak_dd", pnl24_bps, peak_dd_bps);
              throw new Error("DD Gate Active");
            }

            const booksRaw=await getJSON(api("/api/v3/ticker/bookTicker"),10000,2) || [];
            const bookMap=new Map(booksRaw.map(b=>[b.symbol,{ bid:+b.bidPrice, ask:+b.askPrice }]));
            const all24hr = await getJSON(api("/api/v3/ticker/24hr"),10000,2) || [];
            const all=[]; for(const t of all24hr){ const sq=split(t.symbol); if(sq && !STABLES.has(sq.base) && isFinite(+t.quoteVolume) && +t.quoteVolume>0) all.push({ symbol:t.symbol, base:sq.base, quote:sq.quote, qv:+t.quoteVolume }); }
            all.sort((a,b)=>b.qv-a.qv); let dynMinQV=Math.max(MIN_QV_ENV, DYN_QV_MIN), filt=all.filter(x=>x.qv>=dynMinQV);
            while(filt.length<UNIV_TARGET_MIN && dynMinQV>1_000_000){ dynMinQV=Math.max(1_000_000, dynMinQV-DYN_QV_STEP); filt=all.filter(x=>x.qv>=dynMinQV); }
            const universe=filt.slice(0,UNIV_TARGET_MAX); log("Universe size:", universe.length);
            
            const picksRaw=[]; const BATCH_SIZE = Number(process.env.MTF_BATCH||"4");
            for(let i=0; i<universe.length; i+=BATCH_SIZE){
              const batch=await Promise.all(universe.slice(i,i+BATCH_SIZE).map(async c=>{
                try{
                  if(state.cooldown?.[c.base] && (Date.now()-state.cooldown[c.base])<COOLDOWN_MS) return null;
                  const book=bookMap.get(c.symbol); if(!book?.bid||!book?.ask) return null;
                  const mid=(+book.bid + +book.ask)/2; const spreadBps=Math.round(((book.ask-book.bid)/mid)*10000);
                  if(spreadBps > MAX_SPREAD_BPS) return null;
                  const mtfData = await fetchKlinesMTF(c.symbol); if (!mtfData) return null;
                  const mtfInd = computeMTFIndicators(mtfData, TF_WEIGHTS, RSI_PERIOD, ADX_PERIOD, ROC_SHORT_BARS, ROC_MED_BARS);
                  if (!mtfInd || mtfInd.tfAlign < MIN_TF_ALIGN) return null;
                  const { avgRsi: rsi14, avgAdx: adx5, avgAtrBps: atr_bps, avgRoc5: roc5, avgRoc15: roc15, tfAlign } = mtfInd;
                  if (atr_bps < 4 || atr_bps > 260) return null;
                  const { highs: h5, lows: l5, c_kalman: c5, volumes: v5 } = mtfData['5m'];
                  const last = c5.at(-1); const { atr: atr5m } = computeADX_ATR(h5, l5, c5, ADX_PERIOD) || {};
                  const z_vwap=(last-vwapAnchored(h5,l5,c5,v5,36))/(atr5m||1);
                  const adxF=clamp((adx5 - 16)/14,0,1);
                  const pTrend=clamp(0.5+0.27*(0.6*tanh(roc5/0.003)+0.4*tanh(roc15/0.0065))*adxF*tfAlign,0.32,0.93);
                  const pMR=clamp(0.5+0.23*(0.7*tanh(Math.abs(z_vwap))*Math.sign(-z_vwap)+0.3*(-(rsi14-50)/50))*(1-adxF)*tfAlign,0.35,0.90);
                  const pLong0=clamp(0.45*pTrend+0.55*pMR,0.3,0.97), pShort0=clamp(0.45*(1-pTrend)+0.55*(1-pMR),0.3,0.97);
                  const win=MR_BREAKOUT_DC_N, dcHi=Math.max(...h5.slice(-win)), dcLo=Math.min(...l5.slice(-win));
                  const breakout=(last>dcHi)||(last<dcLo)||(Math.abs((last/(c5.at(-4)||last))-1)>=MR_BREAKOUT_RET15_ATR*(atr5m/last));
                  if(breakout) state.mr_lockout[c.symbol]=Date.now()+MR_LOCKOUT_SEC*1000;
                  const mrLocked=(Date.now()<(state.mr_lockout?.[c.symbol]||0));
                  return{c, mtfData, vol1h_est_usd:c.qv/24, spreadBps, pLong0, pShort0, mrLocked, rsi14, adx5, atr_bps, tfAlign};
                } catch { return null; } 
              }));
              for(const x of batch) if(x) picksRaw.push(x);
              await sleep(5000);
            }
            
            const refined=[];
            const prelim=picksRaw.map(p=>({p,score:Math.max(p.pLong0,p.pShort0)})).sort((a,b)=>b.score-a.score).slice(0,30).map(x=>x.p);
            const kBTC1H=await fetchK("BTCUSDT","1h",300); const btcUp1h = (()=>{if(!kBTC1H?.length)return false;const c=kBTC1H.map(x=>+x[4]);return c.at(-1)>=ema(c,EMA_FAST)&&c.at(-1)>=ema(c,EMA_SLOW);})();
            for(const p of prelim){ try{ const c=p.c; const book=bookMap.get(c.symbol); if(!book?.bid||!book?.ask)continue; const mid=(+book.bid+ +book.ask)/2; const depth=await getJSON(api("/api/v3/depth",{symbol:c.symbol,limit:DEPTH_LIMIT})); if(!depth?.bids?.length)continue; const d1Ask=vwapFillLevels(depth.asks, mid*0.01*NOTIONAL).filledUSD, d1Bid=vwapFillLevels(depth.bids, mid*0.01*NOTIONAL).filledUSD;const depth1pUSD=d1Ask+d1Bid; const regime=p.mrLocked?"trend":"meanrevert"; const pLong=calibrateP(state,"long",regime,p.pLong0), pShort=calibrateP(state,"short",regime,p.pShort0); const pLong_lcb=wilsonLCB(pLong,80,WILSON_Z), pShort_lcb=wilsonLCB(pShort,80,WILSON_Z); let candLong=null,candShort=null; const slipL=slipFromDepth(depth,mid,"long",NOTIONAL).slip_bps||0, costLong=COST_BPS+slipL; const slipS=slipFromDepth(depth,mid,"short",NOTIONAL).slip_bps||0, costShort=COST_BPS+slipS; if(DIRECTION!=="short"){let tp=Math.round(LONG_BOUNCE_TP_ATR*p.atr_bps),sl=Math.round(LONG_BOUNCE_SL_ATR*p.atr_bps);sl=Math.min(sl,80);tp=Math.max(tp,Math.round(sl*1.5));const evLCB=Math.round(pLong_lcb*tp-(1-pLong_lcb)*sl-costLong);if(tp>=LONG_EDGE_MULT_MIN*costLong&&evLCB>=EXP_LCB_MIN_BPS_BASE){candLong={side:"long",p_lcb:pLong_lcb,p_raw:p.pLong0,exp_lcb_bps:evLCB,tp_bps:tp,sl_bps:sl,cost_bps:costLong,slip_est:slipL};}}if(DIRECTION!=="long"){let tp=Math.round(p.atr_bps*1.0),sl=Math.round(p.atr_bps*0.5);sl=Math.min(sl,80);tp=Math.max(tp,Math.round(sl*1.5));const evLCB=Math.round(pShort_lcb*tp-(1-pShort_lcb)*sl-costShort);if(tp>=4*costShort&&evLCB>=EXP_LCB_MIN_BPS_BASE){candShort={side:"short",p_lcb:pShort_lcb,p_raw:p.pShort0,exp_lcb_bps:evLCB,tp_bps:tp,sl_bps:sl,cost_bps:costShort,slip_est:slipS};}}const chosen=candLong&&candShort?(candLong.exp_lcb_bps>=candShort.exp_lcb_bps?candLong:candShort):(candLong||candShort||null);if(!chosen)continue;const conf=confidenceScore({p_cal:chosen.p_lcb,ev_bps:chosen.exp_lcb_bps,atr_bps:p.atr_bps,micro:p.tfAlign});refined.push({...chosen,symbol:c.symbol,base:c.base,confidence:conf,p,entry_mid:mid,depth1pUSD});}catch(e){log("refine warn",e?.message||e);}}
            
            const picks=refined.sort((a,b)=>b.confidence-a.confidence).slice(0,TOP_N).map((x,i)=>{
                const p=x.p,idea_id=crypto.randomBytes(16).toString("hex"),decisionTs=Date.now(),mid=x.entry_mid;
                let entry_limit=null,tp_abs=null,sl_abs=null; if(mid){const slF=x.sl_bps/10000,tpF=x.tp_bps/10000;if(x.side==="long"){entry_limit=mid*(1-0.0002);tp_abs=entry_limit*(1+tpF);sl_abs=entry_limit*(1-slF);}else{entry_limit=mid*(1+0.0002);tp_abs=entry_limit*(1-tpF);sl_abs=entry_limit*(1+slF);}}
                const c5=p.mtfData?.['5m']?.c_kalman||[];const ema21_5m=ema(c5,21)||0,ema50_5m=ema(c5,50)||0,slope_bps_5m=slopeBps(c5);const trend_dir_5m=(ema21_5m>ema50_5m&&p.adx5>20)?"up":(ema21_5m<ema50_5m&&p.adx5>20)?"down":"flat";const trend5m={tf:"5m",dir:trend_dir_5m,adx:+(p.adx5).toFixed(1),slope_bps:slope_bps_5m};
                const predicted={ts_ms:decisionTs,side:x.side,p_raw:x.p_raw,p_cal:x.p_lcb,ev_bps:x.exp_lcb_bps,confidence_score:x.confidence,micro:{spread_bps:p.spreadBps,slip_bps_est:x.slip_est},trend5m,regime:{tf_align:p.tfAlign},gates:{spread_bps:p.spreadBps,cost_bps:x.cost_bps,vol1h_usd:p.vol1h_est_usd,depth1p_usd:x.depth1pUSD,mr_locked:p.mrLocked,btc_gate:btcUp1h}};
                return {idea_id,client_order_id:idea_id,decision_ts_ms:decisionTs,symbol:x.base,symbol_full:x.symbol,side:x.side,p_lcb:x.p_lcb,p_raw:x.p_raw,calib_key:`${x.side}_${p.mrLocked?"trend":"meanrevert"}`,tp_bps:x.tp_bps,sl_bps:x.sl_bps,cost_bps:x.cost_bps,entry_mid:mid,entry_limit,tp_abs,sl_abs,size_bps:x.sl_bps>0?Math.min(220,Math.round((softmax(refined.slice(0,TOP_N).map(r=>r.exp_lcb_bps),20)[i]*TARGET_PORT_RISK_BPS/x.sl_bps)*100)):0,predicted,confidence:x.confidence,ttl_sec:TTL_MIN};
            });
            
            try{
              const nowMs=Date.now();
              for(const p of picks){ state.cooldown[p.symbol]=nowMs; const parts=split(p.symbol_full); state.pending.push({ idea_id: p.idea_id, client_order_id: p.client_order_id, decision_ts_ms: p.decision_ts_ms, ts_ms:nowMs, ttl_ts_ms:nowMs+p.ttl_sec*1000, symbolFull:p.symbol_full,base:p.symbol, quote: parts?.quote||"USDT", side:p.side, entry_mid:p.entry_mid, entry_limit:p.entry_limit,tp_abs:p.tp_abs,sl_abs:p.sl_abs, p_lcb:p.p_lcb,p_raw:p.p_raw,calib_key:p.calib_key,regime:p.predicted.regime.tf_align>0.7?"trend":"meanrevert", predicted:p.predicted, notional_usd:NOTIONAL, cost_bps:p.cost_bps }); }
              if(state.pending.length>550) state.pending=state.pending.slice(-550);
              await saveState(persist,state);
            }catch(e){ log("state save warn",e?.message||e); }

            const meta={exchange:"mexc",exchange_base:BASE,counts:{universe:universe.length,refined:refined.length,selected:picks.length},dd_gate:{pnl24_bps,peak_dd_bps,throttle:false},tod:{active:todOK,start:S_H,end:E_H}};
            const payload={ts:new Date().toISOString(),mode:"normal",source:"external_pusher",meta:{origin:"github_actions",reason:"ok",...meta},top_n:picks.length||0,ideas:picks||[]};
            log(`pushing ${picks.length} ideas to ${PUSH_URL}`);
            const r=await fetchWithTimeout(PUSH_URL,{method:"POST",headers:{"Content-Type":"application/json","Authorization":"Bearer "+PUSH_TOKEN},body:JSON.stringify(payload)},15000);
            log("push status",r?.status||"ERR",(await r.text()||"").slice(0,400));

          }catch(e){
            const payload={ts:new Date().toISOString(),mode:"normal",source:"external_pusher",meta:{origin:"github_actions",reason:"error",error:String(e?.message||e)},top_n:0,ideas:[]};
            log("pushing 0 ideas due to error:", e?.message||e);
            if(PUSH_URL && PUSH_TOKEN) await fetchWithTimeout(PUSH_URL,{method:"POST",headers:{"Content-Type":"application/json","Authorization":"Bearer "+PUSH_TOKEN},body:JSON.stringify(payload)},12000);
          }
          })();
          NODE
          EXIT_CODE=$?

          # Shell-level fallback (in case node crashed before posting)
          set -e
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo "[gha] pusher exited with code $EXIT_CODE — sending minimal payload so tail shows a [push] line"

            # Sanitize and derive URLs
            raw_push_url="$(printf '%s' "${WORKER_PUSH_URL}" | tr -d '\r\n')"
            health_url="$(printf '%s' "${raw_push_url}" | sed -E 's#/signals/push(\?.*)?$#/health#')"

            # 1) Fallback health GET (guaranteed Worker hit)
            echo "[gha] fallback health GET ${health_url}"
            http_code_h=$(curl -g -sS -o /dev/null -w "%{http_code}" \
              -H "Authorization: Bearer ${PUSH_TOKEN}" \
              --max-time 8 \
              "${health_url}" || true)
            echo "[gha] fallback health status ${http_code_h}"

            # 2) Minimal POST with 0 ideas
            now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            payload='{"ts":"'"${now}"'","mode":"normal","source":"external_pusher","meta":{"origin":"github_actions","reason":"fallback_node_error"},"top_n":0,"ideas":[]}'
            echo "[gha] pushing 0 ideas to ${raw_push_url}"
            mkdir -p /tmp
            : > /tmp/push_resp.txt
            http_code=$(curl -g -sS -o /tmp/push_resp.txt -w "%{http_code}" -X POST \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer ${PUSH_TOKEN}" \
              --data-raw "${payload}" \
              --max-time 12 \
              "${raw_push_url}" || true)
            body="$(head -c 400 /tmp/push_resp.txt || true)"
            echo "[gha] push status ${http_code} ${body}"
            exit 0
          fi
