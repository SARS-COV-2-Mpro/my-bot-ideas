name: Ideas Pusher (MEXC strict→fallback 1–3, adaptive SL + flexible EV)

on:
  workflow_dispatch:
  schedule:
    - cron: "*/20 * * * *" # every 20 minutes

permissions:
  contents: read

concurrency:
  group: ideas-mexc
  cancel-in-progress: true

jobs:
  push:
    runs-on: ubuntu-latest
    timeout-minutes: 12

    env:
      # Required secrets only
      WORKER_PUSH_URL: ${{ secrets.WORKER_PUSH_URL }}
      PUSH_TOKEN: ${{ secrets.PUSH_TOKEN }}
      # Optional (not required to run)
      GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
      GIST_ID: ${{ secrets.GIST_ID }}
      # Optional env for worker (defaults to "paper" in code if not set)
      # SIGNAL_ENV: ${{ vars.SIGNAL_ENV }}

    steps:
      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Run pusher (2.1 strict → fallback always 1–3)
        shell: bash
        run: |
          set -euo pipefail

          if [[ -z "${WORKER_PUSH_URL:-}" || -z "${PUSH_TOKEN:-}" ]]; then
            echo "[gha] Missing WORKER_PUSH_URL or PUSH_TOKEN"
            exit 1
          fi

          set +e
          node - <<'NODE'
          (async ()=>{
            'use strict';

            // ---------------- Utils ----------------
            const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
            const sigmoid=(x)=>1/(1+Math.exp(-x));
            const ema=(arr,p)=>{ if(arr.length<p) return null; const k=2/(p+1); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; for(let i=p;i<arr.length;i++) e=arr[i]*k+e*(1-k); return e; };
            const rsi=(cl,p=14)=>{ if(cl.length<=p) return null; let g=0,l=0; for(let i=1;i<=p;i++){ const d=cl[i]-cl[i-1]; g+=Math.max(d,0); l+=Math.max(-d,0); } let ag=g/p, al=l/p; for(let i=p+1;i<cl.length;i++){ const d=cl[i]-cl[i-1]; ag=(ag*(p-1)+Math.max(d,0))/p; al=(al*(p-1)+Math.max(-d,0))/p; } const rs=al===0?100:ag/al; return 100-100/(1+rs); };
            const std=(x)=>{ const n=x.length; if(n<=1) return 0; const m=x.reduce((a,b)=>a+b,0)/n; let v=0; for(const xi of x) v+=(xi-m)*(xi-m); return Math.sqrt(v/(n-1)); };
            const quantile=(arr,q)=>{ if(!arr?.length) return null; const a=arr.slice().sort((x,y)=>x-y); const pos=(a.length-1)*q; const lo=Math.floor(pos), hi=Math.ceil(pos); if(lo===hi) return a[lo]; const h=pos-lo; return a[lo]*(1-h)+a[hi]*h; };
            const corr=(a,b)=>{ const n=Math.min(a?.length||0,b?.length||0); if(n<5) return 0; const as=a.slice(-n), bs=b.slice(-n); const ma=as.reduce((x,y)=>x+y,0)/n, mb=bs.reduce((x,y)=>x+y,0)/n; let num=0,da=0,db=0; for(let i=0;i<n;i++){ const xa=as[i]-ma, xb=bs[i]-mb; num+=xa*xb; da+=xa*xa; db+=xb*xb; } const den=Math.sqrt(da*db); return den===0?0:num/den; };
            const wilsonLCB=(p,n,z=1.34)=>{ if(n<=0) return p; const z2=z*z; const a=p + z2/(2*n); const b=z*Math.sqrt((p*(1-p)+z2/(4*n))/n); const c=1+z2/n; return clamp((a-b)/c, 0, 1); };
            const log=(...a)=>console.log("[gha]",...a);

            // ---------------- Net ----------------
            const UA="gh-actions-ideas-mexc-strict-fallback/1.2 (+https://github.com/)";
            async function fetchWithTimeout(url,opts={},ms=12000){
              const ac=new AbortController(); const t=setTimeout(()=>ac.abort(),ms);
              try{ return await fetch(url,{...opts,signal:ac.signal,headers:{ "User-Agent":UA, ...(opts.headers||{}) }}); }
              finally{ clearTimeout(t); }
            }
            async function getJSON(url,ms=12000,tries=2){
              for(let i=0;i<tries;i++){
                try{ const r=await fetchWithTimeout(url,{},ms); if(r?.ok) return await r.json(); }catch{}
                await new Promise(r=>setTimeout(r,220+Math.random()*120));
              }
              return null;
            }

            // ---------------- Config (no repo vars required) ----------------
            const PUSH_URL = process.env.WORKER_PUSH_URL;
            const PUSH_TOKEN= process.env.PUSH_TOKEN;
            const ENV_NAME = process.env.SIGNAL_ENV || process.env.PUSH_ENV || process.env.NODE_ENV || "paper"; // worker env gate helper
            const IS_MANUAL = (process.env.GITHUB_EVENT_NAME||"").toLowerCase()==="workflow_dispatch";

            // Exchange
            const MEXC_BASES=["https://api.mexc.com","https://www.mexc.com"];

            // Strict defaults (relaxed for larger universe)
            const MIN_QV = 5_000_000;           // was 30_000_000
            const MAX_SPREAD_BPS = 18;          // was 12

            // Fallback goals
            const MIN_IDEAS = 1;
            const MAX_IDEAS_TARGET = 3;

            // Selection sizes (strict)
            const TOP_N = 10;
            const EXTRA_IDEAS_MAX = 3;

            // Slip/fill modeling size
            const SIGNAL_NOTIONAL = 300;

            // Depth/OBI
            const DEPTH_LIMIT = 50;
            const OBI_TOPN = 12;

            // Universe sizing
            const UNIVERSE_MIN = 100;
            const UNIVERSE_MAX = 400;

            // ToD off; manual ignores gates
            const S_H=null, E_H=null;
            const nowH = new Date().getUTCHours();
            const todOK = (S_H==null || E_H==null) ? true : (S_H<=E_H ? (nowH>=S_H && nowH<=E_H) : (nowH>=S_H || nowH<=E_H));
            const TOD_OK = IS_MANUAL ? true : todOK;

            // Cooldown / DD
            const COOLDOWN_MS = 3*60*60*1000;
            const DD_24H_LIMIT_BPS=-150, DD_PEAK_LIMIT_BPS=-300;
            const WILSON_Z=1.34;

            // ATR targets (raised SL bounds)
            const TP_ATR_MIN=0.40, TP_ATR_MAX=2.10;
            const SL_ATR_MIN=0.35, SL_ATR_MAX=1.70;   // raised
            const TP_TREND_BASE=1.12, SL_TREND_BASE=0.62; // raised base SL
            const TP_MR_BASE=0.62,  SL_MR_BASE=0.60;
            const TP_BO_BASE=1.30,  SL_BO_BASE=0.60;

            // Windows
            const EMA_FAST=21, EMA_SLOW=50, ADX_P=14;
            const K1M=240, K5M=120, K15M=96, K1H=96;
            const VWAP_5M_WIN=36;

            const STABLES=new Set(["USDT","USDC","USD","BUSD","FDUSD","TUSD","DAI","USDP","PAX","USTC","USDE","USDD"]);

            // ---------------- Health + heartbeat ----------------
            const HEALTH_URL=(()=>{ try{ const u=new URL(PUSH_URL); return `${u.origin}${u.pathname.replace(/\/signals\/push(\?.*)?$/,"/health")}`;}catch{return PUSH_URL.replace(/\/signals\/push(\?.*)?$/,"/health");}})();
            try{
              const r=await fetchWithTimeout(HEALTH_URL,{ headers:{ "Authorization":`Bearer ${PUSH_TOKEN}` }},5000);
              let t=""; try{ t=await r.text(); }catch{}; log("health status", r?.status||"ERR", (t||"").slice(0,160));
            }catch(e){ log("health error", e?.message||e); }

            async function heartbeat(){
              const payload={ ts:new Date().toISOString(), mode:"normal", env:ENV_NAME, source:"external_pusher",
                meta:{ origin:"github_actions", reason:"heartbeat", env:ENV_NAME }, top_n:0, ideas:[] };
              try{
                console.log(`[gha] heartbeat pushing 0 ideas to ${PUSH_URL}`);
                const r=await fetchWithTimeout(PUSH_URL,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":`Bearer ${PUSH_TOKEN}` }, body: JSON.stringify(payload) },10000);
                let txt=""; try{ txt=await r.text(); }catch{}; console.log(`[gha] heartbeat push status ${r?.status||"ERR"} ${(txt||"").slice(0,200)}`);
              }catch(e){ console.log("[gha] heartbeat push failed", e?.message||e); }
            }
            await heartbeat();

            // ---------------- MEXC base + API ----------------
            async function fetchMexcBase(){
              for(const b of MEXC_BASES){ try{ const r=await fetchWithTimeout(`${b}/api/v3/time`,{},4000); if(r?.ok) return b; }catch{} }
              throw new Error("No healthy MEXC base");
            }
            const BASE = await fetchMexcBase();
            const api=(path,params={})=>{ const u=new URL(path,BASE); for(const [k,v] of Object.entries(params)){ if(v!==undefined&&v!==null) u.searchParams.set(k,String(v)); } return u.toString(); };
            async function fetchK(sym,interval,limit,startTime,endTime){
              const u=api("/api/v3/klines",{symbol:sym,interval,limit,startTime,endTime});
              const r=await getJSON(u,10000,2); return Array.isArray(r)?r:null;
            }
            async function fetchDepth(symbol){ return await getJSON(api("/api/v3/depth",{symbol,limit:DEPTH_LIMIT}), 10000, 2); }
            async function fetchAll24hr(){
              let all = await getJSON(api("/api/v3/ticker/24hr"), 10000, 2);
              if(Array.isArray(all) && all.length) return all;
              const exi=await getJSON(api("/api/v3/exchangeInfo"), 10000, 2);
              const syms=(exi?.symbols||[]).filter(s=>s.status==="TRADING").map(s=>s.symbol).slice(0,180);
              const out=[];
              for(let i=0;i<syms.length;i+=24){
                const chunk=syms.slice(i,i+24);
                const got=await Promise.all(chunk.map(s=>getJSON(api("/api/v3/ticker/24hr",{symbol:s}),6000,1)));
                for(const x of got) if(x) out.push(x);
                await new Promise(r=>setTimeout(r,180));
              }
              return out;
            }

            // ---------------- Gist (optional) ----------------
            async function loadState(){
              const token=process.env.GIST_TOKEN, id=process.env.GIST_ID;
              const init={ v:"strict-fb-1-3-sl-ev", cooldown:{}, pending:[], equity:[], recentBases:[], lastMegaIdx:0 };
              if(!token||!id) return { state:init, persist:null };
              try{
                const r=await fetchWithTimeout(`https://api.github.com/gists/${id}`,{ headers:{Authorization:`Bearer ${token}`,"Accept":"application/vnd.github+json","User-Agent":UA}});
                if(!r.ok) return { state:init, persist:null };
                const g=await r.json(); const c=g.files?.["state.json"]?.content;
                const s=c?JSON.parse(c):init;
                // Backfill new fields if missing
                if(!Array.isArray(s.recentBases)) s.recentBases=[];
                if(typeof s.lastMegaIdx!=="number") s.lastMegaIdx=0;
                return { state:s, persist:{id,token} };
              }catch{ return { state:init, persist:null }; }
            }
            async function saveState(persist,state){
              if(!persist) return;
              try{
                await fetchWithTimeout(`https://api.github.com/gists/${persist.id}`,{ method:"PATCH",
                  headers:{Authorization:`Bearer ${persist.token}`,"Accept":"application/vnd.github+json","Content-Type":"application/json","User-Agent":UA},
                  body: JSON.stringify({ files:{ "state.json":{ content: JSON.stringify(state) } } })
                });
              }catch{}
            }
            async function evalPending(state){
              const now=Date.now(); const keep=[];
              for(const p of state.pending||[]){
                if(now < p.ts_ms + p.hold_sec*1000 + 5000){ keep.push(p); continue; }
                const k = await fetchK(p.symbolFull,"1m",K1M, p.ts_ms-60*1000, p.ts_ms+p.hold_sec*1000+60*1000);
                if(!k){ keep.push(p); continue; }
                const highs=k.map(x=>+x[2]), lows=k.map(x=>+x[3]), closes=k.map(x=>+x[4]);
                const entry=p.entry_price, long=p.side==="long", tp=p.tp_bps/10000, sl=p.sl_bps/10000;
                let exitPx=closes.at(-1);
                for(let i=0;i<k.length;i++){
                  const hi=highs[i], lo=lows[i];
                  if(long){ if(hi>=entry*(1+tp)){ exitPx=entry*(1+tp); break; } if(lo<=entry*(1-sl)){ exitPx=entry*(1-sl); break; } }
                  else    { if(lo<=entry*(1-tp)){ exitPx=entry*(1-tp); break; } if(hi>=entry*(1+sl)){ exitPx=entry*(1+sl); break; } }
                }
                const ret = long? (exitPx/entry - 1) : (entry/exitPx - 1);
                const pnl_bps = Math.round(ret*10000) - (p.cost_bps||0);
                state.equity.push({ ts_ms:p.ts_ms, pnl_bps });
              }
              state.pending = keep;
              if(state.equity.length>6000) state.equity = state.equity.slice(-6000);
            }
            const equityStats=(eq)=>{ const day=Date.now()-24*3600*1000; let pnl24=0,cum=0,peak=0,dd=0;
              for(const e of eq){ if(e.ts_ms>=day) pnl24+=e.pnl_bps; cum+=e.pnl_bps; if(cum>peak) peak=cum; dd=Math.min(dd,cum-peak); }
              return { pnl24_bps:Math.round(pnl24), peak_dd_bps:Math.round(dd) };
            };

            // ---------------- Indicators ----------------
            function computeADX_ATR(h,l,c,p=14){
              const n=c.length; if(n<p+2) return null; const TR=[],plusDM=[],minusDM=[];
              for(let i=1;i<n;i++){ const up=h[i]-h[i-1], down=l[i-1]-l[i]; plusDM.push((up>down&&up>0)?up:0); minusDM.push((down>up&&down>0)?down:0);
                TR.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1]))); }
              let trN=0,pdmN=0,ndmN=0; for(let i=0;i<p;i++){ trN+=TR[i]; pdmN+=plusDM[i]; ndmN+=minusDM[i]; }
              let pDI=100*(pdmN/(trN||1)), nDI=100*(ndmN/(trN||1)); let dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1), adx=dx;
              for(let i=p;i<TR.length;i++){ trN=trN-(trN/p)+TR[i]; pdmN=pdmN-(pdmN/p)+plusDM[i]; ndmN=ndmN-(ndmN/p)+minusDM[i];
                pDI=100*(pdmN/(trN||1)); nDI=100*(ndmN/(trN||1)); dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1); adx=((adx*(p-1))+dx)/p; }
              const atr=trN/p; return { adx, atr };
            }
            const vwapAnchored=(h,l,c,v,win)=>{ const n=c.length,s=Math.max(0,n-win); let pv=0,vv=0; for(let i=s;i<n;i++){ const tp=(h[i]+l[i]+c[i])/3; const vol=+v[i]||0; pv+=tp*vol; vv+=vol; } return vv>0?pv/vv:c.at(-1); };

            // ---------------- Main ----------------
            let reason="ok"; let selectedFinal=[], forcedMode=false;

            try{
              if(!TOD_OK) { reason="tod_gate"; throw new Error("time-of-day gate"); }

              const { state, persist } = await loadState();
              try{ await evalPending(state); }catch{}
              const { pnl24_bps, peak_dd_bps } = equityStats(state.equity);
              const throttle = (pnl24_bps<=DD_24H_LIMIT_BPS) || (peak_dd_bps<=DD_PEAK_LIMIT_BPS);

              const ALL24 = await getJSON(api("/api/v3/ticker/24hr"), 10000, 2) || await fetchAll24hr();
              const booksRaw=await getJSON(api("/api/v3/ticker/bookTicker"),10000,2) || [];
              const bookMap=new Map(booksRaw.map(b=>[b.symbol,{ bid:+b.bidPrice, ask:+b.askPrice }]));

              const QUOTES=["USDT","USDC","USD"];
              const split=(sym)=>{ for(const q of QUOTES){ if(sym.endsWith(q)) return { base: sym.slice(0,-q.length), quote:q }; } return null; };
              const all=[];
              for(const t of ALL24||[]){
                const sym=t.symbol||t.s; if(!sym) continue; const sq=split(sym); if(!sq) continue;
                const base=sq.base; if(["USDT","USDC","USD","BUSD","FDUSD","TUSD","DAI","USDP","PAX","USTC","USDE","USDD"].includes(base.toUpperCase())) continue;
                const qv=+(t.quoteVolume||t.q||0); if(!(qv>0)) continue;
                all.push({ symbol:sym, base, quote:sq.quote, qv });
              }
              all.sort((a,b)=>b.qv-a.qv);

              // Universe with dynamic relaxation to ensure >= UNIVERSE_MIN
              let universe = all.filter(x=>x.qv>=MIN_QV).slice(0,UNIVERSE_MAX);
              if(universe.length < UNIVERSE_MIN){
                universe = all.slice(0, Math.min(UNIVERSE_MAX, all.length));
                reason = reason==="ok" ? "universe_relaxed" : reason;
              }
              console.log(`[gha] universe: ${universe.length}`);
              if(!universe.length) { reason="no_universe"; throw new Error("no liquid symbols"); }

              const BTC="BTCUSDT", ETH="ETHUSDT";
              const kBTC15=await fetchK(BTC,"15m",K15M), kETH15=await fetchK(ETH,"15m",K15M);
              const kBTC1H=await fetchK(BTC,"1h",K1H), kETH1H=await fetchK(ETH,"1h",K1H);
              const regime=(()=>{
                const f=(k)=>{ if(!k||k.length<ADX_P+5) return null; const h=k.map(x=>+x[2]), l=k.map(x=>+x[3]), c=k.map(x=>+x[4]); const { adx }=computeADX_ATR(h,l,c,ADX_P)||{}; const roc=((c.at(-1)/c.at(-5))-1); return { adx:adx||0, roc }; };
                const b=f(kBTC15)||{adx:0,roc:0}, e=f(kETH15)||{adx:0,roc:0}, b1=f(kBTC1H)||{roc:0}, e1=f(kETH1H)||{roc:0};
                const adxAvg=(b.adx+e.adx)/2; const dir=Math.sign((b.roc+e.roc)+(b1.roc+e1.roc));
                const isTrend=adxAvg>=22 && Math.abs(b.roc)>0.001 && Math.abs(e.roc)>0.001;
                return { regime: isTrend?"trend":"meanrevert", adxAvg, dir };
              })();
              log("regime", regime.regime, "adxAvg", regime.adxAvg?.toFixed?.(1)||"");

              const liqPct=new Map(); for(let i=0;i<universe.length;i++){ liqPct.set(universe[i].symbol,(universe.length===1)?1:1 - i/(universe.length-1)); }

              // -------- Prefilter (strict) --------
              const pre=[]; const B=18; // was 8
              for(let i=0;i<universe.length;i+=B){
                const part=await Promise.all(universe.slice(i,i+B).map(async c=>{
                  try{
                    const lastTs=state.cooldown?.[c.base]; const now=Date.now();
                    if(lastTs && (now-lastTs) < COOLDOWN_MS) return null;

                    const bk=bookMap.get(c.symbol); if(!bk?.bid||!bk?.ask) return null;
                    const mid=(bk.bid+bk.ask)/2; if(!(mid>0)) return null;
                    const spreadBps=Math.round(((bk.ask-bk.bid)/mid)*10000);
                    if(spreadBps>MAX_SPREAD_BPS) return null;

                    const k5 = await fetchK(c.symbol,"5m",K5M); if(!k5||k5.length<Math.max(EMA_SLOW+10,ADX_P+10)) return null;
                    const k15= await fetchK(c.symbol,"15m",K15M); if(!k15) return null;
                    const k1h= await fetchK(c.symbol,"1h",K1H); if(!k1h) return null;

                    const h5=k5.map(x=>+x[2]), l5=k5.map(x=>+x[3]), c5=k5.map(x=>+x[4]), v5=k5.map(x=>+x[5]);
                    const c15=k15.map(x=>+x[4]), h15=k15.map(x=>+x[2]), l15=k15.map(x=>+x[3]);
                    const c1h=k1h.map(x=>+x[4]);

                    const em21_5=ema(c5,EMA_FAST), em50_5=ema(c5,EMA_SLOW);
                    const em21_15=ema(c15,EMA_FAST), em50_15=ema(c15,EMA_SLOW);
                    const { adx:adx5, atr:atr5 } = computeADX_ATR(h5,l5,c5,ADX_P)||{}; if(!(adx5&&atr5)) return null;
                    const atr_bps=Math.round((atr5/(c5.at(-1)||1))*10000); if(atr_bps<4||atr_bps>260) return null;

                    const roc5=(c5.at(-1)/c5.at(-2)-1), roc15=(c15.at(-1)/c15.at(-4)-1), roc1h=(c1h.at(-1)/c1h.at(-2)-1);
                    const vwap5=vwapAnchored(h5,l5,c5,v5,VWAP_5M_WIN);
                    const z_vwap=(c5.at(-1)-vwap5)/(atr5||1);

                    // Squeeze proxy
                    const slice=c5.slice(-20); const bbWidth= 2*std(slice)/(c5.at(-1)||1);
                    const kelWidth= (atr5/(c5.at(-1)||1))*2;
                    const squeezeRatio = kelWidth>0? bbWidth/kelWidth : 1;

                    // 15m Donchian(10) levels (for structure floor later)
                    let donchHigh10=null, donchLow10=null;
                    if(h15.length>=10 && l15.length>=10){
                      donchHigh10=Math.max(...h15.slice(-10));
                      donchLow10=Math.min(...l15.slice(-10));
                    }

                    const trendAlign5=(c5.at(-1)>em21_5 && em21_5>em50_5) ? 1 : (c5.at(-1)<em21_5 && em21_5<em50_5) ? -1 : 0;
                    const trendAlign15=(c15.at(-1)>em21_15 && em21_15>em50_15)?1:(c15.at(-1)<em21_15 && em21_15<em50_15)?-1:0;
                    const sTrend = 0.5*trendAlign5 + 0.35*trendAlign15 + 0.15*Math.sign(roc1h);
                    const p_up_trend = sigmoid(1.2*sTrend + 0.03*(adx5-20) + 0.35*Math.sign(regime.dir));

                    const sMR = -Math.tanh(z_vwap)*0.9 + (1-clamp((adx5-16)/14,0,1))*0.3 + (1/Math.max(0.5,squeezeRatio))*0.1;
                    const p_up_mr = sigmoid(sMR);

                    const boBase = Math.sign(0.6*roc5+0.4*roc15) * (0.6+0.4*clamp((adx5-16)/14,0,1)) * (1+0.3*clamp((1.15 - squeezeRatio)/0.45,0,1));
                    const p_up_bo = sigmoid(0.9*boBase);

                    const regVec = [(regime.regime==="trend"?1.0:0.6),(regime.regime==="trend"?0.6:1.0),0.8];
                    const eReg=regVec.map(x=>Math.exp(x)); const sReg=eReg.reduce((a,b)=>a+b,0)||1; const wT=eReg[0]/sReg, wM=eReg[1]/sReg, wB=eReg[2]/sReg;

                    const pLong0=clamp(wT*p_up_trend + wM*p_up_mr + wB*p_up_bo, 0.05, 0.95);
                    const pShort0=clamp(wT*(1-p_up_trend) + wM*(1-p_up_mr) + wB*(1-p_up_bo), 0.05, 0.95);

                    const styleLong = trendAlign5>0||trendAlign15>0?"trend": "mr";
                    const styleShort= trendAlign5<0||trendAlign15<0?"trend": "mr";

                    return { c, spreadBps, atr_bps, adx5, pLong0, pShort0, styleLong, styleShort, z_vwap, squeezeRatio, c5, donchLow10, donchHigh10 };
                  }catch{ return null; }
                }));
                for(const x of part) if(x) pre.push(x);
              }
              console.log(`[gha] pre candidates: ${pre.length}`);

              // -------- Refine with depth (strict + adaptive SL + flexible EV) --------
              pre.sort((a,b)=> Math.max(b.pLong0,b.pShort0) - Math.max(a.pLong0,a.pShort0));
              const REFINE_M = Math.min(180, pre.length); // was 96
              const refined=[];
              for(let i=0;i<REFINE_M;i++){
                const p=pre[i]; const c=p.c;
                const bk=bookMap.get(c.symbol); if(!bk?.bid||!bk?.ask) continue;
                const mid=(bk.bid+bk.ask)/2;
                const last=p.c5.at(-1)||mid;

                const depth=await fetchDepth(c.symbol);
                let obi=0, slipL=p.spreadBps/2, slipS=p.spreadBps/2, fillL=0, fillS=0;
                if(depth?.asks?.length && depth?.bids?.length){
                  const w=(i)=>Math.exp(-i*0.18);
                  let bidNot=0, askNot=0;
                  for(let j=0;j<Math.min(OBI_TOPN, depth.bids.length); j++){ const pr=+depth.bids[j][0], q=+depth.bids[j][1]; if(pr>0&&q>0) bidNot+=pr*q*w(j); }
                  for(let j=0;j<Math.min(OBI_TOPN, depth.asks.length); j++){ const pr=+depth.asks[j][0], q=+depth.asks[j][1]; if(pr>0&&q>0) askNot+=pr*q*w(j); }
                  obi=(bidNot+askNot>0)? (bidNot-askNot)/(bidNot+askNot):0;

                  const vwapFill=(levels,targetUSD)=>{ let remain=targetUSD,val=0,qty=0; for(const [ps,qs] of levels){ const pr=+ps, q=+qs; if(!(pr>0&&q>0)) continue; const can=pr*q, take=Math.min(remain,can), tq=take/pr; val+=pr*tq; qty+=tq; remain-=take; if(remain<=1e-6) break; } return { px: qty>0? val/qty : null, filledUSD:(targetUSD-remain) }; };
                  const targ=Math.max(50,SIGNAL_NOTIONAL);
                  const buy=vwapFill(depth.asks,targ), sell=vwapFill(depth.bids,targ);
                  slipL = buy.px? Math.max(0, Math.round((buy.px - mid)/mid*10000)) : slipL;
                  slipS = sell.px? Math.max(0, Math.round((mid - sell.px)/mid*10000)) : slipS;
                  fillL = Math.min(1, buy.filledUSD/Math.max(1,SIGNAL_NOTIONAL));
                  fillS = Math.min(1, sell.filledUSD/Math.max(1,SIGNAL_NOTIONAL));
                }
                const costLong=COST_BPS + Math.max(Math.round(p.spreadBps/2), slipL);
                const costShort=COST_BPS + Math.max(Math.round(p.spreadBps/2), slipS);

                // Base TP/SL from ATR (style-aware)
                let tp_bps_L = Math.round(clamp((p.styleLong==="trend"? TP_TREND_BASE : p.styleLong==="mr"? TP_MR_BASE : TP_BO_BASE) * p.atr_bps, TP_ATR_MIN*p.atr_bps, TP_ATR_MAX*p.atr_bps));
                let sl_bps_L = Math.round(clamp((p.styleLong==="trend"? SL_TREND_BASE : p.styleLong==="mr"? SL_MR_BASE : SL_BO_BASE) * p.atr_bps, SL_ATR_MIN*p.atr_bps, SL_ATR_MAX*p.atr_bps));

                let tp_bps_S = Math.round(clamp((p.styleShort==="trend"? TP_TREND_BASE : p.styleShort==="mr"? TP_MR_BASE : TP_BO_BASE) * p.atr_bps, TP_ATR_MIN*p.atr_bps, TP_ATR_MAX*p.atr_bps));
                let sl_bps_S = Math.round(clamp((p.styleShort==="trend"? SL_TREND_BASE : p.styleShort==="mr"? SL_MR_BASE : SL_BO_BASE) * p.atr_bps, SL_ATR_MIN*p.atr_bps, SL_ATR_MAX*p.atr_bps));

                // Structure floors (15m Donchian(10) + 0.15*ATR)
                if(p.donchLow10!=null){ const structL = Math.max(0, Math.round(((last - p.donchLow10)/last)*10000)) + Math.round(0.15*p.atr_bps); sl_bps_L = Math.max(sl_bps_L, structL); }
                if(p.donchHigh10!=null){ const structS = Math.max(0, Math.round(((p.donchHigh10 - last)/last)*10000)) + Math.round(0.15*p.atr_bps); sl_bps_S = Math.max(sl_bps_S, structS); }

                // Friction buffer (push SL beyond noise)
                sl_bps_L = Math.max(sl_bps_L, costLong + 2);
                sl_bps_S = Math.max(sl_bps_S, costShort + 2);

                // Regime-based widening/tightening
                const widenChop = (p.adx5<20 || p.squeezeRatio>0.60) ? 1.25 : 1.0;
                const tightenStrongTrendLong = (p.adx5>28 && p.styleLong==="trend") ? 0.95 : 1.0;
                const tightenStrongTrendShort= (p.adx5>28 && p.styleShort==="trend")? 0.95 : 1.0;
                sl_bps_L = Math.round(clamp(sl_bps_L * widenChop * tightenStrongTrendLong, SL_ATR_MIN*p.atr_bps, SL_ATR_MAX*p.atr_bps));
                sl_bps_S = Math.round(clamp(sl_bps_S * widenChop * tightenStrongTrendShort, SL_ATR_MIN*p.atr_bps, SL_ATR_MAX*p.atr_bps));

                // OBI micro nudge: against side widens SL 10%
                if(obi < -0.15) sl_bps_L = Math.round(clamp(sl_bps_L*1.10, SL_ATR_MIN*p.atr_bps, SL_ATR_MAX*p.atr_bps));
                if(obi > +0.15) sl_bps_S = Math.round(clamp(sl_bps_S*1.10, SL_ATR_MIN*p.atr_bps, SL_ATR_MAX*p.atr_bps));

                // Confidence n
                const liq = liqPct.get(c.symbol)||0.5;
                const adxF=clamp((p.adx5-16)/14,0,1);
                let nConf = 46 + 26*adxF + 22*liq + 10*Math.abs(obi) - 8*Math.abs(p.pLong0-p.pShort0);
                nConf = Math.round(clamp(nConf, 32, 132));

                const pL_lcb=wilsonLCB(p.pLong0, nConf, WILSON_Z);
                const pS_lcb=wilsonLCB(p.pShort0, nConf, WILSON_Z);

                // EVs
                const expL = Math.round(pL_lcb*tp_bps_L - (1-pL_lcb)*sl_bps_L - costLong);
                const expS = Math.round(pS_lcb*tp_bps_S - (1-pS_lcb)*sl_bps_S - costShort);

                // Choose side
                let side="long", p_win=p.pLong0, p_lcb=pL_lcb, tp_bps=tp_bps_L, sl_bps=sl_bps_L, cost_bps=costLong, style=p.styleLong, fillProb=0;
                if(expS>expL){ side="short"; p_win=p.pShort0; p_lcb=pS_lcb; tp_bps=tp_bps_S; sl_bps=sl_bps_S; cost_bps=costShort; style=p.styleShort; }
                const fpL = (fillL||0), fpS = (fillS||0); fillProb = side==="long"? fpL : fpS;

                // Flexible EV gate (context-aware)
                const hardFloor = 2;
                let dyn = 5   // EXP_LCB_MIN_BPS
                          + (1 - liq)*2
                          + Math.max(0, 12 - p.spreadBps)/12
                          + (fillProb < 0.70 ? 8*(0.70 - fillProb) : 0)
                          + (regime.regime === "trend" ? -1 : +1);
                if (liq >= 0.80 && p.spreadBps <= 6 && fillProb >= 0.85) dyn -= 1;
                dyn = Math.max(hardFloor, Math.round(dyn));
                const costBound = Math.round(10 * (regime.regime === "trend" ? 0.6 : 0.8));
                const floor = Math.max(dyn, costBound);
                const softBand = (p_lcb >= 0.60 && p.spreadBps <= 6 && fillProb >= 0.85) ? 1 : 0;

                const exp_lcb_bps = Math.round(p_lcb*tp_bps - (1-p_lcb)*sl_bps - cost_bps);
                if (exp_lcb_bps < floor - softBand) continue;

                const minFill = (liq >= 0.80 && p.spreadBps <= 6) ? 0.60 : 0.65;
                if (fillProb < minFill) continue;

                const hold_base = (regime.regime==="trend"?760:560) + 240*adxF;
                const hold_sec = Math.round(clamp(hold_base, 480, 2000));

                refined.push({
                  symbol:c.symbol, base:c.base, quote:c.quote, qv:c.qv,
                  side, p_win:+p_win.toFixed(3), p_lcb:+p_lcb.toFixed(3),
                  exp_bps: Math.round(p_win*tp_bps - (1-p_win)*sl_bps - cost_bps),
                  exp_lcb_bps,
                  tp_bps, sl_bps, rrr:+(tp_bps/sl_bps).toFixed(2),
                  tp_atr_mult:+(tp_bps/p.atr_bps).toFixed(2), sl_atr_mult:+(sl_bps/p.atr_bps).toFixed(2),
                  spread_bps:p.spreadBps, cost_bps,
                  adx:+(p.adx5||0).toFixed(1), atr_bps:p.atr_bps,
                  regime: regime.regime, style,
                  n_conf:nConf, obi:+obi.toFixed(3),
                  hold_sec, liq_pct:+liq.toFixed(3),
                  ret5:(()=>{ const r=[]; for(let k=1;k<p.c5.length;k++) r.push(Math.log(p.c5[k]/p.c5[k-1])); return r.slice(-36); })(),
                  fill_prob:+fillProb.toFixed(2)
                });
              }
              console.log(`[gha] refined: ${refined.length}`);

              // -------- Strict selection --------
              refined.sort((a,b)=> b.exp_lcb_bps!==a.exp_lcb_bps ? b.exp_lcb_bps-a.exp_lcb_bps
                              : b.exp_bps!==a.exp_bps ? b.exp_bps-a.exp_bps
                              : b.p_lcb!==a.p_lcb ? b.p_lcb-a.p_lcb
                              : b.qv-a.qv);

              const CORE_CORR_MAX=0.84, OF_CORR_MAX=0.90;
              const core=[], overflow=[];
              const rho=(a,b)=>corr(a.ret5||[],b.ret5||[]);
              const maxCore = Math.min(TOP_N, throttle? Math.max(4, Math.floor(TOP_N*0.6)) : TOP_N);
              const maxOverflow = throttle? 0 : EXTRA_IDEAS_MAX;

              for(const cand of refined){
                if(core.length>=maxCore && overflow.length>=maxOverflow) break;
                if(core.length<maxCore){
                  if(cand.p_lcb>=0.54 && cand.fill_prob>=0.65){
                    let ok=true; for(const s of core){ if(rho(cand,s)>CORE_CORR_MAX){ ok=false; break; } }
                    if(ok){ core.push(cand); continue; }
                  }
                }
                if(overflow.length<maxOverflow){
                  if(cand.p_lcb>=0.58 && cand.exp_lcb_bps>=5+3 && cand.fill_prob>=0.75){
                    let ok=true; for(const s of core.concat(overflow)){ if(rho(cand,s)>OF_CORR_MAX){ ok=false; break; } }
                    if(ok){ overflow.push(cand); continue; }
                  }
                }
              }
              selectedFinal=[...core,...overflow];
              console.log(`[gha] selected(strict): ${selectedFinal.length}`);

              // Recent skip set to avoid repetition across runs (if state persisted)
              state.recentBases = Array.isArray(state.recentBases) ? state.recentBases : [];
              const recentSkip = new Set(state.recentBases.slice(-12).map(x => x.toUpperCase()));

              // -------- Fallback Tier 1 (gentle relax) if strict=0 --------
              if(selectedFinal.length < MIN_IDEAS){
                const need = MAX_IDEAS_TARGET;  // aim for 2–3 "second bests"
                const relaxed = refined.filter(x=>
                  x.spread_bps <= (MAX_SPREAD_BPS+2) &&
                  x.fill_prob >= 0.55 &&
                  x.exp_lcb_bps >= (5 - 2)
                ).sort((a,b)=> b.exp_lcb_bps!==a.exp_lcb_bps ? b.exp_lcb_bps-a.exp_lcb_bps
                          : b.p_lcb!==a.p_lcb ? b.p_lcb-a.p_lcb
                          : (a.spread_bps-b.spread_bps));
                const used=new Set(selectedFinal.map(x=>x.base.toUpperCase()));
                for(const cand of relaxed){
                  if(selectedFinal.length>=need) break;
                  const k=cand.base.toUpperCase();
                  if(used.has(k) || recentSkip.has(k)) continue;
                  let ok=true; for(const s of selectedFinal){ if(rho(cand,s)>0.90){ ok=false; break; } }
                  if(!ok) continue;
                  cand.forced=true; selectedFinal.push(cand); used.add(k);
                }
                if(selectedFinal.length>=MIN_IDEAS){ forcedMode=true; reason = reason==="ok"?"fallback_min_ideas":reason; }
              }

              // -------- Fallback Tier 2 (mega-caps) with rotation + cooldown --------
              if(selectedFinal.length < MIN_IDEAS){
                const MEGA=["BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","XRPUSDT","DOGEUSDT"];
                const used=new Set(selectedFinal.map(x=>x.base.toUpperCase()));
                const start = (persist ? (state.lastMegaIdx||0) : Math.floor(Math.random()*MEGA.length));
                const target = Math.max(MIN_IDEAS, Math.min(MAX_IDEAS_TARGET, 3));
                for(let j=0;j<MEGA.length && selectedFinal.length<target; j++){
                  const sym=MEGA[(start+j)%MEGA.length];
                  const base=sym.replace(/(USDT|USDC|USD)$/,"").toUpperCase();
                  if(used.has(base) || recentSkip.has(base)) continue;

                  // Respect cooldown
                  const lastTs=state.cooldown?.[base]; const now=Date.now();
                  if(lastTs && (now-lastTs) < COOLDOWN_MS) continue;

                  const bk=bookMap.get(sym); if(!bk?.bid||!bk?.ask) continue;
                  const mid=(bk.bid+bk.ask)/2; const spreadBps=Math.round(((bk.ask-bk.bid)/mid)*10000);
                  if(spreadBps>Math.max(14,MAX_SPREAD_BPS+2)) continue;
                  const k5=await fetchK(sym,"5m",K5M); if(!k5) continue;
                  const h5=k5.map(x=>+x[2]), l5=k5.map(x=>+x[3]), c5=k5.map(x=>+x[4]);
                  const { adx:adx5, atr:atr5 } = computeADX_ATR(h5,l5,c5,ADX_P)||{}; if(!(adx5&&atr5)) continue;
                  const atr_bps=Math.round((atr5/(c5.at(-1)||1))*10000);
                  const em21=ema(c5,EMA_FAST), em50=ema(c5,EMA_SLOW);
                  const trend=(c5.at(-1)>em21 && em21>em50) ? "long" : (c5.at(-1)<em21 && em21<em50) ? "short" : "long";
                  const p_win=0.52, p_lcb=0.50;
                  const tp_bps=Math.round(clamp(1.0*atr_bps, TP_ATR_MIN*atr_bps, TP_ATR_MAX*atr_bps));
                  const sl_bps=Math.round(clamp(0.7*atr_bps, SL_ATR_MIN*atr_bps, SL_ATR_MAX*atr_bps));
                  const cost_bps=10 + Math.round(spreadBps/2);
                  const exp_bps=Math.round(p_win*tp_bps - (1-p_win)*sl_bps - cost_bps);
                  selectedFinal.push({
                    symbol:sym, base:sym.replace(/(USDT|USDC|USD)$/,""), quote:sym.replace(/^.*(USDT|USDC|USD)$/,"$1"), qv:1e12,
                    side:trend, p_win:+p_win.toFixed(3), p_lcb:+p_lcb.toFixed(3),
                    exp_bps, exp_lcb_bps: Math.max(exp_bps-2, -2),
                    tp_bps, sl_bps, rrr:+(tp_bps/sl_bps).toFixed(2),
                    tp_atr_mult:+(tp_bps/atr_bps).toFixed(2), sl_atr_mult:+(sl_bps/atr_bps).toFixed(2),
                    spread_bps:spreadBps, cost_bps,
                    adx:+(adx5||0).toFixed(1), atr_bps,
                    regime: regime.regime, style:"trend",
                    n_conf:45, obi:0, hold_sec:720, liq_pct:1,
                    ret5:(()=>{ const r=[]; for(let k=1;k<c5.length;k++) r.push(Math.log(c5[k]/c5[k-1])); return r.slice(-36); })(),
                    fill_prob:0.9, forced:true
                  });
                  used.add(base);
                  forcedMode=true; reason = reason==="ok"?"fallback_megacap":reason;
                }
                // advance rotation pointer if persisted
                state.lastMegaIdx = (start + 1) % MEGA.length;
              }

              // Sizing & POST
              const softmax=(arr,t=20)=>{ const ex=arr.map(x=>Math.exp(x/t)); const s=ex.reduce((a,b)=>a+b,0)||1; return ex.map(x=>x/s); };
              const wExp=softmax(selectedFinal.map(x=>x.exp_lcb_bps||x.exp_bps||0),20);
              const TARGET_PORT_RISK_BPS=52;

              const picks = selectedFinal.map((x,i)=>({
                symbol: x.base,               // keep style (base symbol)
                symbol_full: x.symbol,        // full symbol also provided
                quote: x.quote,
                side: x.side, rank:i+1,
                ttl_sec: clamp(Math.round((x.hold_sec||900) * (x.forced?0.9:1.0) + i*10), 420, 2000),
                p_win:x.p_win, p_lcb:x.p_lcb,
                exp_bps:x.exp_bps, exp_lcb_bps:x.exp_lcb_bps,
                tp_bps:x.tp_bps, sl_bps:x.sl_bps, rrr:x.rrr,
                tp_atr_mult:x.tp_atr_mult, sl_atr_mult:x.sl_atr_mult,
                spread_bps:x.spread_bps, cost_bps:x.cost_bps,
                adx:x.adx, atr_bps:x.atr_bps, n_conf:x.n_conf, obi:x.obi,
                regime:x.regime, style:x.style,
                liq_pct:x.liq_pct, fill_prob:x.fill_prob,
                size_bps: x.sl_bps>0 ? Math.min(220, Math.round((wExp[i]||0.2)*TARGET_PORT_RISK_BPS/x.sl_bps*100*(x.forced?0.6:1.0))) : 0,
                quality_tag: x.forced ? "forced_low_conf" : "strict"
              }));

              try{
                const nowMs=Date.now(); const ideasTs=new Date(nowMs).toISOString();
                for(const p of picks){
                  const bk=bookMap.get(p.symbol_full); const mid=bk? (bk.bid+bk.ask)/2 : 0;
                  state.cooldown[p.symbol]=nowMs;
                  state.pending.push({
                    ts:ideasTs, ts_ms:nowMs, symbolFull:p.symbol_full, base:p.symbol, quote:p.quote, side:p.side,
                    entry_price:mid, hold_sec:p.ttl_sec, tp_bps:p.tp_bps, sl_bps:p.sl_bps, regime:p.regime, cost_bps:p.cost_bps
                  });
                  // track recency to reduce repetition across runs
                  try{ state.recentBases.push(String(p.symbol).toUpperCase()); }catch{}
                }
                if(state.pending.length>600) state.pending=state.pending.slice(-600);
                if(state.recentBases.length>60) state.recentBases = state.recentBases.slice(-60);
                state.last_ts=new Date().toISOString();
                await saveState(persist,state);
              }catch(e){ log("state save warn", e?.message||e); }

              const payload={ ts:new Date().toISOString(), mode:"normal", env:ENV_NAME, source:"external_pusher",
                meta:{ origin:"github_actions", reason, forced_mode:forcedMode, exchange:"mexc", exchange_base:BASE, env:ENV_NAME },
                top_n:picks.length||0, ideas:picks||[] };

              console.log(`[gha] pushing ${picks.length} ideas to ${PUSH_URL}`);
              try{
                const r=await fetchWithTimeout(PUSH_URL,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":`Bearer ${PUSH_TOKEN}` }, body: JSON.stringify(payload) },15000);
                let txt=""; try{ txt=await r.text(); }catch{}; console.log(`[gha] push status ${r?.status||"ERR"} ${(txt||"").slice(0,400)}`);
              }catch(e){
                console.log(`[gha] push failed ${e?.message||e}`);
              }

            }catch(e){
              const payload={ ts:new Date().toISOString(), mode:"normal", env:ENV_NAME, source:"external_pusher",
                meta:{ origin:"github_actions", reason: reason==="ok"?"data_error":reason, error:(e?.message||String(e)).slice(0,240), env:ENV_NAME },
                top_n:0, ideas:[] };
              console.log(`[gha] pushing 0 ideas to ${PUSH_URL}`);
              try{
                const r=await fetchWithTimeout(PUSH_URL,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":`Bearer ${PUSH_TOKEN}` }, body: JSON.stringify(payload) },15000);
                let txt=""; try{ txt=await r.text(); }catch{}; console.log(`[gha] push status ${r?.status||"ERR"} ${(txt||"").slice(0,300)}`);
              }catch(e2){ console.log(`[gha] push failed ${e2?.message||e2}`); }
            }
          })();
          NODE

          EXIT_CODE=$?
          set -e

          if [[ $EXIT_CODE -ne 0 ]]; then
            echo "[gha] pusher exited with code $EXIT_CODE — sending minimal payload"
            health_url="${WORKER_PUSH_URL/\/signals\/push/\/health}"
            curl -sS -H "Authorization: Bearer ${PUSH_TOKEN}" --max-time 8 "$health_url" >/dev/null || true
            now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            payload='{"ts":"'"$now"'","mode":"normal","env":"paper","source":"external_pusher","meta":{"origin":"github_actions","reason":"fallback_node_error","env":"paper"},"top_n":0,"ideas":[]}'
            http_code=$(curl -sS -o /tmp/push_resp.txt -w "%{http_code}" -X POST \
              -H "Content-Type: application/json" -H "Authorization: Bearer ${PUSH_TOKEN}" \
              --data "${payload}" --max-time 12 "${WORKER_PUSH_URL}" || true)
            body="$(head -c 400 /tmp/push_resp.txt || true)"
            echo "[gha] push status ${http_code} ${body}"
            exit 0
          fi
